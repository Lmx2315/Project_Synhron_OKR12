
#ifndef	__ADC_C
#define __ADC_C

#include "opora.h"
#include "adc.h"

uint32_t CurrentResult, LastResult;

void ADCInit()
{
//	В контроллера 1986ВЕ1 только 1 АЦП
    ADC->ADC1_CFG  =0x00000000; //обнуление регистра

	ADC->ADC1_CFG |= (  1<< 0)   //Включение АЦП 1 – включено 0 – выключено
				//	|(  1<< 0)   //Начало преобразования Запись “1” начинает процесс преобразования, сбрасывается автоматически
					|(  1<< 2)   //Выбор источника синхросигнала CLK работы ADC 1 – ACLK 0 – PCLK
				//	|(  1<< 3)   //Выбор способа запуска АЦП. 1 – последовательное преобразование, автоматический запуск после завершения предыдущего преобразования 0 – одиночное преобразование
					|(0x1<< 4)   //Выбор аналогового канала, по которому поступает сигнал для преобразования 00000 – 0 канал 00001 – 1 канал … 11111 – 31 канал
				//	|(  1<< 9)   //Выбор переключения каналов 1 – переключение включено (перебираются каналы, выбранные в регистре выбора канала) 0 – используется только выбранный канал
				//	|(  1<<10)   //Разрешение автоматического контролирования уровней 1 – Разрешено, выработка прерывания при выходе за диапазон в регистрах границы обработки 0 – не разрешено
				//	|(  1<<11)   //Выбор источника опорных напряжений 0 – внутренне опорное напряжение (от Audd и Auss)
					|(0x1<<12)   //Выбор коэффициента деления входной частоты 0000 – CLK 0001 – CLK/2 0010 – CLK/4 0011 – CLK/8
				//	|(  1<<16)   //Записывать всегда ноль
					|(  1<<17)   //В регистре ADC1_CFG. Включение датчика температуры и источника опорного напряжения
				//	|(  1<<18)   //В регистре ADC1_CFG. Включение выходного усилителя для датчика температуры и источника опорного напряжения
				//	|(  1<<19)   //Выбор для оцифровки датчика температуры
				//	|(  1<<20)   //Выбор для оцифровки источника опорного напряжения на 1.23В
					|(0x6<<21)   //Подстройка опорного напряжения
					|(0x7<<25)   //Задержка перед началом следующего преобразования после завершения предыдущего при последовательном переборе каналов
					|(0xf<<28);  //Задержка между началом преобразования ADC1 при последовательном переборе, либо работе на один канал.
	
	ADC->ADC1_CHSEL  = 0x00000000; //обнуление регистра перебора каналов
	ADC->ADC1_CHSEL |= (1<< 0)  //выбор нулевого канала
					  |(1<< 1)  //выбор первого канала
					  |(1<<31); //выбор температурного датчика

	
					
	ADC->ADC1_STATUS = 0;
}

unsigned short ADC_m(unsigned char ch)

{
    ADC->ADC1_CFG &=  (~(31<<4));	//обнуление каналов измерения - подготовка к установке нового канала
    ADC->ADC1_CFG |=    (ch<<4);	//Выбор аналогового канала, по которому поступает сигнал для преобразования 00000 – 0 канал 00001 – 1 канал … 11111 – 31 канал
	ADC->ADC1_CFG |=    ( 1<<1);	//start of ADC
		
		while((ADC->ADC1_STATUS&(1<<2))!=(1<<2));
		CurrentResult = (uint16_t)ADC->ADC1_RESULT&0xFFF8;
		
		return CurrentResult;
}


#endif	//__ADC_C

