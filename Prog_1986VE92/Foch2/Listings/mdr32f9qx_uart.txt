; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list -c --asm --interleave -o.\objects\mdr32f9qx_uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mdr32f9qx_uart.d --cpu=Cortex-M3 --apcs=interwork -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE\Device\MDR1986BE92 -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=513 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 -W --enum_is_int --signed_chars C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;82       */
;;;83     void UART_DeInit(MDR_UART_TypeDef* UARTx)
000000  2100              MOVS     r1,#0
;;;84     {
;;;85       /* Check the parameters */
;;;86       assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;87     
;;;88       /* Clear UART CR */
;;;89       UARTx->CR = 0;
000002  6301              STR      r1,[r0,#0x30]
;;;90       UARTx->LCR_H = 0;
000004  62c1              STR      r1,[r0,#0x2c]
;;;91       UARTx->RSR_ECR = 0;
000006  6041              STR      r1,[r0,#4]
;;;92       UARTx->FR = UART_FLAG_TXFE | UART_FLAG_RXFE;
000008  2290              MOVS     r2,#0x90
00000a  6182              STR      r2,[r0,#0x18]
;;;93       UARTx->ILPR = 0;
00000c  6201              STR      r1,[r0,#0x20]
;;;94       UARTx->IBRD = 0;
00000e  6241              STR      r1,[r0,#0x24]
;;;95       UARTx->FBRD = 0;
000010  6281              STR      r1,[r0,#0x28]
;;;96       UARTx->IFLS = UART_IT_FIFO_LVL_8words;
000012  2202              MOVS     r2,#2
000014  6342              STR      r2,[r0,#0x34]
;;;97       UARTx->IMSC = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;98       UARTx->DMACR = 0;
000018  6481              STR      r1,[r0,#0x48]
;;;99       /* Set UART CR[RXE] and UART CR[TXE] bits */
;;;100      UARTx->CR = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
00001a  f44f7140          MOV      r1,#0x300
00001e  6301              STR      r1,[r0,#0x30]
;;;101    }
000020  4770              BX       lr
;;;102    
                          ENDP

                  UART_Init PROC
;;;112      */
;;;113    BaudRateStatus UART_Init ( MDR_UART_TypeDef* UARTx,
000022  b570              PUSH     {r4-r6,lr}
;;;114    						   UART_InitTypeDef* UART_InitStruct )
;;;115    {
000024  b086              SUB      sp,sp,#0x18
000026  4604              MOV      r4,r0
000028  460d              MOV      r5,r1
;;;116    	uint32_t tmpreg, cpuclock;
;;;117    	uint32_t realspeed, speederror;
;;;118    	uint32_t divider;
;;;119    	uint32_t integerdivider;
;;;120    	uint32_t fractionaldivider;
;;;121    	RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;122    
;;;123    	/* Check the parameters */
;;;124    	assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;125    	assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));
;;;126    	assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLength));
;;;127    	assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
;;;128    	assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
;;;129    	assert_param(IS_UART_FIFOMODE(UART_InitStruct->UART_FIFOMode));
;;;130    	assert_param(IS_UART_HARDWARE_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
;;;131    
;;;132    	/* Configure the UART Baud Rate */
;;;133    	RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;134    	cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
;;;135    #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;136    	if(( UARTx == MDR_UART3 ) || (UARTx == MDR_UART4))
;;;137    		tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;138    	else
;;;139    		if(( UARTx == MDR_UART1 ) || (UARTx == MDR_UART2))
;;;140    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;141    			tmpreg = MDR_RST_CLK->UART_CLOCK;
000030  4962              LDR      r1,|L1.444|
000032  9800              LDR      r0,[sp,#0]
000034  6a89              LDR      r1,[r1,#0x28]
;;;142    
;;;143    	if (UARTx == MDR_UART1) {
000036  4b62              LDR      r3,|L1.448|
;;;144    		cpuclock /= (1 << (tmpreg & UART1_BRG_Mask));
000038  2201              MOVS     r2,#1
00003a  429c              CMP      r4,r3                 ;143
00003c  d102              BNE      |L1.68|
00003e  f0010107          AND      r1,r1,#7
000042  e004              B        |L1.78|
                  |L1.68|
;;;145    	}
;;;146    	else
;;;147    		if (UARTx == MDR_UART2) {
000044  4b5f              LDR      r3,|L1.452|
000046  429c              CMP      r4,r3
000048  d104              BNE      |L1.84|
;;;148    			cpuclock /= (1 << ((tmpreg & UART2_BRG_Mask) >> UART2_BRG_Offs));
00004a  f3c12102          UBFX     r1,r1,#8,#3
                  |L1.78|
00004e  408a              LSLS     r2,r2,r1
000050  fbb0f0f2          UDIV     r0,r0,r2
                  |L1.84|
;;;149    		}
;;;150    #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;151    		else
;;;152    			if(UARTx == MDR_UART3) {
;;;153    				cpuclock /= (1 << (tmpreg & UART3_BRG_Mask ));
;;;154    			}
;;;155    			else
;;;156    				if(UARTx == MDR_UART4) {
;;;157    					cpuclock /= (1 << ((tmpreg & UART4_BRG_Mask) >> UART4_BRG_Offs));
;;;158    				}
;;;159    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;160    
;;;161    	/* Determine the integer part */
;;;162    	divider = cpuclock / (UART_InitStruct->UART_BaudRate >> 2);
000054  6829              LDR      r1,[r5,#0]
000056  088a              LSRS     r2,r1,#2
000058  fbb0f3f2          UDIV     r3,r0,r2
;;;163    	integerdivider = divider >> 6;
00005c  099a              LSRS     r2,r3,#6
;;;164    	/* Determine the fractional part */
;;;165    	fractionaldivider = (divider & FBRD_Fract_Mask);
00005e  f003033f          AND      r3,r3,#0x3f
;;;166    	/* Determine the speed error */
;;;167    	realspeed = (cpuclock * 4) / ((integerdivider * 64) + fractionaldivider);
000062  0080              LSLS     r0,r0,#2
000064  eb031682          ADD      r6,r3,r2,LSL #6
000068  fbb0f0f6          UDIV     r0,r0,r6
;;;168    	speederror = ((realspeed - UART_InitStruct->UART_BaudRate) * 128)
00006c  1a40              SUBS     r0,r0,r1
00006e  01c0              LSLS     r0,r0,#7
000070  fbb0f0f1          UDIV     r0,r0,r1
;;;169    			/ UART_InitStruct->UART_BaudRate;
;;;170    	if (speederror > 2) {
000074  2802              CMP      r0,#2
000076  d902              BLS      |L1.126|
;;;171    		return BaudRateInvalid;
000078  2000              MOVS     r0,#0
                  |L1.122|
;;;172    	}
;;;173    	/* Write UART Baud Rate */
;;;174    	UARTx->IBRD = integerdivider;
;;;175    	UARTx->FBRD = fractionaldivider;
;;;176    
;;;177    	/* UART LCR_H configuration */
;;;178    	/* Set the WLEN bits according to UART_WordLength value */
;;;179    	/* Set STP2 bit according to UART_StopBits value */
;;;180    	/* Set PEN, EPS and SPS bits according to UART_Parity value */
;;;181    	/* Set FEN bit according to UART_FIFOMode value */
;;;182    	tmpreg = UARTx->LCR_H;
;;;183    	tmpreg |= UART_InitStruct->UART_WordLength | UART_InitStruct->UART_StopBits
;;;184    			| UART_InitStruct->UART_Parity | UART_InitStruct->UART_FIFOMode;
;;;185    	UARTx->LCR_H = tmpreg;
;;;186    
;;;187    	/* UART CR configuration */
;;;188    	tmpreg = UARTx->CR;
;;;189    	/* Clear UART CR Flow control bits */
;;;190    	tmpreg &= ~CR_FC_Mask;
;;;191    	/* Set UART CR Flow control bits */
;;;192    	tmpreg |= UART_InitStruct->UART_HardwareFlowControl;
;;;193    	/* Write to UART CR */
;;;194    	UARTx->CR = tmpreg;
;;;195    
;;;196    	return BaudRateValid;
;;;197    }
00007a  b006              ADD      sp,sp,#0x18
00007c  bd70              POP      {r4-r6,pc}
                  |L1.126|
00007e  6262              STR      r2,[r4,#0x24]         ;174
000080  62a3              STR      r3,[r4,#0x28]         ;175
000082  6ae0              LDR      r0,[r4,#0x2c]         ;182
000084  88a9              LDRH     r1,[r5,#4]            ;183
000086  88ea              LDRH     r2,[r5,#6]            ;183
000088  896b              LDRH     r3,[r5,#0xa]          ;183
00008a  4311              ORRS     r1,r1,r2              ;183
00008c  892a              LDRH     r2,[r5,#8]            ;183
00008e  431a              ORRS     r2,r2,r3              ;183
000090  4311              ORRS     r1,r1,r2              ;183
000092  4301              ORRS     r1,r1,r0              ;183
000094  62e1              STR      r1,[r4,#0x2c]         ;185
000096  6b20              LDR      r0,[r4,#0x30]         ;188
000098  f64f7180          MOV      r1,#0xff80            ;190
00009c  4388              BICS     r0,r0,r1              ;190
00009e  89a9              LDRH     r1,[r5,#0xc]          ;192
0000a0  4301              ORRS     r1,r1,r0              ;192
0000a2  6321              STR      r1,[r4,#0x30]         ;194
0000a4  2001              MOVS     r0,#1                 ;196
0000a6  e7e8              B        |L1.122|
;;;198    
                          ENDP

                  UART_StructInit PROC
;;;204      */
;;;205    void UART_StructInit(UART_InitTypeDef* UART_InitStruct)
0000a8  f44f5116          MOV      r1,#0x2580
;;;206    {
;;;207      /* UART_InitStruct members default value */
;;;208      UART_InitStruct->UART_BaudRate = 9600;
;;;209      UART_InitStruct->UART_WordLength = UART_WordLength5b;
0000ac  6001              STR      r1,[r0,#0]
0000ae  2100              MOVS     r1,#0
0000b0  8081              STRH     r1,[r0,#4]
;;;210      UART_InitStruct->UART_StopBits = UART_StopBits1;
0000b2  80c1              STRH     r1,[r0,#6]
;;;211      UART_InitStruct->UART_Parity = UART_Parity_No;
0000b4  8101              STRH     r1,[r0,#8]
;;;212      UART_InitStruct->UART_FIFOMode = UART_FIFO_OFF;
0000b6  8141              STRH     r1,[r0,#0xa]
;;;213      UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
0000b8  f44f7140          MOV      r1,#0x300
0000bc  8181              STRH     r1,[r0,#0xc]
;;;214    }
0000be  4770              BX       lr
;;;215    
                          ENDP

                  UART_Cmd PROC
;;;224      */
;;;225    void UART_Cmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
0000c0  2900              CMP      r1,#0
;;;226    {
;;;227      /* Check the parameters */
;;;228      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;229      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;230    
;;;231      if (NewState != DISABLE)
;;;232      {
;;;233        /* Enable the selected UART by setting the UARTEN bit in the CR register */
;;;234        UARTx->CR |= CR_EN_Set;
;;;235      }
;;;236      else
;;;237      {
;;;238        /* Disable the selected UART by clearing the UARTEN bit in the CR register */
;;;239        UARTx->CR &= CR_EN_Reset;
0000c2  6b01              LDR      r1,[r0,#0x30]
0000c4  d002              BEQ      |L1.204|
0000c6  f0410101          ORR      r1,r1,#1              ;234
0000ca  e002              B        |L1.210|
                  |L1.204|
0000cc  f64f72fe          MOV      r2,#0xfffe
0000d0  4011              ANDS     r1,r1,r2
                  |L1.210|
0000d2  6301              STR      r1,[r0,#0x30]         ;234
;;;240      }
;;;241    }
0000d4  4770              BX       lr
;;;242    
                          ENDP

                  UART_ITConfig PROC
;;;264      */
;;;265    void UART_ITConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT, FunctionalState NewState)
0000d6  2a00              CMP      r2,#0
;;;266    {
;;;267      /* Check the parameters */
;;;268      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;269      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;270      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;271    
;;;272      if (NewState != DISABLE)
;;;273      {
;;;274        UARTx->IMSC |= UART_IT;
;;;275      }
;;;276      else
;;;277      {
;;;278        UARTx->IMSC &= ~UART_IT;
0000d8  6b82              LDR      r2,[r0,#0x38]
0000da  d001              BEQ      |L1.224|
0000dc  430a              ORRS     r2,r2,r1              ;274
0000de  e000              B        |L1.226|
                  |L1.224|
0000e0  438a              BICS     r2,r2,r1
                  |L1.226|
0000e2  6382              STR      r2,[r0,#0x38]         ;274
;;;279      }
;;;280    }
0000e4  4770              BX       lr
;;;281    
                          ENDP

                  UART_GetITStatus PROC
;;;301      */
;;;302    ITStatus UART_GetITStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
0000e6  6bc0              LDR      r0,[r0,#0x3c]
;;;303    {
;;;304      ITStatus bitstatus;
;;;305    
;;;306      /* Check the parameters */
;;;307      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;308      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;309    
;;;310      if ((UARTx->RIS & UART_IT) == UART_IT)
0000e8  4381              BICS     r1,r1,r0
0000ea  d001              BEQ      |L1.240|
;;;311      {
;;;312        bitstatus = SET;
;;;313      }
;;;314      else
;;;315      {
;;;316        bitstatus = RESET;
0000ec  2000              MOVS     r0,#0
;;;317      }
;;;318    
;;;319      return bitstatus;
;;;320    }
0000ee  4770              BX       lr
                  |L1.240|
0000f0  2001              MOVS     r0,#1                 ;312
0000f2  4770              BX       lr
;;;321    
                          ENDP

                  UART_GetITStatusMasked PROC
;;;341      */
;;;342    ITStatus UART_GetITStatusMasked(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
0000f4  6c00              LDR      r0,[r0,#0x40]
;;;343    {
;;;344      ITStatus bitstatus;
;;;345    
;;;346      /* Check the parameters */
;;;347      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;348      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;349    
;;;350      if (UARTx->MIS & UART_IT)
0000f6  4008              ANDS     r0,r0,r1
0000f8  d000              BEQ      |L1.252|
;;;351      {
;;;352        bitstatus = SET;
0000fa  2001              MOVS     r0,#1
                  |L1.252|
;;;353      }
;;;354      else
;;;355      {
;;;356        bitstatus = RESET;
;;;357      }
;;;358    
;;;359      return bitstatus;
;;;360    }
0000fc  4770              BX       lr
;;;361    
                          ENDP

                  UART_ClearITPendingBit PROC
;;;381      */
;;;382    void UART_ClearITPendingBit(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
0000fe  6c42              LDR      r2,[r0,#0x44]
;;;383    {
;;;384      /* Check the parameters */
;;;385      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;386      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;387    
;;;388      UARTx->ICR |= UART_IT;
000100  430a              ORRS     r2,r2,r1
000102  6442              STR      r2,[r0,#0x44]
;;;389    }
000104  4770              BX       lr
;;;390    
                          ENDP

                  UART_DMAConfig PROC
;;;411      */
;;;412    void UART_DMAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT_RB_LVL, uint32_t UART_IT_TB_LVL)
000106  ea4201c1          ORR      r1,r2,r1,LSL #3
;;;413    {
;;;414      /* Check the parameters */
;;;415      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;416      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_RB_LVL));
;;;417      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_TB_LVL));
;;;418    
;;;419      UARTx->IFLS = (UART_IT_RB_LVL << 3) | UART_IT_TB_LVL;
00010a  6341              STR      r1,[r0,#0x34]
;;;420    }
00010c  4770              BX       lr
;;;421    
                          ENDP

                  UART_DMACmd PROC
;;;436      */
;;;437    void UART_DMACmd(MDR_UART_TypeDef* UARTx, uint32_t UART_DMAReq, FunctionalState NewState)
00010e  2a00              CMP      r2,#0
;;;438    {
;;;439      /* Check the parameters */
;;;440      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;441      assert_param(IS_UART_DMAREQ(UART_DMAReq));
;;;442      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;443    
;;;444      if (NewState != DISABLE)
;;;445      {
;;;446        /* Enable the DMA transfer for selected requests and DMAONERR bit
;;;447           in the UART DMACR register */
;;;448        UARTx->DMACR |= UART_DMAReq;
;;;449      }
;;;450      else
;;;451      {
;;;452        /* Disable the DMA transfer for selected requests and DMAONERR bit
;;;453           in the UART DMACR register */
;;;454        UARTx->DMACR &= (uint16_t)~UART_DMAReq;
000110  6c82              LDR      r2,[r0,#0x48]
000112  d001              BEQ      |L1.280|
000114  430a              ORRS     r2,r2,r1              ;448
000116  e002              B        |L1.286|
                  |L1.280|
000118  43c9              MVNS     r1,r1
00011a  b289              UXTH     r1,r1
00011c  400a              ANDS     r2,r2,r1
                  |L1.286|
00011e  6482              STR      r2,[r0,#0x48]         ;448
;;;455      }
;;;456    }
000120  4770              BX       lr
;;;457    
                          ENDP

                  UART_SendData PROC
;;;465      */
;;;466    void UART_SendData(MDR_UART_TypeDef* UARTx, uint16_t Data)
000122  b2c9              UXTB     r1,r1
;;;467    {
;;;468      /* Check the parameters */
;;;469      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;470      assert_param(IS_UART_DATA(Data));
;;;471    
;;;472      /* Transmit Data */
;;;473      UARTx->DR = (Data & (uint16_t)0x0FF);
000124  6001              STR      r1,[r0,#0]
;;;474    }
000126  4770              BX       lr
;;;475    
                          ENDP

                  UART_ReceiveData PROC
;;;482      */
;;;483    uint16_t UART_ReceiveData(MDR_UART_TypeDef* UARTx)
000128  6800              LDR      r0,[r0,#0]
;;;484    {
;;;485      /* Check the parameters */
;;;486      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;487    
;;;488      /* Receive Data */
;;;489      return (uint16_t)(UARTx->DR);
00012a  b280              UXTH     r0,r0
;;;490    }
00012c  4770              BX       lr
;;;491    
                          ENDP

                  UART_BreakLine PROC
;;;500      */
;;;501    void UART_BreakLine(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
00012e  2900              CMP      r1,#0
;;;502    {
;;;503      /* Check the parameters */
;;;504      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;505      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;506    
;;;507      if (NewState != DISABLE)
;;;508      {
;;;509        /* Set BRK bit in the UART LCR_H register */
;;;510        UARTx->LCR_H |= LCR_H_BRK_Set;
;;;511      }
;;;512      else
;;;513      {
;;;514        /* Reset BRK bit in the UART LCR_H register */
;;;515        UARTx->LCR_H |= LCR_H_BRK_Reset;
000130  6ac1              LDR      r1,[r0,#0x2c]
000132  d002              BEQ      |L1.314|
000134  f0410101          ORR      r1,r1,#1              ;510
000138  e002              B        |L1.320|
                  |L1.314|
00013a  f64f72fe          MOV      r2,#0xfffe
00013e  4311              ORRS     r1,r1,r2
                  |L1.320|
000140  62c1              STR      r1,[r0,#0x2c]         ;510
;;;516      }
;;;517    }
000142  4770              BX       lr
;;;518    
                          ENDP

                  UART_IrDAConfig PROC
;;;529      */
;;;530    void UART_IrDAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IrDAMode)
000144  b530              PUSH     {r4,r5,lr}
;;;531    {
000146  b085              SUB      sp,sp,#0x14
000148  460d              MOV      r5,r1
00014a  4604              MOV      r4,r0
;;;532      uint32_t cpuclock;
;;;533      RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;534    
;;;535      /* Check the parameters */
;;;536      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;537      assert_param(IS_UART_IRDA_MODE(UART_IrDAMode));
;;;538    
;;;539      if (UART_IrDAMode == UART_IrDAMode_LowPower)
00014c  2904              CMP      r1,#4
00014e  d108              BNE      |L1.354|
;;;540      {
;;;541        /* Configure the UART ILPR */
;;;542        RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
000150  4668              MOV      r0,sp
000152  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;543        cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
;;;544        UARTx->ILPR = cpuclock / IrLPBaud16;
000156  9800              LDR      r0,[sp,#0]
000158  f44f11e1          MOV      r1,#0x1c2000
00015c  fbb0f0f1          UDIV     r0,r0,r1
000160  6220              STR      r0,[r4,#0x20]
                  |L1.354|
;;;545      }
;;;546      UARTx->CR |= UART_IrDAMode;
000162  6b20              LDR      r0,[r4,#0x30]
000164  4328              ORRS     r0,r0,r5
000166  6320              STR      r0,[r4,#0x30]
;;;547    }
000168  b005              ADD      sp,sp,#0x14
00016a  bd30              POP      {r4,r5,pc}
;;;548    
                          ENDP

                  UART_IrDACmd PROC
;;;557      */
;;;558    void UART_IrDACmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
00016c  2900              CMP      r1,#0
;;;559    {
;;;560      /* Check the parameters */
;;;561      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;562      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;563    
;;;564      if (NewState != DISABLE)
;;;565      {
;;;566        /* Set SIREN bit in the UART CR register */
;;;567        UARTx->CR |= CR_SIREN_Set;
;;;568      }
;;;569      else
;;;570      {
;;;571        /* Reset SIREN bit in the UART CR register */
;;;572        UARTx->CR |= CR_SIREN_Reset;
00016e  6b01              LDR      r1,[r0,#0x30]
000170  d002              BEQ      |L1.376|
000172  f0410102          ORR      r1,r1,#2              ;567
000176  e002              B        |L1.382|
                  |L1.376|
000178  f64f72fd          MOV      r2,#0xfffd
00017c  4311              ORRS     r1,r1,r2
                  |L1.382|
00017e  6301              STR      r1,[r0,#0x30]         ;567
;;;573      }
;;;574    }
000180  4770              BX       lr
;;;575    
                          ENDP

                  UART_GetFlagStatus PROC
;;;593      */
;;;594    FlagStatus UART_GetFlagStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_FLAG)
000182  6980              LDR      r0,[r0,#0x18]
;;;595    {
;;;596      FlagStatus bitstatus;
;;;597    
;;;598      /* Check the parameters */
;;;599      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;600      assert_param(IS_UART_FLAG(UART_FLAG));
;;;601    
;;;602      if (UARTx->FR & UART_FLAG)
000184  4008              ANDS     r0,r0,r1
000186  d000              BEQ      |L1.394|
;;;603      {
;;;604        bitstatus = SET;
000188  2001              MOVS     r0,#1
                  |L1.394|
;;;605      }
;;;606      else
;;;607      {
;;;608        bitstatus = RESET;
;;;609      }
;;;610      return bitstatus;
;;;611    }
00018a  4770              BX       lr
;;;612    
                          ENDP

                  UART_BRGInit PROC
;;;630      */
;;;631    void UART_BRGInit(MDR_UART_TypeDef* UARTx, uint32_t UART_BRG)
00018c  4b0b              LDR      r3,|L1.444|
;;;632    {
00018e  b510              PUSH     {r4,lr}
;;;633      uint32_t tmpreg;
;;;634    
;;;635      /* Check the parameters */
;;;636      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;637      assert_param(IS_UART_CLOCK_BRG(UART_BRG));
;;;638    
;;;639      tmpreg = MDR_RST_CLK->UART_CLOCK;
000190  6a9a              LDR      r2,[r3,#0x28]
;;;640    
;;;641      if (UARTx == MDR_UART1)
000192  4c0b              LDR      r4,|L1.448|
000194  42a0              CMP      r0,r4
000196  d105              BNE      |L1.420|
;;;642      {
;;;643        tmpreg |= RST_CLK_UART_CLOCK_UART1_CLK_EN;
000198  f02200ff          BIC      r0,r2,#0xff
;;;644        tmpreg &= ~RST_CLK_UART_CLOCK_UART1_BRG_Msk;
00019c  f0407280          ORR      r2,r0,#0x1000000
;;;645        tmpreg |= UART_BRG;
0001a0  430a              ORRS     r2,r2,r1
0001a2  e008              B        |L1.438|
                  |L1.420|
;;;646      }
;;;647      else if (UARTx == MDR_UART2)
0001a4  4c07              LDR      r4,|L1.452|
0001a6  42a0              CMP      r0,r4
0001a8  d105              BNE      |L1.438|
;;;648      {
;;;649        tmpreg |= RST_CLK_UART_CLOCK_UART2_CLK_EN;
0001aa  f422407f          BIC      r0,r2,#0xff00
;;;650        tmpreg &= ~RST_CLK_UART_CLOCK_UART2_BRG_Msk;
0001ae  f0407000          ORR      r0,r0,#0x2000000
;;;651        tmpreg |= (UART_BRG << 8);
0001b2  ea402201          ORR      r2,r0,r1,LSL #8
                  |L1.438|
;;;652      }
;;;653      MDR_RST_CLK->UART_CLOCK = tmpreg;
0001b6  629a              STR      r2,[r3,#0x28]
;;;654    }
0001b8  bd10              POP      {r4,pc}
;;;655    
                          ENDP

0001ba  0000              DCW      0x0000
                  |L1.444|
                          DCD      0x40020000
                  |L1.448|
                          DCD      0x40030000
                  |L1.452|
                          DCD      0x40038000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH|
#line 144
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
