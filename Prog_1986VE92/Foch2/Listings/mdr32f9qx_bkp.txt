; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list -c --asm --interleave -o.\objects\mdr32f9qx_bkp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mdr32f9qx_bkp.d --cpu=Cortex-M3 --apcs=interwork -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE\Device\MDR1986BE92 -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=513 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 -W --enum_is_int --signed_chars C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_bkp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  BKP_DeInit PROC
;;;101      */
;;;102    void BKP_DeInit(void)
000000  4b30              LDR      r3,|L1.196|
;;;103    {
;;;104      #define BKP_RTC_CS_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CS) - BKP_OFFSET)/4)
;;;105      #define BKP_REG_0F_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0F) - BKP_OFFSET)/4)
;;;106      #define BKP_REG_0E_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0E) - BKP_OFFSET)/4)
;;;107      #define BKP_RTC_CNT_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CNT) - BKP_OFFSET)/4)
;;;108    
;;;109      uint32_t * _bkp = (uint32_t *) MDR_BKP_BASE;
;;;110      uint32_t i;
;;;111    
;;;112      for ( i = 0; i < BKP_REG_0E_NUM; i++)
000002  2000              MOVS     r0,#0
000004  4619              MOV      r1,r3                 ;109
000006  4602              MOV      r2,r0
                  |L1.8|
;;;113      {
;;;114        _bkp[i] = 0;
000008  f8412020          STR      r2,[r1,r0,LSL #2]
00000c  1c40              ADDS     r0,r0,#1
00000e  280e              CMP      r0,#0xe               ;112
000010  d3fa              BCC      |L1.8|
;;;115      }
;;;116    
;;;117      for ( i = BKP_RTC_CNT_NUM; i <= BKP_RTC_CS_NUM; i++)
000012  2010              MOVS     r0,#0x10
                  |L1.20|
;;;118      {
;;;119        _bkp[i] = 0;
000014  f8412020          STR      r2,[r1,r0,LSL #2]
000018  1c40              ADDS     r0,r0,#1
00001a  2814              CMP      r0,#0x14              ;117
00001c  d9fa              BLS      |L1.20|
;;;120      }
;;;121    
;;;122      MDR_BKP -> REG_0E |= (uint32_t) (BKP_REG_0E_ON);
00001e  6b98              LDR      r0,[r3,#0x38]
000020  f4406000          ORR      r0,r0,#0x800
000024  6398              STR      r0,[r3,#0x38]
;;;123      MDR_BKP -> REG_0E &= (uint32_t) (BKP_REG_0E_OFF);
000026  6b98              LDR      r0,[r3,#0x38]
000028  4927              LDR      r1,|L1.200|
00002a  4008              ANDS     r0,r0,r1
00002c  6398              STR      r0,[r3,#0x38]
;;;124      MDR_BKP -> REG_0F = (uint32_t) (BKP_REG_0F_LSI_ON);
00002e  f44f4000          MOV      r0,#0x8000
000032  63d8              STR      r0,[r3,#0x3c]
;;;125    }
000034  4770              BX       lr
;;;126    
                          ENDP

                  BKP_JTAGA_CMD PROC
;;;134      */
;;;135    void BKP_JTAGA_CMD(FunctionalState NewState)
000036  4925              LDR      r1,|L1.204|
;;;136    {
;;;137      /* Check the parameters */
;;;138      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;139    
;;;140      *(__IO uint32_t *) BKP_JTAGA_BB = (uint32_t)NewState;
000038  6008              STR      r0,[r1,#0]
;;;141    }
00003a  4770              BX       lr
;;;142    
                          ENDP

                  BKP_JTAGB_CMD PROC
;;;150      */
;;;151    void BKP_JTAGB_CMD(FunctionalState NewState)
00003c  4923              LDR      r1,|L1.204|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;155    
;;;156      *(__IO uint32_t *) BKP_JTAGB_BB = (uint32_t)NewState;
00003e  1d09              ADDS     r1,r1,#4
000040  6008              STR      r0,[r1,#0]
;;;157    }
000042  4770              BX       lr
;;;158    #endif
                          ENDP

                  BKP_RTCclkSource PROC
;;;168      */
;;;169    void BKP_RTCclkSource(uint32_t RTC_CLK)
000044  4a1f              LDR      r2,|L1.196|
;;;170    {
;;;171    	uint32_t tmpreg;
;;;172    
;;;173    	/* Check the parameters */
;;;174    	assert_param(IS_RTC_CLK_SOURCE(RTC_CLK));
;;;175    	/* Clear BKP_REG0F[3:2] bits */
;;;176    	tmpreg = MDR_BKP ->REG_0F & (uint32_t) (~BKP_REG_0F_RTC_SEL_Msk );
000046  6bd1              LDR      r1,[r2,#0x3c]
;;;177    	/* Set BKP_REG0F[3:2] bits according to RTC clock source*/
;;;178    	tmpreg |= BKP_REG_0F_RTC_SEL_Msk & RTC_CLK;
000048  f000000c          AND      r0,r0,#0xc
00004c  f021010c          BIC      r1,r1,#0xc            ;176
000050  4308              ORRS     r0,r0,r1
;;;179    	MDR_BKP ->REG_0F = tmpreg;
000052  63d0              STR      r0,[r2,#0x3c]
;;;180    
;;;181    }
000054  4770              BX       lr
;;;182    
                          ENDP

                  BKP_RTC_Enable PROC
;;;190      */
;;;191    void BKP_RTC_Enable ( FunctionalState NewState )
000056  491d              LDR      r1,|L1.204|
;;;192    {
;;;193    	/* Check the parameters */
;;;194    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;195    #if defined (USE_MDR1986VE9x)
;;;196    	*(__IO uint32_t *) RTC_ENABLE_BB = (uint32_t) NewState;
000058  3178              ADDS     r1,r1,#0x78
00005a  6008              STR      r0,[r1,#0]
;;;197    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;198    	if(NewState != DISABLE){
;;;199    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_EN;
;;;200    	}
;;;201    	else{
;;;202    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_EN;
;;;203    	}
;;;204    #endif
;;;205    }
00005c  4770              BX       lr
;;;206    
                          ENDP

                  BKP_RTC_Calibration PROC
;;;212      */
;;;213    void BKP_RTC_Calibration(uint32_t RTC_Calibration)
00005e  4a19              LDR      r2,|L1.196|
;;;214    {
;;;215      uint32_t tmpreg;
;;;216    
;;;217      /* Check the parameters */
;;;218      assert_param(IS_RTC_CALIBRATION(RTC_Calibration));
;;;219      /* Clear BKP_REG0F[12:5] bits */
;;;220      tmpreg  = MDR_BKP -> REG_0F & (uint32_t) (~BKP_REG_0F_CAL_Msk);
000060  6bd1              LDR      r1,[r2,#0x3c]
;;;221      /* Set BKP_REG0F[12:5] bits according to RTC clock source*/
;;;222      tmpreg |= BKP_REG_0F_CAL_Msk & (RTC_Calibration << BKP_REG_0F_CAL_Pos);
000062  b2c0              UXTB     r0,r0
000064  f42151ff          BIC      r1,r1,#0x1fe0         ;220
000068  ea411040          ORR      r0,r1,r0,LSL #5
;;;223      MDR_BKP -> REG_0F = tmpreg;
00006c  63d0              STR      r0,[r2,#0x3c]
;;;224    }
00006e  4770              BX       lr
;;;225    
                          ENDP

                  BKP_RTC_Reset PROC
;;;233      */
;;;234    void BKP_RTC_Reset ( FunctionalState NewState )
000070  4916              LDR      r1,|L1.204|
;;;235    {
;;;236    	/* Check the parameters */
;;;237    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;238    
;;;239    #if defined (USE_MDR1986VE9x)
;;;240    	*(__IO uint32_t *) RTC_RESET_BB = (uint32_t) NewState;
000072  31e4              ADDS     r1,r1,#0xe4
000074  6008              STR      r0,[r1,#0]
;;;241    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;242    	if(NewState != DISABLE){
;;;243    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_RESET;
;;;244    	}
;;;245    	else{
;;;246    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_RESET;
;;;247    	}
;;;248    #endif // #elif defined (USE_MDR1986VE3)
;;;249    }
000076  4770              BX       lr
;;;250    
                          ENDP

                  BKP_RTC_ITConfig PROC
;;;261      */
;;;262    void BKP_RTC_ITConfig(uint32_t BKP_RTC_IT, FunctionalState NewState)
000078  4a12              LDR      r2,|L1.196|
;;;263    {
;;;264      /* Check the parameters */
;;;265      assert_param(IS_RTC_CLK_IT(BKP_RTC_IT));
;;;266      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;267    
;;;268      if (NewState != DISABLE)
00007a  2900              CMP      r1,#0
;;;269      {
;;;270        MDR_BKP->RTC_CS |= BKP_RTC_IT;
;;;271      }
;;;272      else
;;;273      {
;;;274        MDR_BKP->RTC_CS &= (uint32_t)~BKP_RTC_IT;
00007c  6d11              LDR      r1,[r2,#0x50]
00007e  d001              BEQ      |L1.132|
000080  4301              ORRS     r1,r1,r0              ;270
000082  e000              B        |L1.134|
                  |L1.132|
000084  4381              BICS     r1,r1,r0
                  |L1.134|
000086  6511              STR      r1,[r2,#0x50]         ;270
;;;275      }
;;;276    }
000088  4770              BX       lr
;;;277    
                          ENDP

                  BKP_RTC_GetCounter PROC
;;;282      */
;;;283    uint32_t BKP_RTC_GetCounter(void)
00008a  480e              LDR      r0,|L1.196|
;;;284    {
;;;285      return MDR_BKP -> RTC_CNT;
00008c  6c00              LDR      r0,[r0,#0x40]
;;;286    }
00008e  4770              BX       lr
;;;287    
                          ENDP

                  BKP_RTC_SetCounter PROC
;;;292      */
;;;293    void BKP_RTC_SetCounter(uint32_t CounterValue)
000090  490c              LDR      r1,|L1.196|
;;;294    {
;;;295      MDR_BKP -> RTC_CNT = CounterValue;
000092  6408              STR      r0,[r1,#0x40]
;;;296    }
000094  4770              BX       lr
;;;297    
                          ENDP

                  BKP_RTC_SetAlarm PROC
;;;302      */
;;;303    void  BKP_RTC_SetAlarm(uint32_t AlarmValue)
000096  490b              LDR      r1,|L1.196|
;;;304    {
;;;305      MDR_BKP -> RTC_ALRM = AlarmValue;
000098  64c8              STR      r0,[r1,#0x4c]
;;;306    }
00009a  4770              BX       lr
;;;307    
                          ENDP

                  BKP_RTC_GetDivider PROC
;;;312      */
;;;313    uint32_t BKP_RTC_GetDivider(void)
00009c  4809              LDR      r0,|L1.196|
;;;314    {
;;;315      return MDR_BKP -> RTC_DIV;
00009e  6c40              LDR      r0,[r0,#0x44]
;;;316    }
0000a0  4770              BX       lr
;;;317    
                          ENDP

                  BKP_RTC_SetPrescaler PROC
;;;323      */
;;;324    void BKP_RTC_SetPrescaler(uint32_t PrescalerValue)
0000a2  4908              LDR      r1,|L1.196|
;;;325    {
;;;326      /* Check the parameter */
;;;327      assert_param(IS_BKP_PRESCALER_VALUE(PrescalerValue));
;;;328    
;;;329      MDR_BKP -> RTC_PRL = PrescalerValue;
0000a4  6488              STR      r0,[r1,#0x48]
;;;330    }
0000a6  4770              BX       lr
;;;331    
                          ENDP

                  BKP_RTC_WaitForUpdate PROC
;;;337      */
;;;338    void BKP_RTC_WaitForUpdate ( void )
0000a8  4809              LDR      r0,|L1.208|
                  |L1.170|
;;;339    {
;;;340    	/* Loop until WEC flag is set */
;;;341    #if defined (USE_MDR1986VE9x)
;;;342    	while (*(__IO uint32_t *) RTC_WEC_BB != 0);
0000aa  6801              LDR      r1,[r0,#0]
0000ac  2900              CMP      r1,#0
0000ae  d1fc              BNE      |L1.170|
;;;343    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;344    	while((MDR_BKP->RTC_CS & BKP_RTC_CS_WEC) == BKP_RTC_CS_WEC);
;;;345    #endif
;;;346    
;;;347    }
0000b0  4770              BX       lr
;;;348    
                          ENDP

                  BKP_RTC_GetFlagStatus PROC
;;;358      */
;;;359    FlagStatus BKP_RTC_GetFlagStatus(uint32_t BKP_RTC_FLAG)
0000b2  4904              LDR      r1,|L1.196|
;;;360    {
;;;361      FlagStatus status;
;;;362    
;;;363      /* Check the parameters */
;;;364      assert_param(IS_BKP_RTC_GET_FLAG(BKP_RTC_FLAG));
;;;365    
;;;366      if ((MDR_BKP -> RTC_CS & BKP_RTC_FLAG) != 0)
0000b4  6d09              LDR      r1,[r1,#0x50]
0000b6  4201              TST      r1,r0
0000b8  d001              BEQ      |L1.190|
;;;367      {
;;;368        status = SET;
0000ba  2001              MOVS     r0,#1
;;;369      }
;;;370      else
;;;371      {
;;;372        status = RESET;
;;;373      }
;;;374      return status;
;;;375    }
0000bc  4770              BX       lr
                  |L1.190|
0000be  2000              MOVS     r0,#0                 ;372
0000c0  4770              BX       lr
;;;376    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L1.196|
                          DCD      0x400d8000
                  |L1.200|
                          DCD      0x7ffff8c0
                  |L1.204|
                          DCD      0x43b00718
                  |L1.208|
                          DCD      0x43b00a18

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_bkp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH|
#line 144
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
