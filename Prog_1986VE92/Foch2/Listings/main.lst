L 1 "main.c"
N#include "MDR32F9Qx_port.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_port.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_port.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    16/06/2010
N  * @brief   This file contains all the functions prototypes for the PORTs
N  *          firmware library.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_port.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_PORT_H
N#define __MDR32F9Qx_PORT_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config\MDR32F9Qx_config.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_Demo\Project\Demo\MDR32F9Qx_config.h
N  * @author  Milandr Application Team
N  * @version V1.2.0
N  * @date    10/07/2010
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * <br><br>
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, MILANDR SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2014 Milandr</center></h2>
N  */
N
N/**
N * @mainpage MDR32F9Qx Standard Peripherals Library.
N * MDR32F9Qx Standard Peripherals Library is a package consisting of
N * all standard peripheral device drivers for 1986BE9x, K1986BE9x, MDR32F9Qx,
N * 1986VE1T, 1986VE3T, 1986VE7T microcontrollers.
N * This library is a firmware package which contains a collection of routines,
N * data structures and macros covering the features of Milandr MDR32F9Qx
N * peripherals. It includes a description of the device drivers plus a set of
N * examples for each peripheral. The firmware library allows any device to be
N * used in the user application without the need for in-depth study of each
N * peripherals specifications. Using the Standard Peripherals Library has two
N * advantages: it saves significant time that would otherwise be spent in
N * coding, while simultaneously reducing application development and
N * integration costs.
N *
N * The MDR32F9Qx Standard Peripherals Library is compatible with Milandr
N * 1986BE9x evaluation boards, Milandr evaluation board for MC 1986VE1T
N * (EVAL 22.0 B) and evaluation board for MC 1986VE3T.
N *
N * The MDR32F9Qx Standard Peripherals Library is full CMSIS compliant.
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_CONFIG_H
N#define __MDR32F9Qx_CONFIG_H
N
N#if ((__CC_ARM == 0) || (__ARMCC_VERSION < 5000000))
X#if ((1 == 0) || (5050106 < 5000000))
S	#include "MDR32F9Qx_board.h"
N#endif
N#include "MDR32F9Qx_lib.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_lib.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_lib.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    23/03/2011
N  * @brief   This file contains all file IDs of the Milandr MDR32F9Qx
N  *          firmware library source files.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_lib.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_LIB_H
N#define __MDR32F9QX_LIB_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define FILEID__MDR32F9X_CAN_C					1
N#define FILEID__MDR32F9X_USB_C					2
N#define FILEID__MDR32F9X_EEPROM_C				3
N#define FILEID__MDR32F9X_RST_CLK_C				4
N#define FILEID__MDR32F9X_DMA_C					5
N#define FILEID__MDR32F9X_UART_C					6
N#define FILEID__MDR32F9X_SSP_C					7
N#define FILEID__MDR32F9X_I2C_C					8
N#define FILEID__MDR32F9X_POWER_C				9
N#define FILEID__MDR32F9X_WWDG_C					10
N#define FILEID__MDR32F9X_IWDG_C					11
N#define FILEID__MDR32F9X_TIMER_C				12
N#define FILEID__MDR32F9X_ADC_C					13
N#define FILEID__MDR32F9X_DAC_C					14
N#define FILEID__MDR32F9X_COMP_C					15
N#define FILEID__MDR32F9X_PORT_C					16
N#define FILEID__MDR32F9X_BKP_C					17
N#define FILEID__MDR32F9X_EBC_C					18
N#define FILEID__MDR32F9X_USB_DEVICE_C			19
N#define FILEID__MDR32F9X_USB_CDC_C				20
N#define FILEID__MDR32F9X_MIL_STD1553_C			21
N#define FILEID__MDR32F9X_ARINC429R_C			22
N#define FILEID__MDR32F9X_ARINC429T_C			23
N#define FILEID__MDR32F9X_ETH_C					24
N#define FILEID__MDR32F9Qx_AUDIO_C				25
N#define FILEID__MDR32F9Qx_KEYPAD_C				26
N#define FILEID__MDR32F9Qx_LED_C					27
N
N#define  FILEID__USER_LO                    	100
N
N/* Supported USB Device Classes */
N#define USB_DEVICE_CLASS_CDC 2
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9QX_LIB_H */
N
N/******************* (C) COPYRIGHT 2013 Milandr ********************************
N*
N* END OF FILE MDR32F9Qx_lib.h */
L 50 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config\MDR32F9Qx_config.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050106
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 51 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config\MDR32F9Qx_config.h" 2
N
N#if defined (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1) ||\
N    defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1) ||\
N    defined (USE_MDR32F9Q3_Rev0) || defined (USE_MDR32F9Q3_Rev1) ||\
N    defined (USE_MDR1986VE94)
X#if 0L || 0L ||    0L || 1L ||    0L || 0L ||    0L
N	#define USE_MDR1986VE9x
N#endif
N
N#if defined (USE_MDR1986BE7T)
X#if 0L
S	#define USE_MDR1986VE1T
N#endif
N
N/* Selet the header file for target microcontroller */
N#if defined ( USE_MDR1986VE9x )
X#if 1L
N	#include "MDR32Fx.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32Fx.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    22/06/2011
N  * @brief   This file contains all the Special Function Registers definitions
N  *          for the Milandr MDR32Fx microcontroller.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32Fx.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32FX_H
N#define __MDR32FX_H
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32Fx_Peripheral MDR32F9Qx Peripheral
N  * @{
N  */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#endif
N
N/* MDR32Fx Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/*---- Cortex-M3 Processor Exceptions Numbers --------------------------------*/
N  NonMaskableInt_IRQn     = -14,  /*!<  2 Non Maskable Interrupt              *///!< NonMaskableInt_IRQn
N  HardFault_IRQn          = -13,  /*!<  3 Hard Fault Interrupt                *///!< HardFault_IRQn
N  MemoryManagement_IRQn   = -12,  /*!<  4 Memory Management Interrupt         *///!< MemoryManagement_IRQn
N  BusFault_IRQn           = -11,  /*!<  5 Bus Fault Interrupt                 *///!< BusFault_IRQn
N  UsageFault_IRQn         = -10,  /*!<  6 Usage Fault Interrupt               *///!< UsageFault_IRQn
N  SVCall_IRQn             = -5,   /*!< 11 SV Call Interrupt                   *///!< SVCall_IRQn
N  PendSV_IRQn             = -2,   /*!< 14 Pend SV Interrupt                   *///!< PendSV_IRQn
N  SysTick_IRQn            = -1,   /*!< 15 System Tick Timer Interrupt         *///!< SysTick_IRQn
N
N/*---- MDR32Fx specific Interrupt Numbers ------------------------------------*/
N  CAN1_IRQn               =  0,   /*!< CAN1 Interrupt                         *///!< CAN1_IRQn
N  CAN2_IRQn               =  1,   /*!< CAN1 Interrupt                         *///!< CAN2_IRQn
N  USB_IRQn                =  2,   /*!< USB Host Interrupt                     *///!< USB_IRQn
N  DMA_IRQn                =  5,   /*!< DMA Interrupt                          *///!< DMA_IRQn
N  UART1_IRQn              =  6,   /*!< UART1 Interrupt                        *///!< UART1_IRQn
N  UART2_IRQn              =  7,   /*!< UART2 Interrupt                        *///!< UART2_IRQn
N  SSP1_IRQn               =  8,   /*!< SSP1 Interrupt                         *///!< SSP1_IRQn
N  I2C_IRQn                =  10,  /*!< I2C Interrupt                          *///!< I2C_IRQn
N  POWER_IRQn              =  11,  /*!< POWER Detecor Interrupt                *///!< POWER_IRQn
N  WWDG_IRQn               =  12,  /*!< Window Watchdog Interrupt              *///!< WWDG_IRQn
N  Timer1_IRQn             =  14,  /*!< Timer1 Interrupt                       *///!< Timer1_IRQn
N  Timer2_IRQn             =  15,  /*!< Timer2 Interrupt                       *///!< Timer2_IRQn
N  Timer3_IRQn             =  16,  /*!< Timer3 Interrupt                       *///!< Timer3_IRQn
N  ADC_IRQn                =  17,  /*!< ADC Interrupt                          *///!< ADC_IRQn
N  COMPARATOR_IRQn         =  19,  /*!< COMPARATOR Interrupt                   *///!< COMPARATOR_IRQn
N  SSP2_IRQn               =  20,  /*!< SSP2 Interrupt                         *///!< SSP2_IRQn
N  BACKUP_IRQn             =  27,  /*!< BACKUP Interrupt                       *///!< BACKUP_IRQn
N  EXT_INT1_IRQn           =  28,  /*!< EXT_INT1 Interrupt                     *///!< EXT_INT1_IRQn
N  EXT_INT2_IRQn           =  29,  /*!< EXT_INT2 Interrupt                     *///!< EXT_INT2_IRQn
N  EXT_INT3_IRQn           =  30,  /*!< EXT_INT3 Interrupt                     *///!< EXT_INT3_IRQn
N  EXT_INT4_IRQn           =  31   /*!< EXT_INT4 Interrupt                     *///!< EXT_INT4_IRQn
N}IRQn_Type;
N
N/** @addtogroup __Configuration_of_CMSIS Configuration of CMSIS
N  * @{
N  */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __CM3_REV              0x0102   /*!< Cortex-M3 Core Revision                      */
N#define __MPU_PRESENT             1     /*!< MPU present or not                           */
N#define __NVIC_PRIO_BITS          3     /*!< Number of Bits used for Priority Levels      */
N#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
N
N/** @} */ /* End of group __Configuration_of_CMSIS */
N
N/* Includes ------------------------------------------------------------------*/
N#include "core_cm3.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM3_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) |                                     __CM3_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CMCARM__ )
S  #define __ASM            #pragma asm                                /*!< #pragma asm for Phyton CMC-ARM Compiler      */
S  #define __INLINE         __inline                                   /*!< inline keyword for Phyton CMC-ARM Compiler */
S  #define __STATIC_INLINE  static __inline
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.22
N * @date     10. June 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050106 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function performs a exclusive LDR command for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function performs a exclusive LDR command for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function performs a exclusive LDR command for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function performs a exclusive STR command for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function performs a exclusive STR command for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function performs a exclusive STR command for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 141 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport\core_cm3.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050106 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x03) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 142 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport\core_cm3.h" 2
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201)                   /* core r2p1 */
X#if (0x0102 < 0x0201)                    
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((1L) && (0x0102 >= 0x200))
S  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1[1];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
N  reg_value  =  (reg_value                                 |
N                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 3)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 3)) & 0xff);    }         
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 3)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 3)));  }  
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 3) ? 3 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 3) < 7) ? 0 : PriorityGroupTmp - 7 + 3;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 3) ? 3 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 3) < 7) ? 0 : PriorityGroupTmp - 7 + 3;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1UL << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<3) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
N      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N#endif
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
N
L 99 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N#include "system_MDR32F9Qx.h"
L 1 "C:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE\Device\MDR1986BE92\system_MDR32F9Qx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_MDR32F9Qx.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    11/06/2010
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE system_MDR32F9Qx.h
N  */
N
N/** @addtogroup __CMSIS CMSIS
N  * @{
N  */
N
N/** @defgroup MDR1986VE9x
N *  @{
N */
N
N/** @defgroup __MDR32F9QX MDR32F9QX System
N  * @{
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __SYSTEM_MDR32F9Qx_H
N#define __SYSTEM_MDR32F9Qx_H
N
N/** @addtogroup __MDR32F9QX_System_Exported_Variables MDR32F9QX System Exported Variables
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock)
N                                           *   default value */
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Variables */
N
N/** @addtogroup __MDR32F9QX_System_Exported_Functions MDR32F9QX System Exported Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N
N/** @} */ /* End of group __MDR32F9QX_System_Exported_Functions */
N
N#endif /*__SYSTEM_MDR32F9Qx_H */
N
N/** @} */ /* End of group __MDR32F9QX */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE system_MDR32F9Qx.h */
L 100 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\MDR32Fx.h" 2
N
N/** @defgroup __Exported_types Exported types
N  * @{
N  */
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus, BitStatus;
N
N#define IS_BIT_STATUS(STATUS)	(((STATUS) == RESET) || ((STATE) == SET))
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/** @} */ /* End of group __Exported_types */
N
N/** @addtogroup __MDR32Fx_Peripheral_Units MDR32F9Qx Peripheral Units
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN CAN
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_CAN_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_CAN_BUF_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ID;
X  volatile uint32_t ID;
N  __IO uint32_t DLC;
X  volatile uint32_t DLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N}MDR_CAN_BUF_TypeDef;
N
N/* MDR_CAN_BUF_FILTER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t MASK;
X  volatile uint32_t MASK;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N}MDR_CAN_BUF_FILTER_TypeDef;
N
N/* MDR_CAN_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t BITTMNG;
X  volatile uint32_t BITTMNG;
N       uint32_t RESERVED0;
N  __IO uint32_t INT_EN;
X  volatile uint32_t INT_EN;
N       uint32_t RESERVED1[2];
N  __IO uint32_t OVER;
X  volatile uint32_t OVER;
N  __IO uint32_t RXID;
X  volatile uint32_t RXID;
N  __IO uint32_t RXDLC;
X  volatile uint32_t RXDLC;
N  __IO uint32_t RXDATAL;
X  volatile uint32_t RXDATAL;
N  __IO uint32_t RXDATAH;
X  volatile uint32_t RXDATAH;
N  __IO uint32_t TXID;
X  volatile uint32_t TXID;
N  __IO uint32_t TXDLC;
X  volatile uint32_t TXDLC;
N  __IO uint32_t DATAL;
X  volatile uint32_t DATAL;
N  __IO uint32_t DATAH;
X  volatile uint32_t DATAH;
N  __IO uint32_t BUF_CON[32];
X  volatile uint32_t BUF_CON[32];
N  __IO uint32_t INT_RX;
X  volatile uint32_t INT_RX;
N  __IO uint32_t RX;
X  volatile uint32_t RX;
N  __IO uint32_t INT_TX;
X  volatile uint32_t INT_TX;
N  __IO uint32_t TX;
X  volatile uint32_t TX;
N       uint32_t RESERVED2[76];
N    MDR_CAN_BUF_TypeDef CAN_BUF[32];
N       uint32_t RESERVED3[64];
N    MDR_CAN_BUF_FILTER_TypeDef CAN_BUF_FILTER[32];
N}MDR_CAN_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_CAN_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_CAN_CONTROL	CAN CONTROL
N  * @{
N  */ 
N
N/*-- CAN_CONTROL: CAN Control Register -----------------------------*/
N/* Bit field positions: */
N#define CAN_CONTROL_CAN_EN_Pos                  0
N#define CAN_CONTROL_ROM_Pos                     1
N#define CAN_CONTROL_STM_Pos                     2
N#define CAN_CONTROL_SAP_Pos                     3
N#define CAN_CONTROL_ROP_Pos                     4
N
N/* Bit field masks: */
N#define CAN_CONTROL_CAN_EN                      ((uint32_t)0x00000001)
N#define CAN_CONTROL_ROM                         ((uint32_t)0x00000002)
N#define CAN_CONTROL_STM                         ((uint32_t)0x00000004)
N#define CAN_CONTROL_SAP                         ((uint32_t)0x00000008)
N#define CAN_CONTROL_ROP                         ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_CONTROL */
N
N/** @defgroup Periph_CAN_STATUS	CAN STATUS
N  * @{
N  */ 
N
N/*-- CAN_STATUS: CAN Status Register -------------------------------*/
N/* Bit field positions: */
N#define CAN_STATUS_RX_READY_Pos                 0
N#define CAN_STATUS_TX_READY_Pos                 1
N#define CAN_STATUS_ERROR_OVER_Pos               2
N#define CAN_STATUS_BIT_ERR_Pos                  3
N#define CAN_STATUS_BIT_STUFF_ERR_Pos            4
N#define CAN_STATUS_CRC_ERR_Pos                  5
N#define CAN_STATUS_FRAME_ERR_Pos                6
N#define CAN_STATUS_ACK_ERR_Pos                  7
N#define CAN_STATUS_IDLOWER_Pos                  8
N#define CAN_STATUS_ERR_STATUS_Pos               9
N#define CAN_STATUS_RX_ERR_CNT8_Pos              11
N#define CAN_STATUS_TX_ERR_CNT8_Pos              12
N#define CAN_STATUS_RX_ERR_CNT_Pos               16
N#define CAN_STATUS_TX_ERR_CNT_Pos               24
N
N/* Bit field masks: */
N#define CAN_STATUS_RX_READY                     ((uint32_t)0x00000001)
N#define CAN_STATUS_TX_READY                     ((uint32_t)0x00000002)
N#define CAN_STATUS_ERROR_OVER                   ((uint32_t)0x00000004)
N#define CAN_STATUS_BIT_ERR                      ((uint32_t)0x00000008)
N#define CAN_STATUS_BIT_STUFF_ERR                ((uint32_t)0x00000010)
N#define CAN_STATUS_CRC_ERR                      ((uint32_t)0x00000020)
N#define CAN_STATUS_FRAME_ERR                    ((uint32_t)0x00000040)
N#define CAN_STATUS_ACK_ERR                      ((uint32_t)0x00000080)
N#define CAN_STATUS_IDLOWER                      ((uint32_t)0x00000100)
N#define CAN_STATUS_ERR_STATUS_Msk               ((uint32_t)0x00000600)
N#define CAN_STATUS_RX_ERR_CNT8                  ((uint32_t)0x00000800)
N#define CAN_STATUS_TX_ERR_CNT8                  ((uint32_t)0x00001000)
N#define CAN_STATUS_RX_ERR_CNT_Msk               ((uint32_t)0x00FF0000)
N#define CAN_STATUS_TX_ERR_CNT_Msk               ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_STATUS */
N
N/** @defgroup Periph_CAN_BITTMNG	CAN BITTMNG
N  * @{
N  */ 
N
N/*-- CAN_BITTMNG: CAN Bittiming Register ---------------------------*/
N/* Bit field positions: */
N#define CAN_BITTMNG_BRP_Pos                     0
N#define CAN_BITTMNG_PSEG_Pos                    16
N#define CAN_BITTMNG_SEG1_Pos                    19
N#define CAN_BITTMNG_SEG2_Pos                    22
N#define CAN_BITTMNG_SJW_Pos                     25
N#define CAN_BITTMNG_SB_Pos                      27
N
N/* Bit field masks: */
N#define CAN_BITTMNG_BRP_Msk                     ((uint32_t)0x0000FFFF)
N#define CAN_BITTMNG_PSEG_Msk                    ((uint32_t)0x00070000)
N#define CAN_BITTMNG_SEG1_Msk                    ((uint32_t)0x00380000)
N#define CAN_BITTMNG_SEG2_Msk                    ((uint32_t)0x01C00000)
N#define CAN_BITTMNG_SJW_Msk                     ((uint32_t)0x06000000)
N#define CAN_BITTMNG_SB                          ((uint32_t)0x08000000)
N
N/** @} */ /* End of group CAN_BITTMNG */
N
N/** @defgroup Periph_CAN_INT_EN	CAN INT EN
N  * @{
N  */ 
N
N/*-- CAN_INT_EN: CAN Interrupt enable Register ---------------------*/
N/* Bit field positions: */
N#define CAN_INT_EN_GLB_INT_EN_Pos               0
N#define CAN_INT_EN_RX_INT_EN_Pos                1
N#define CAN_INT_EN_TX_INT_EN_Pos                2
N#define CAN_INT_EN_ERR_INT_EN_Pos               3
N#define CAN_INT_EN_ERR_OVER_INT_EN_Pos          4
N
N/* Bit field masks: */
N#define CAN_INT_EN_GLB_INT_EN                   ((uint32_t)0x00000001)
N#define CAN_INT_EN_RX_INT_EN                    ((uint32_t)0x00000002)
N#define CAN_INT_EN_TX_INT_EN                    ((uint32_t)0x00000004)
N#define CAN_INT_EN_ERR_INT_EN                   ((uint32_t)0x00000008)
N#define CAN_INT_EN_ERR_OVER_INT_EN              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group CAN_INT_EN */
N
N/** @defgroup Periph_CAN_RXID	CAN RXID
N  * @{
N  */ 
N
N/*-- CAN_RXID:   CAN Receive ID Register ---------------------------*/
N/*-- CAN_TXID:   CAN Transmit ID Register --------------------------*/
N/*-- CAN_BUF_ID: CAN Buffer ID Register ----------------------------*/
N/* Bit field positions: */
N#define CAN_ID_EID_Pos                          0
N#define CAN_ID_SID_Pos                          18
N
N/* Bit field masks: */
N#define CAN_ID_EID_Msk                          ((uint32_t)0x0003FFFF)
N#define CAN_ID_SID_Msk                          ((uint32_t)0x1FFC0000)
N
N/** @} */ /* End of group CAN_RXID */
N
N/** @defgroup Periph_CAN_RXDLC	CAN RXDLC
N  * @{
N  */ 
N
N/*-- CAN_RXDLC:   CAN Receive DLC Register -------------------------*/
N/*-- CAN_TXDLC:   CAN Transmit DLC Register ------------------------*/
N/*-- CAN_BUF_DLC: CAN Buffer DLC Register --------------------------*/
N/* Bit field positions: */
N#define CAN_DLC_Pos                             0
N#define CAN_DLC_RTR_Pos                         8
N#define CAN_DLC_R1_Pos                          9
N#define CAN_DLC_R0_Pos                          10
N#define CAN_DLC_SSR_Pos                         11
N#define CAN_DLC_IDE_Pos                         12
N
N/* Bit field masks: */
N#define CAN_DLC_Msk                             ((uint32_t)0x0000000F)
N#define CAN_DLC_RTR                             ((uint32_t)0x00000100)
N#define CAN_DLC_R1                              ((uint32_t)0x00000200)
N#define CAN_DLC_R0                              ((uint32_t)0x00000400)
N#define CAN_DLC_SSR                             ((uint32_t)0x00000800)
N#define CAN_DLC_IDE                             ((uint32_t)0x00001000)
N
N/** @} */ /* End of group CAN_RXDLC */
N
N/** @defgroup Periph_CAN_RXDATAL	CAN RXDATAL
N  * @{
N  */ 
N
N/*-- CAN_RXDATAL:   CAN Receive Data low Register ------------------*/
N/*-- CAN_DATAL:     CAN Transmit Data low Register -----------------*/
N/*-- CAN_BUF_DATAL: CAN Buffer Data low Register -------------------*/
N/* Bit field positions: */
N#define CAN_DATAL_DB0_Pos                       0
N#define CAN_DATAL_DB1_Pos                       8
N#define CAN_DATAL_DB2_Pos                       16
N#define CAN_DATAL_DB3_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAL_DB0_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAL_DB1_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAL_DB2_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAL_DB3_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAL */
N
N/** @defgroup Periph_CAN_RXDATAH	CAN RXDATAH
N  * @{
N  */ 
N
N/*-- CAN_RXDATAH:   CAN Receive Data high Register -----------------*/
N/*-- CAN_DATAH:     CAN Transmit Data high Register ----------------*/
N/*-- CAN_BUF_DATAH: CAN Buffer Data high Register ------------------*/
N/* Bit field positions: */
N#define CAN_DATAH_DB4_Pos                       0
N#define CAN_DATAH_DB5_Pos                       8
N#define CAN_DATAH_DB6_Pos                       16
N#define CAN_DATAH_DB7_Pos                       24
N
N/* Bit field masks: */
N#define CAN_DATAH_DB4_Msk                       ((uint32_t)0x000000FF)
N#define CAN_DATAH_DB5_Msk                       ((uint32_t)0x0000FF00)
N#define CAN_DATAH_DB6_Msk                       ((uint32_t)0x00FF0000)
N#define CAN_DATAH_DB7_Msk                       ((uint32_t)0xFF000000)
N
N/** @} */ /* End of group CAN_RXDATAH */
N
N/** @defgroup Periph_CAN_BUF_CON	CAN BUF CON
N  * @{
N  */ 
N
N/*-- CAN_BUF_CON: CAN Buffer Connection Register -------------------*/
N/* Bit field positions: */
N#define CAN_BUF_CON_EN_Pos                      0
N#define CAN_BUF_CON_RX_TXN_Pos                  1
N#define CAN_BUF_CON_OVER_EN_Pos                 2
N#define CAN_BUF_CON_RTR_EN_Pos                  3
N#define CAN_BUF_CON_PRIOR_0_Pos                 4
N#define CAN_BUF_CON_TX_REQ_Pos                  5
N#define CAN_BUF_CON_RX_FULL_Pos                 6
N#define CAN_BUF_CON_OVER_WR_Pos                 7
N
N/* Bit field masks: */
N#define CAN_BUF_CON_EN                          ((uint32_t)0x00000001)
N#define CAN_BUF_CON_RX_TXN                      ((uint32_t)0x00000002)
N#define CAN_BUF_CON_OVER_EN                     ((uint32_t)0x00000004)
N#define CAN_BUF_CON_RTR_EN                      ((uint32_t)0x00000008)
N#define CAN_BUF_CON_PRIOR_0                     ((uint32_t)0x00000010)
N#define CAN_BUF_CON_TX_REQ                      ((uint32_t)0x00000020)
N#define CAN_BUF_CON_RX_FULL                     ((uint32_t)0x00000040)
N#define CAN_BUF_CON_OVER_WR                     ((uint32_t)0x00000080)
N
N/** @} */ /* End of group CAN_BUF_CON */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_CAN */
N
N/** @defgroup MDR32Fx_Periph_USB USB
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_USB_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_USB_SEP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CTRL;
X  volatile uint32_t CTRL;
N  __IO uint32_t STS;
X  volatile uint32_t STS;
N  __IO uint32_t TS;
X  volatile uint32_t TS;
N  __IO uint32_t NTS;
X  volatile uint32_t NTS;
N}MDR_USB_SEP_TypeDef;
N
N/* MDR_USB_SEP_FIFO_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXFD;
X  volatile uint32_t RXFD;
N       uint32_t RESERVED0;
N  __IO uint32_t RXFDC_L;
X  volatile uint32_t RXFDC_L;
N  __IO uint32_t RXFDC_H;
X  volatile uint32_t RXFDC_H;
N  __IO uint32_t RXFC;
X  volatile uint32_t RXFC;
N       uint32_t RESERVED1[11];
N  __IO uint32_t TXFD;
X  volatile uint32_t TXFD;
N       uint32_t RESERVED2[3];
N  __IO uint32_t TXFDC;
X  volatile uint32_t TXFDC;
N       uint32_t RESERVED3[11];
N}MDR_USB_SEP_FIFO_TypeDef;
N
N/* MDR_USB_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t HTXC;
X  volatile uint32_t HTXC;
N  __IO uint32_t HTXT;
X  volatile uint32_t HTXT;
N  __IO uint32_t HTXLC;
X  volatile uint32_t HTXLC;
N  __IO uint32_t HTXSE;
X  volatile uint32_t HTXSE;
N  __IO uint32_t HTXA;
X  volatile uint32_t HTXA;
N  __IO uint32_t HTXE;
X  volatile uint32_t HTXE;
N  __IO uint32_t HFN_L;
X  volatile uint32_t HFN_L;
N  __IO uint32_t HFN_H;
X  volatile uint32_t HFN_H;
N  __IO uint32_t HIS;
X  volatile uint32_t HIS;
N  __IO uint32_t HIM;
X  volatile uint32_t HIM;
N  __IO uint32_t HRXS;
X  volatile uint32_t HRXS;
N  __IO uint32_t HRXP;
X  volatile uint32_t HRXP;
N  __IO uint32_t HRXA;
X  volatile uint32_t HRXA;
N  __IO uint32_t HRXE;
X  volatile uint32_t HRXE;
N  __IO uint32_t HRXCS;
X  volatile uint32_t HRXCS;
N  __IO uint32_t HSTM;
X  volatile uint32_t HSTM;
N       uint32_t RESERVED0[16];
N  __IO uint32_t HRXFD;
X  volatile uint32_t HRXFD;
N       uint32_t RESERVED1;
N  __IO uint32_t HRXFDC_L;
X  volatile uint32_t HRXFDC_L;
N  __IO uint32_t HRXFDC_H;
X  volatile uint32_t HRXFDC_H;
N  __IO uint32_t HRXFC;
X  volatile uint32_t HRXFC;
N       uint32_t RESERVED2[11];
N  __IO uint32_t HTXFD;
X  volatile uint32_t HTXFD;
N       uint32_t RESERVED3[3];
N  __IO uint32_t HTXFC;
X  volatile uint32_t HTXFC;
N       uint32_t RESERVED4[11];
N    MDR_USB_SEP_TypeDef USB_SEP[4];
N  __IO uint32_t SC;
X  volatile uint32_t SC;
N  __IO uint32_t SLS;
X  volatile uint32_t SLS;
N  __IO uint32_t SIS;
X  volatile uint32_t SIS;
N  __IO uint32_t SIM;
X  volatile uint32_t SIM;
N  __IO uint32_t SA;
X  volatile uint32_t SA;
N  __IO uint32_t SFN_L;
X  volatile uint32_t SFN_L;
N  __IO uint32_t SFN_H;
X  volatile uint32_t SFN_H;
N       uint32_t RESERVED5[9];
N    MDR_USB_SEP_FIFO_TypeDef USB_SEP_FIFO[4];
N  __IO uint32_t HSCR;
X  volatile uint32_t HSCR;
N  __IO uint32_t HSVR;
X  volatile uint32_t HSVR;
N}MDR_USB_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_USB_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_USB_HTXC	USB HTXC
N  * @{
N  */ 
N
N/*-- USB_HTXC: USB HTXC Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HTXC_TREQ_Pos                       0
N#define USB_HTXC_SOFS_Pos                       1
N#define USB_HTXC_PREEN_Pos                      2
N#define USB_HTXC_ISOEN_Pos                      3
N
N/* Bit field masks: */
N#define USB_HTXC_TREQ                           ((uint32_t)0x00000001)
N#define USB_HTXC_SOFS                           ((uint32_t)0x00000002)
N#define USB_HTXC_PREEN                          ((uint32_t)0x00000004)
N#define USB_HTXC_ISOEN                          ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HTXC */
N
N/** @defgroup Periph_USB_HTXLC	USB HTXLC
N  * @{
N  */ 
N
N/*-- USB_HTXLC: USB HTXLC Register ---------------------------------*/
N/* Bit field positions: */
N#define USB_HTXLC_Pos                           0
N#define USB_HTXLC_DC_Pos                        2
N#define USB_HTXLC_FSPL_Pos                      3
N#define USB_HTXLC_FSLR_Pos                      4
N
N/* Bit field masks: */
N#define USB_HTXLC_Msk                           ((uint32_t)0x00000003)
N#define USB_HTXLC_DC                            ((uint32_t)0x00000004)
N#define USB_HTXLC_FSPL                          ((uint32_t)0x00000008)
N#define USB_HTXLC_FSLR                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_HTXLC */
N
N/** @defgroup Periph_USB_HIS	USB HIS
N  * @{
N  */ 
N
N/*-- USB_HIS: USB_HIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIS_TDONE_Pos                       0
N#define USB_HIS_RESUME_Pos                      1
N#define USB_HIS_CONEV_Pos                       2
N#define USB_HIS_SOFS_Pos                        3
N
N/* Bit field masks: */
N#define USB_HIS_TDONE                           ((uint32_t)0x00000001)
N#define USB_HIS_RESUME                          ((uint32_t)0x00000002)
N#define USB_HIS_CONEV                           ((uint32_t)0x00000004)
N#define USB_HIS_SOFS                            ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIS */
N
N/** @defgroup Periph_USB_HIM	USB HIM
N  * @{
N  */ 
N
N/*-- USB_HIM: USB_HIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_HIM_TDONEIE_Pos                     0
N#define USB_HIM_RESUMEIE_Pos                    1
N#define USB_HIM_CONEVIE_Pos                     2
N#define USB_HIM_SOFIE_Pos                       3
N
N/* Bit field masks: */
N#define USB_HIM_TDONEIE                         ((uint32_t)0x00000001)
N#define USB_HIM_RESUMEIE                        ((uint32_t)0x00000002)
N#define USB_HIM_CONEVIE                         ((uint32_t)0x00000004)
N#define USB_HIM_SOFIE                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group USB_HIM */
N
N/** @defgroup Periph_USB_HRXS	USB HRXS
N  * @{
N  */ 
N
N/*-- USB_HRXS: USB_HRXS Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HRXS_CRCERR_Pos                     0
N#define USB_HRXS_BSERR_Pos                      1
N#define USB_HRXS_RXOF_Pos                       2
N#define USB_HRXS_RXTO_Pos                       3
N#define USB_HRXS_NAKRXED_Pos                    4
N#define USB_HRXS_STALLRXED_Pos                  5
N#define USB_HRXS_ACKRXED_Pos                    6
N#define USB_HRXS_DATASEQ_Pos                    7
N
N/* Bit field masks: */
N#define USB_HRXS_CRCERR                         ((uint32_t)0x00000001)
N#define USB_HRXS_BSERR                          ((uint32_t)0x00000002)
N#define USB_HRXS_RXOF                           ((uint32_t)0x00000004)
N#define USB_HRXS_RXTO                           ((uint32_t)0x00000008)
N#define USB_HRXS_NAKRXED                        ((uint32_t)0x00000010)
N#define USB_HRXS_STALLRXED                      ((uint32_t)0x00000020)
N#define USB_HRXS_ACKRXED                        ((uint32_t)0x00000040)
N#define USB_HRXS_DATASEQ                        ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HRXS */
N
N/** @defgroup Periph_USB_SEP_CTRL	USB SEP CTRL
N  * @{
N  */ 
N
N/*-- USB_SEP_CTRL: USB_SEP Control Register ------------------------*/
N/* Bit field positions: */
N#define USB_SEP_CTRL_EPEN_Pos                   0
N#define USB_SEP_CTRL_EPRDY_Pos                  1
N#define USB_SEP_CTRL_EPDATASEQ_Pos              2
N#define USB_SEP_CTRL_EPSSTALL_Pos               3
N#define USB_SEP_CTRL_EPISOEN_Pos                4
N
N/* Bit field masks: */
N#define USB_SEP_CTRL_EPEN                       ((uint32_t)0x00000001)
N#define USB_SEP_CTRL_EPRDY                      ((uint32_t)0x00000002)
N#define USB_SEP_CTRL_EPDATASEQ                  ((uint32_t)0x00000004)
N#define USB_SEP_CTRL_EPSSTALL                   ((uint32_t)0x00000008)
N#define USB_SEP_CTRL_EPISOEN                    ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SEP_CTRL */
N
N/** @defgroup Periph_USB_SEP_STS	USB SEP STS
N  * @{
N  */ 
N
N/*-- USB_SEP_STS: USB_SEP Status Register --------------------------*/
N/* Bit field positions: */
N#define USB_SEP_STS_SCCRCERR_Pos                0
N#define USB_SEP_STS_SCBSERR_Pos                 1
N#define USB_SEP_STS_SCRXOF_Pos                  2
N#define USB_SEP_STS_SCRXTO_Pos                  3
N#define USB_SEP_STS_SCNAKSENT_Pos               4
N#define USB_SEP_STS_SCSTALLSENT_Pos             5
N#define USB_SEP_STS_SCACKRXED_Pos               6
N#define USB_SEP_STS_SCDATASEQ_Pos               7
N
N/* Bit field masks: */
N#define USB_SEP_STS_SCCRCERR                    ((uint32_t)0x00000001)
N#define USB_SEP_STS_SCBSERR                     ((uint32_t)0x00000002)
N#define USB_SEP_STS_SCRXOF                      ((uint32_t)0x00000004)
N#define USB_SEP_STS_SCRXTO                      ((uint32_t)0x00000008)
N#define USB_SEP_STS_SCNAKSENT                   ((uint32_t)0x00000010)
N#define USB_SEP_STS_SCSTALLSENT                 ((uint32_t)0x00000020)
N#define USB_SEP_STS_SCACKRXED                   ((uint32_t)0x00000040)
N#define USB_SEP_STS_SCDATASEQ                   ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_SEP_STS */
N
N/** @defgroup Periph_USB_SC	USB SC
N  * @{
N  */ 
N
N/*-- USB_SC: USB_SC Register ---------------------------------------*/
N/* Bit field positions: */
N#define USB_SCGEN_Pos                           0
N#define USB_SCTXLS_Pos                          1
N#define USB_SCDC_Pos                            3
N#define USB_SCFSP_Pos                           4
N#define USB_SCFSR_Pos                           5
N
N/* Bit field masks: */
N#define USB_SCGEN                               ((uint32_t)0x00000001)
N#define USB_SCTXLS_Msk                          ((uint32_t)0x00000006)
N#define USB_SCDC                                ((uint32_t)0x00000008)
N#define USB_SCFSP                               ((uint32_t)0x00000010)
N#define USB_SCFSR                               ((uint32_t)0x00000020)
N
N/** @} */ /* End of group USB_SC */
N
N/** @defgroup Periph_USB_SIS	USB SIS
N  * @{
N  */ 
N
N/*-- USB_SIS: USB_SIS Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIS_SCTDONE_Pos                     0
N#define USB_SIS_SCRESUME_Pos                    1
N#define USB_SIS_SCRESETEV_Pos                   2
N#define USB_SIS_SCSOFREC_Pos                    3
N#define USB_SIS_SCNAKSENT_Pos                   4
N
N/* Bit field masks: */
N#define USB_SIS_SCTDONE                         ((uint32_t)0x00000001)
N#define USB_SIS_SCRESUME                        ((uint32_t)0x00000002)
N#define USB_SIS_SCRESETEV                       ((uint32_t)0x00000004)
N#define USB_SIS_SCSOFREC                        ((uint32_t)0x00000008)
N#define USB_SIS_SCNAKSENT                       ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIS */
N
N/** @defgroup Periph_USB_SIM	USB SIM
N  * @{
N  */ 
N
N/*-- USB_SIM: USB_SIM Register -------------------------------------*/
N/* Bit field positions: */
N#define USB_SIM_SCTDONEIE_Pos                   0
N#define USB_SIM_SCRESUMEIE_Pos                  1
N#define USB_SIM_SCRESETEVIE_Pos                 2
N#define USB_SIM_SCSOFRECIE_Pos                  3
N#define USB_SIM_SCNAKSENTIE_Pos                 4
N
N/* Bit field masks: */
N#define USB_SIM_SCTDONEIE                       ((uint32_t)0x00000001)
N#define USB_SIM_SCRESUMEIE                      ((uint32_t)0x00000002)
N#define USB_SIM_SCRESETEVIE                     ((uint32_t)0x00000004)
N#define USB_SIM_SCSOFRECIE                      ((uint32_t)0x00000008)
N#define USB_SIM_SCNAKSENTIE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group USB_SIM */
N
N/** @defgroup Periph_USB_HSCR	USB HSCR
N  * @{
N  */ 
N
N/*-- USB_HSCR: USB_HSCR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSCR_HOST_MODE_Pos                  0
N#define USB_HSCR_RESET_CORE_Pos                 1
N#define USB_HSCR_EN_TX_Pos                      2
N#define USB_HSCR_EN_RX_Pos                      3
N#define USB_HSCR_DP_PULLUP_Pos                  4
N#define USB_HSCR_DP_PULLDOWN_Pos                5
N#define USB_HSCR_DM_PULLUP_Pos                  6
N#define USB_HSCR_DM_PULLDOWN_Pos                7
N
N/* Bit field masks: */
N#define USB_HSCR_HOST_MODE                      ((uint32_t)0x00000001)
N#define USB_HSCR_RESET_CORE                     ((uint32_t)0x00000002)
N#define USB_HSCR_EN_TX                          ((uint32_t)0x00000004)
N#define USB_HSCR_EN_RX                          ((uint32_t)0x00000008)
N#define USB_HSCR_DP_PULLUP                      ((uint32_t)0x00000010)
N#define USB_HSCR_DP_PULLDOWN                    ((uint32_t)0x00000020)
N#define USB_HSCR_DM_PULLUP                      ((uint32_t)0x00000040)
N#define USB_HSCR_DM_PULLDOWN                    ((uint32_t)0x00000080)
N
N/** @} */ /* End of group USB_HSCR */
N
N/** @defgroup Periph_USB_HSVR	USB HSVR
N  * @{
N  */ 
N
N/*-- USB_HSVR: USB_HSVR Register -----------------------------------*/
N/* Bit field positions: */
N#define USB_HSVR_VERSION_Pos                    0
N#define USB_HSVR_REVISION_Pos                   4
N
N/* Bit field masks: */
N#define USB_HSVR_VERSION_Msk                    ((uint32_t)0x0000000F)
N#define USB_HSVR_REVISION_Msk                   ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group USB_HSVR */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_USB */
N
N/** @defgroup MDR32Fx_Periph_EEPROM EEPROM
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EEPROM_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N  __IO uint32_t ADR;
X  volatile uint32_t ADR;
N  __IO uint32_t DI;
X  volatile uint32_t DI;
N  __IO uint32_t DO;
X  volatile uint32_t DO;
N  __IO uint32_t KEY;
X  volatile uint32_t KEY;
N}MDR_EEPROM_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EEPROM_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EEPROM_CMD	EEPROM CMD
N  * @{
N  */ 
N
N/*-- EEPROM_CMD: EEPROM Command Register ---------------------------*/
N/* Bit field positions: */
N#define EEPROM_CMD_CON_Pos                      0
N#define EEPROM_CMD_WR_Pos                       1
N#define EEPROM_CMD_RD_Pos                       2
N#define EEPROM_CMD_DELAY_Pos                    3
N#define EEPROM_CMD_XE_Pos                       6
N#define EEPROM_CMD_YE_Pos                       7
N#define EEPROM_CMD_SE_Pos                       8
N#define EEPROM_CMD_IFREN_Pos                    9
N#define EEPROM_CMD_ERASE_Pos                    10
N#define EEPROM_CMD_MAS1_Pos                     11
N#define EEPROM_CMD_PROG_Pos                     12
N#define EEPROM_CMD_NVSTR_Pos                    13
N
N/* Bit field masks: */
N#define EEPROM_CMD_CON                          ((uint32_t)0x00000001)
N#define EEPROM_CMD_WR                           ((uint32_t)0x00000002)
N#define EEPROM_CMD_RD                           ((uint32_t)0x00000004)
N#define EEPROM_CMD_DELAY_Msk                    ((uint32_t)0x00000038)
N#define EEPROM_CMD_XE                           ((uint32_t)0x00000040)
N#define EEPROM_CMD_YE                           ((uint32_t)0x00000080)
N#define EEPROM_CMD_SE                           ((uint32_t)0x00000100)
N#define EEPROM_CMD_IFREN                        ((uint32_t)0x00000200)
N#define EEPROM_CMD_ERASE                        ((uint32_t)0x00000400)
N#define EEPROM_CMD_MAS1                         ((uint32_t)0x00000800)
N#define EEPROM_CMD_PROG                         ((uint32_t)0x00001000)
N#define EEPROM_CMD_NVSTR                        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group EEPROM_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EEPROM */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK RST_CLK
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_RST_CLK_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CLOCK_STATUS;
X  volatile uint32_t CLOCK_STATUS;
N  __IO uint32_t PLL_CONTROL;
X  volatile uint32_t PLL_CONTROL;
N  __IO uint32_t HS_CONTROL;
X  volatile uint32_t HS_CONTROL;
N  __IO uint32_t CPU_CLOCK;
X  volatile uint32_t CPU_CLOCK;
N  __IO uint32_t USB_CLOCK;
X  volatile uint32_t USB_CLOCK;
N  __IO uint32_t ADC_MCO_CLOCK;
X  volatile uint32_t ADC_MCO_CLOCK;
N  __IO uint32_t RTC_CLOCK;
X  volatile uint32_t RTC_CLOCK;
N  __IO uint32_t PER_CLOCK;
X  volatile uint32_t PER_CLOCK;
N  __IO uint32_t CAN_CLOCK;
X  volatile uint32_t CAN_CLOCK;
N  __IO uint32_t TIM_CLOCK;
X  volatile uint32_t TIM_CLOCK;
N  __IO uint32_t UART_CLOCK;
X  volatile uint32_t UART_CLOCK;
N  __IO uint32_t SSP_CLOCK;
X  volatile uint32_t SSP_CLOCK;
N}MDR_RST_CLK_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_RST_CLK_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_RST_CLK_CLOCK_STATUS	RST CLK CLOCK STATUS
N  * @{
N  */ 
N
N/*-- RST_CLK_CLOCK_STATUS: Clock Status Register -------------------*/
N/* Bit field positions: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY_Pos    0
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY_Pos    1
N#define RST_CLK_CLOCK_STATUS_HSE_RDY_Pos        2
N
N/* Bit field masks: */
N#define RST_CLK_CLOCK_STATUS_PLL_USB_RDY        ((uint32_t)0x00000001)
N#define RST_CLK_CLOCK_STATUS_PLL_CPU_RDY        ((uint32_t)0x00000002)
N#define RST_CLK_CLOCK_STATUS_HSE_RDY            ((uint32_t)0x00000004)
N
N/** @} */ /* End of group RST_CLK_CLOCK_STATUS */
N
N/** @defgroup Periph_RST_CLK_PLL_CONTROL	RST CLK PLL CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_PLL_CONTROL: PLL Control Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON_Pos      0
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD_Pos     1
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON_Pos      2
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD_Pos     3
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos     4
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos     8
N
N/* Bit field masks: */
N#define RST_CLK_PLL_CONTROL_PLL_USB_ON          ((uint32_t)0x00000001)
N#define RST_CLK_PLL_CONTROL_PLL_USB_RLD         ((uint32_t)0x00000002)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_ON          ((uint32_t)0x00000004)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_PLD         ((uint32_t)0x00000008)
N#define RST_CLK_PLL_CONTROL_PLL_USB_MUL_Msk     ((uint32_t)0x000000F0)
N#define RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Msk     ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group RST_CLK_PLL_CONTROL */
N
N/** @defgroup Periph_RST_CLK_HS_CONTROL	RST CLK HS CONTROL
N  * @{
N  */ 
N
N/*-- RST_CLK_HS_CONTROL: HS Control Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_HS_CONTROL_HSE_ON_Pos           0
N#define RST_CLK_HS_CONTROL_HSE_BYP_Pos          1
N
N/* Bit field masks: */
N#define RST_CLK_HS_CONTROL_HSE_ON               ((uint32_t)0x00000001)
N#define RST_CLK_HS_CONTROL_HSE_BYP              ((uint32_t)0x00000002)
N
N/** @} */ /* End of group RST_CLK_HS_CONTROL */
N
N/** @defgroup Periph_RST_CLK_CPU_CLOCK	RST CLK CPU CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CPU_CLOCK: CPU Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos        0
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos        2
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos        4
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Pos          8
N
N/* Bit field masks: */
N#define RST_CLK_CPU_CLOCK_CPU_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_CPU_CLOCK_CPU_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_CPU_CLOCK_CPU_C3_SEL_Msk        ((uint32_t)0x000000F0)
N#define RST_CLK_CPU_CLOCK_HCLK_SEL_Msk          ((uint32_t)0x00000300)
N
N/** @} */ /* End of group RST_CLK_CPU_CLOCK */
N
N/** @defgroup Periph_RST_CLK_USB_CLOCK	RST CLK USB CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_USB_CLOCK: USB Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Pos        0
N#define RST_CLK_USB_CLOCK_USB_C2_SEL_Pos        2
N#define RST_CLK_USB_CLOCK_USB_C3_SEL_Pos        4
N#define RST_CLK_USB_CLOCK_USB_CLK_EN_Pos        8
N
N/* Bit field masks: */
N#define RST_CLK_USB_CLOCK_USB_C1_SEL_Msk        ((uint32_t)0x00000003)
N#define RST_CLK_USB_CLOCK_USB_C2_SEL            ((uint32_t)0x00000004)
N#define RST_CLK_USB_CLOCK_USB_C3_SEL	        ((uint32_t)0x00000010)
N#define RST_CLK_USB_CLOCK_USB_CLK_EN            ((uint32_t)0x00000100)
N
N/** @} */ /* End of group RST_CLK_USB_CLOCK */
N
N/** @defgroup Periph_RST_CLK_ADC_MCO_CLOCK	RST CLK ADC MCO CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_ADC_MCO_CLOCK: ADC Clock Register ---------------------*/
N/* Bit field positions: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos    0
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos    4
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos    8
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN_Pos    13
N
N/* Bit field masks: */
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Msk    ((uint32_t)0x00000003)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Msk    ((uint32_t)0x00000030)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Msk    ((uint32_t)0x00000F00)
N#define RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN        ((uint32_t)0x00002000)
N
N/** @} */ /* End of group RST_CLK_ADC_MCO_CLOCK */
N
N/** @defgroup Periph_RST_CLK_RTC_CLOCK	RST CLK RTC CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_RTC_CLOCK: RTC Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Pos           0
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Pos           4
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN_Pos        8
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN_Pos        9
N
N/* Bit field masks: */
N#define RST_CLK_RTC_CLOCK_HSE_SEL_Msk           ((uint32_t)0x0000000F)
N#define RST_CLK_RTC_CLOCK_HSI_SEL_Msk           ((uint32_t)0x000000F0)
N#define RST_CLK_RTC_CLOCK_HSE_RTC_EN            ((uint32_t)0x00000100)
N#define RST_CLK_RTC_CLOCK_HSI_RTC_EN            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group RST_CLK_RTC_CLOCK */
N
N/** @defgroup Periph_RST_CLK_CAN_CLOCK	RST CLK CAN CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_CAN_CLOCK: CAN Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Pos          0
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Pos          8
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN_Pos       24
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_CAN_CLOCK_CAN1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_CAN_CLOCK_CAN2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_CAN_CLOCK_CAN1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_CAN_CLOCK_CAN2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_CAN_CLOCK */
N
N/** @defgroup Periph_RST_CLK_TIM_CLOCK	RST CLK TIM CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_TIM_CLOCK: Timer Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Pos          0
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Pos          8
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Pos          16
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN_Pos       24
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN_Pos       25
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN_Pos       26
N
N/* Bit field masks: */
N#define RST_CLK_TIM_CLOCK_TIM1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_TIM_CLOCK_TIM2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_TIM_CLOCK_TIM3_BRG_Msk          ((uint32_t)0x00FF0000)
N#define RST_CLK_TIM_CLOCK_TIM1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_TIM_CLOCK_TIM2_CLK_EN           ((uint32_t)0x02000000)
N#define RST_CLK_TIM_CLOCK_TIM3_CLK_EN           ((uint32_t)0x04000000)
N
N/** @} */ /* End of group RST_CLK_TIM_CLOCK */
N
N/** @defgroup Periph_RST_CLK_UART_CLOCK	RST CLK UART CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_UART_CLOCK: UART Clock Register -----------------------*/
N/* Bit field positions: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Pos        0
N#define RST_CLK_UART_CLOCK_UART2_BRG_Pos        8
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN_Pos     24
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN_Pos     25
N
N/* Bit field masks: */
N#define RST_CLK_UART_CLOCK_UART1_BRG_Msk        ((uint32_t)0x000000FF)
N#define RST_CLK_UART_CLOCK_UART2_BRG_Msk        ((uint32_t)0x0000FF00)
N#define RST_CLK_UART_CLOCK_UART1_CLK_EN         ((uint32_t)0x01000000)
N#define RST_CLK_UART_CLOCK_UART2_CLK_EN         ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_UART_CLOCK */
N
N/** @defgroup Periph_RST_CLK_SSP_CLOCK	RST CLK SSP CLOCK
N  * @{
N  */ 
N
N/*-- RST_CLK_SSP_CLOCK: SSP Clock Register -------------------------*/
N/* Bit field positions: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Pos          0
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Pos          8
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN_Pos       24
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN_Pos       25
N
N/* Bit field masks: */
N#define RST_CLK_SSP_CLOCK_SSP1_BRG_Msk          ((uint32_t)0x000000FF)
N#define RST_CLK_SSP_CLOCK_SSP2_BRG_Msk          ((uint32_t)0x0000FF00)
N#define RST_CLK_SSP_CLOCK_SSP1_CLK_EN           ((uint32_t)0x01000000)
N#define RST_CLK_SSP_CLOCK_SSP2_CLK_EN           ((uint32_t)0x02000000)
N
N/** @} */ /* End of group RST_CLK_SSP_CLOCK */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_RST_CLK */
N
N/** @defgroup MDR32Fx_Periph_DMA DMA
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DMA_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DMA_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t CTRL_BASE_PTR;
X  volatile uint32_t CTRL_BASE_PTR;
N  __IO uint32_t ALT_CTRL_BASE_PTR;
X  volatile uint32_t ALT_CTRL_BASE_PTR;
N  __IO uint32_t WAITONREQ_STATUS;
X  volatile uint32_t WAITONREQ_STATUS;
N  __IO uint32_t CHNL_SW_REQUEST;
X  volatile uint32_t CHNL_SW_REQUEST;
N  __IO uint32_t CHNL_USEBURST_SET;
X  volatile uint32_t CHNL_USEBURST_SET;
N  __IO uint32_t CHNL_USEBURST_CLR;
X  volatile uint32_t CHNL_USEBURST_CLR;
N  __IO uint32_t CHNL_REQ_MASK_SET;
X  volatile uint32_t CHNL_REQ_MASK_SET;
N  __IO uint32_t CHNL_REQ_MASK_CLR;
X  volatile uint32_t CHNL_REQ_MASK_CLR;
N  __IO uint32_t CHNL_ENABLE_SET;
X  volatile uint32_t CHNL_ENABLE_SET;
N  __IO uint32_t CHNL_ENABLE_CLR;
X  volatile uint32_t CHNL_ENABLE_CLR;
N  __IO uint32_t CHNL_PRI_ALT_SET;
X  volatile uint32_t CHNL_PRI_ALT_SET;
N  __IO uint32_t CHNL_PRI_ALT_CLR;
X  volatile uint32_t CHNL_PRI_ALT_CLR;
N  __IO uint32_t CHNL_PRIORITY_SET;
X  volatile uint32_t CHNL_PRIORITY_SET;
N  __IO uint32_t CHNL_PRIORITY_CLR;
X  volatile uint32_t CHNL_PRIORITY_CLR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t ERR_CLR;
X  volatile uint32_t ERR_CLR;
N}MDR_DMA_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DMA_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DMA_STATUS	DMA STATUS
N  * @{
N  */ 
N
N/*-- DMA_STATUS: DMA Status Register -------------------------------*/
N/* Bit field positions: */
N#define DMA_STATUS_MASTER_ENABLE_Pos            0
N#define DMA_STATUS_STATE_Pos                    4
N#define DMA_STATUS_CHNLS_MINUS1_Pos             16
N#define DMA_STATUS_TEST_STATUS_Pos              28
N
N/* Bit field masks: */
N#define DMA_STATUS_MASTER_ENABLE                ((uint32_t)0x00000001)
N#define DMA_STATUS_STATE_Msk                    ((uint32_t)0x000000F0)
N#define DMA_STATUS_CHNLS_MINUS1_Msk             ((uint32_t)0x001F0000)
N#define DMA_STATUS_TEST_STATUS_Msk              ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group DMA_STATUS */
N
N/** @defgroup Periph_DMA_CFG	DMA CFG
N  * @{
N  */ 
N
N/*-- DMA_CFG: DMA Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DMA_CFG_MASTER_ENABLE_Pos               0
N#define DMA_CFG_CHNL_PROT_CTRL_Pos              5
N
N/* Bit field masks: */
N#define DMA_CFG_MASTER_ENABLE                   ((uint32_t)0x00000001)
N#define DMA_CFG_CHNL_PROT_CTRL_Msk              ((uint32_t)0x000000E0)
N
N/** @} */ /* End of group DMA_CFG */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DMA */
N
N/** @defgroup MDR32Fx_Periph_UART UART
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_UART_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_UART_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t RSR_ECR;
X  volatile uint32_t RSR_ECR;
N       uint32_t RESERVED0[4];
N  __IO uint32_t FR;
X  volatile uint32_t FR;
N       uint32_t RESERVED1;
N  __IO uint32_t ILPR;
X  volatile uint32_t ILPR;
N  __IO uint32_t IBRD;
X  volatile uint32_t IBRD;
N  __IO uint32_t FBRD;
X  volatile uint32_t FBRD;
N  __IO uint32_t LCR_H;
X  volatile uint32_t LCR_H;
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t IFLS;
X  volatile uint32_t IFLS;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_UART_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_UART_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_UART_DR	UART DR
N  * @{
N  */ 
N
N/*-- UART_DR: UART Data Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_DR_DATA_Pos                        0
N#define UART_DR_FE_Pos                          8
N#define UART_DR_PE_Pos                          9
N#define UART_DR_BE_Pos                          10
N#define UART_DR_OE_Pos                          11
N
N/* Bit field masks: */
N#define UART_DR_DATA_Msk                        ((uint32_t)0x000000FF)
N#define UART_DR_FE                              ((uint32_t)0x00000100)
N#define UART_DR_PE                              ((uint32_t)0x00000200)
N#define UART_DR_BE                              ((uint32_t)0x00000400)
N#define UART_DR_OE                              ((uint32_t)0x00000800)
N
N/** @} */ /* End of group UART_DR */
N
N/** @defgroup Periph_UART_RSR_ECR	UART RSR ECR
N  * @{
N  */ 
N
N/*-- UART_RSR_ECR: UART RSR Register -------------------------------*/
N/* Bit field positions: */
N#define UART_RSR_ECR_FE_Pos                     0
N#define UART_RSR_ECR_PE_Pos                     1
N#define UART_RSR_ECR_BE_Pos                     2
N#define UART_RSR_ECR_OE_Pos                     3
N
N/* Bit field masks: */
N#define UART_RSR_ECR_FE                         ((uint32_t)0x00000001)
N#define UART_RSR_ECR_PE                         ((uint32_t)0x00000002)
N#define UART_RSR_ECR_BE                         ((uint32_t)0x00000004)
N#define UART_RSR_ECR_OE                         ((uint32_t)0x00000008)
N
N/** @} */ /* End of group UART_RSR_ECR */
N
N/** @defgroup Periph_UART_FR	UART FR
N  * @{
N  */ 
N
N/*-- UART_FR: UART Flag Register -----------------------------------*/
N/* Bit field positions: */
N#define UART_FR_CTS_Pos                         0
N#define UART_FR_DSR_Pos                         1
N#define UART_FR_DCD_Pos                         2
N#define UART_FR_BUSY_Pos                        3
N#define UART_FR_RXFE_Pos                        4
N#define UART_FR_TXFF_Pos                        5
N#define UART_FR_RXFF_Pos                        6
N#define UART_FR_TXFE_Pos                        7
N#define UART_FR_RI_Pos                          8
N
N/* Bit field masks: */
N#define UART_FR_CTS                             ((uint32_t)0x00000001)
N#define UART_FR_DSR                             ((uint32_t)0x00000002)
N#define UART_FR_DCD                             ((uint32_t)0x00000004)
N#define UART_FR_BUSY                            ((uint32_t)0x00000008)
N#define UART_FR_RXFE                            ((uint32_t)0x00000010)
N#define UART_FR_TXFF                            ((uint32_t)0x00000020)
N#define UART_FR_RXFF                            ((uint32_t)0x00000040)
N#define UART_FR_TXFE                            ((uint32_t)0x00000080)
N#define UART_FR_RI                              ((uint32_t)0x00000100)
N
N/** @} */ /* End of group UART_FR */
N
N/** @defgroup Periph_UART_LCR_H	UART LCR H
N  * @{
N  */ 
N
N/*-- UART_LCR_H: UART LCR_H Register -------------------------------*/
N/* Bit field positions: */
N#define UART_LCR_H_BRK_Pos                      0
N#define UART_LCR_H_PEN_Pos                      1
N#define UART_LCR_H_EPS_Pos                      2
N#define UART_LCR_H_STP2_Pos                     3
N#define UART_LCR_H_FEN_Pos                      4
N#define UART_LCR_H_WLEN_Pos                     5
N#define UART_LCR_H_SPS_Pos                      7
N
N/* Bit field masks: */
N#define UART_LCR_H_BRK                          ((uint32_t)0x00000001)
N#define UART_LCR_H_PEN                          ((uint32_t)0x00000002)
N#define UART_LCR_H_EPS                          ((uint32_t)0x00000004)
N#define UART_LCR_H_STP2                         ((uint32_t)0x00000008)
N#define UART_LCR_H_FEN                          ((uint32_t)0x00000010)
N#define UART_LCR_H_WLEN_Msk                     ((uint32_t)0x00000060)
N#define UART_LCR_H_SPS                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group UART_LCR_H */
N
N/** @defgroup Periph_UART_CR	UART CR
N  * @{
N  */ 
N
N/*-- UART_CR: UART Command Register --------------------------------*/
N/* Bit field positions: */
N#define UART_CR_UARTEN_Pos                      0
N#define UART_CR_SIREN_Pos                       1
N#define UART_CR_SIRLP_Pos                       2
N#define UART_CR_LBE_Pos                         7
N#define UART_CR_TXE_Pos                         8
N#define UART_CR_RXE_Pos                         9
N#define UART_CR_DTR_Pos                         10
N#define UART_CR_RTS_Pos                         11
N#define UART_CR_OUT1_Pos                        12
N#define UART_CR_OUT2_Pos                        13
N#define UART_CR_RTSEN_Pos                       14
N#define UART_CR_CTSEN_Pos                       15
N
N/* Bit field masks: */
N#define UART_CR_UARTEN                          ((uint32_t)0x00000001)
N#define UART_CR_SIREN                           ((uint32_t)0x00000002)
N#define UART_CR_SIRLP                           ((uint32_t)0x00000004)
N#define UART_CR_LBE                             ((uint32_t)0x00000080)
N#define UART_CR_TXE                             ((uint32_t)0x00000100)
N#define UART_CR_RXE                             ((uint32_t)0x00000200)
N#define UART_CR_DTR                             ((uint32_t)0x00000400)
N#define UART_CR_RTS                             ((uint32_t)0x00000800)
N#define UART_CR_OUT1                            ((uint32_t)0x00001000)
N#define UART_CR_OUT2                            ((uint32_t)0x00002000)
N#define UART_CR_RTSEN                           ((uint32_t)0x00004000)
N#define UART_CR_CTSEN                           ((uint32_t)0x00008000)
N
N/** @} */ /* End of group UART_CR */
N
N/** @defgroup Periph_UART_IFLS	UART IFLS
N  * @{
N  */ 
N
N/*-- UART_IFLS: UART IFLS Register ---------------------------------*/
N/* Bit field positions: */
N#define UART_IFLS_TXIFLSEL_Pos                  0
N#define UART_IFLS_RXIFLSEL_Pos                  3
N
N/* Bit field masks: */
N#define UART_IFLS_TXIFLSEL_Msk                  ((uint32_t)0x00000007)
N#define UART_IFLS_RXIFLSEL_Msk                  ((uint32_t)0x00000038)
N
N/** @} */ /* End of group UART_IFLS */
N
N/** @defgroup Periph_UART_IMSC	UART IMSC
N  * @{
N  */ 
N
N/*-- UART_IMSC: UART Interrupt Mask Register -----------------------*/
N/* Bit field positions: */
N#define UART_IMSC_RIMIM_Pos                     0
N#define UART_IMSC_CTSMIM_Pos                    1
N#define UART_IMSC_DCDMIM_Pos                    2
N#define UART_IMSC_DSRMIM_Pos                    3
N#define UART_IMSC_RXIM_Pos                      4
N#define UART_IMSC_TXIM_Pos                      5
N#define UART_IMSC_RTIM_Pos                      6
N#define UART_IMSC_FEIM_Pos                      7
N#define UART_IMSC_PEIM_Pos                      8
N#define UART_IMSC_BEIM_Pos                      9
N#define UART_IMSC_OEIM_Pos                      10
N
N/* Bit field masks: */
N#define UART_IMSC_RIMIM                         ((uint32_t)0x00000001)
N#define UART_IMSC_CTSMIM                        ((uint32_t)0x00000002)
N#define UART_IMSC_DCDMIM                        ((uint32_t)0x00000004)
N#define UART_IMSC_DSRMIM                        ((uint32_t)0x00000008)
N#define UART_IMSC_RXIM                          ((uint32_t)0x00000010)
N#define UART_IMSC_TXIM                          ((uint32_t)0x00000020)
N#define UART_IMSC_RTIM                          ((uint32_t)0x00000040)
N#define UART_IMSC_FEIM                          ((uint32_t)0x00000080)
N#define UART_IMSC_PEIM                          ((uint32_t)0x00000100)
N#define UART_IMSC_BEIM                          ((uint32_t)0x00000200)
N#define UART_IMSC_OEIM                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_IMSC */
N
N/** @defgroup Periph_UART_RIS	UART RIS
N  * @{
N  */ 
N
N/*-- UART_RIS: UART Interrupt Pending Register ---------------------*/
N/* Bit field positions: */
N#define UART_RIS_RIRMIS_Pos                     0
N#define UART_RIS_CTSRMIS_Pos                    1
N#define UART_RIS_DCDRMIS_Pos                    2
N#define UART_RIS_DSRRMIS_Pos                    3
N#define UART_RIS_RXRIS_Pos                      4
N#define UART_RIS_TXRIS_Pos                      5
N#define UART_RIS_RTRIS_Pos                      6
N#define UART_RIS_FERIS_Pos                      7
N#define UART_RIS_PERIS_Pos                      8
N#define UART_RIS_BERIS_Pos                      9
N#define UART_RIS_OERIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_RIS_RIRMIS                         ((uint32_t)0x00000001)
N#define UART_RIS_CTSRMIS                        ((uint32_t)0x00000002)
N#define UART_RIS_DCDRMIS                        ((uint32_t)0x00000004)
N#define UART_RIS_DSRRMIS                        ((uint32_t)0x00000008)
N#define UART_RIS_RXRIS                          ((uint32_t)0x00000010)
N#define UART_RIS_TXRIS                          ((uint32_t)0x00000020)
N#define UART_RIS_RTRIS                          ((uint32_t)0x00000040)
N#define UART_RIS_FERIS                          ((uint32_t)0x00000080)
N#define UART_RIS_PERIS                          ((uint32_t)0x00000100)
N#define UART_RIS_BERIS                          ((uint32_t)0x00000200)
N#define UART_RIS_OERIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_RIS */
N
N/** @defgroup Periph_UART_MIS	UART MIS
N  * @{
N  */ 
N
N/*-- UART_MIS: UART Masked Interrupt Pending Register --------------*/
N/* Bit field positions: */
N#define UART_MIS_RIMMIS_Pos                     0
N#define UART_MIS_CTSMMIS_Pos                    1
N#define UART_MIS_DCDMMIS_Pos                    2
N#define UART_MIS_DSRMMIS_Pos                    3
N#define UART_MIS_RXMIS_Pos                      4
N#define UART_MIS_TXMIS_Pos                      5
N#define UART_MIS_RTMIS_Pos                      6
N#define UART_MIS_FEMIS_Pos                      7
N#define UART_MIS_PEMIS_Pos                      8
N#define UART_MIS_BEMIS_Pos                      9
N#define UART_MIS_OEMIS_Pos                      10
N
N/* Bit field masks: */
N#define UART_MIS_RIMMIS                         ((uint32_t)0x00000001)
N#define UART_MIS_CTSMMIS                        ((uint32_t)0x00000002)
N#define UART_MIS_DCDMMIS                        ((uint32_t)0x00000004)
N#define UART_MIS_DSRMMIS                        ((uint32_t)0x00000008)
N#define UART_MIS_RXMIS                          ((uint32_t)0x00000010)
N#define UART_MIS_TXMIS                          ((uint32_t)0x00000020)
N#define UART_MIS_RTMIS                          ((uint32_t)0x00000040)
N#define UART_MIS_FEMIS                          ((uint32_t)0x00000080)
N#define UART_MIS_PEMIS                          ((uint32_t)0x00000100)
N#define UART_MIS_BEMIS                          ((uint32_t)0x00000200)
N#define UART_MIS_OEMIS                          ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_MIS */
N
N/** @defgroup Periph_UART_ICR	UART ICR
N  * @{
N  */ 
N
N/*-- UART_ICR: UART Interrupt Clear Register -----------------------*/
N/* Bit field positions: */
N#define UART_ICR_RIMIC_Pos                      0
N#define UART_ICR_CTSMIC_Pos                     1
N#define UART_ICR_DCDMIC_Pos                     2
N#define UART_ICR_DSRMIC_Pos                     3
N#define UART_ICR_RXIC_Pos                       4
N#define UART_ICR_TXIC_Pos                       5
N#define UART_ICR_RTIC_Pos                       6
N#define UART_ICR_FEIC_Pos                       7
N#define UART_ICR_PEIC_Pos                       8
N#define UART_ICR_BEIC_Pos                       9
N#define UART_ICR_OEIC_Pos                       10
N
N/* Bit field masks: */
N#define UART_ICR_RIMIC                          ((uint32_t)0x00000001)
N#define UART_ICR_CTSMIC                         ((uint32_t)0x00000002)
N#define UART_ICR_DCDMIC                         ((uint32_t)0x00000004)
N#define UART_ICR_DSRMIC                         ((uint32_t)0x00000008)
N#define UART_ICR_RXIC                           ((uint32_t)0x00000010)
N#define UART_ICR_TXIC                           ((uint32_t)0x00000020)
N#define UART_ICR_RTIC                           ((uint32_t)0x00000040)
N#define UART_ICR_FEIC                           ((uint32_t)0x00000080)
N#define UART_ICR_PEIC                           ((uint32_t)0x00000100)
N#define UART_ICR_BEIC                           ((uint32_t)0x00000200)
N#define UART_ICR_OEIC                           ((uint32_t)0x00000400)
N
N/** @} */ /* End of group UART_ICR */
N
N/** @defgroup Periph_UART_DMACR	UART DMACR
N  * @{
N  */ 
N
N/*-- UART_DMACR: UART DMA Control Register -------------------------*/
N/* Bit field positions: */
N#define UART_DMACR_RXDMAE_Pos                   0
N#define UART_DMACR_TXDMAE_Pos                   1
N#define UART_DMACR_DMAONERR_Pos                 2
N
N/* Bit field masks: */
N#define UART_DMACR_RXDMAE                       ((uint32_t)0x00000001)
N#define UART_DMACR_TXDMAE                       ((uint32_t)0x00000002)
N#define UART_DMACR_DMAONERR                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group UART_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_UART */
N
N/** @defgroup MDR32Fx_Periph_SSP SSP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_SSP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_SSP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N}MDR_SSP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_SSP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_SSP_CR0	SSP CR0
N  * @{
N  */ 
N
N/*-- SSP_CR0: SSP Control0 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR0_DSS_Pos                         0
N#define SSP_CR0_FRF_Pos                         4
N#define SSP_CR0_SPO_Pos                         6
N#define SSP_CR0_SPH_Pos                         7
N#define SSP_CR0_SCR_Pos                         8
N
N/* Bit field masks: */
N#define SSP_CR0_DSS_Msk                         ((uint32_t)0x0000000F)
N#define SSP_CR0_FRF_Msk                         ((uint32_t)0x00000030)
N#define SSP_CR0_SPO                             ((uint32_t)0x00000040)
N#define SSP_CR0_SPH                             ((uint32_t)0x00000080)
N#define SSP_CR0_SCR_Msk                         ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group SSP_CR0 */
N
N/** @defgroup Periph_SSP_CR1	SSP CR1
N  * @{
N  */ 
N
N/*-- SSP_CR1: SSP Control1 Register --------------------------------*/
N/* Bit field positions: */
N#define SSP_CR1_LBM_Pos                         0
N#define SSP_CR1_SSE_Pos                         1
N#define SSP_CR1_MS_Pos                          2
N#define SSP_CR1_SOD_Pos                         3
N
N/* Bit field masks: */
N#define SSP_CR1_LBM                             ((uint32_t)0x00000001)
N#define SSP_CR1_SSE                             ((uint32_t)0x00000002)
N#define SSP_CR1_MS                              ((uint32_t)0x00000004)
N#define SSP_CR1_SOD                             ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_CR1 */
N
N/** @defgroup Periph_SSP_SR	SSP SR
N  * @{
N  */ 
N
N/*-- SSP_SR: SSP Status Register -----------------------------------*/
N/* Bit field positions: */
N#define SSP_SR_TFE_Pos                          0
N#define SSP_SR_TNF_Pos                          1
N#define SSP_SR_RNE_Pos                          2
N#define SSP_SR_RFF_Pos                          3
N#define SSP_SR_BSY_Pos                          4
N
N/* Bit field masks: */
N#define SSP_SR_TFE                              ((uint32_t)0x00000001)
N#define SSP_SR_TNF                              ((uint32_t)0x00000002)
N#define SSP_SR_RNE                              ((uint32_t)0x00000004)
N#define SSP_SR_RFF                              ((uint32_t)0x00000008)
N#define SSP_SR_BSY                              ((uint32_t)0x00000010)
N
N/** @} */ /* End of group SSP_SR */
N
N/** @defgroup Periph_SSP_IMSC	SSP IMSC
N  * @{
N  */ 
N
N/*-- SSP_IMSC: SSP Interrupt Mask Register -------------------------*/
N/* Bit field positions: */
N#define SSP_IMSC_RORIM_Pos                      0
N#define SSP_IMSC_RTIM_Pos                       1
N#define SSP_IMSC_RXIM_Pos                       2
N#define SSP_IMSC_TXIM_Pos                       3
N
N/* Bit field masks: */
N#define SSP_IMSC_RORIM                          ((uint32_t)0x00000001)
N#define SSP_IMSC_RTIM                           ((uint32_t)0x00000002)
N#define SSP_IMSC_RXIM                           ((uint32_t)0x00000004)
N#define SSP_IMSC_TXIM                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_IMSC */
N
N/** @defgroup Periph_SSP_RIS	SSP RIS
N  * @{
N  */ 
N
N/*-- SSP_RIS: SSP Interrupt Pending Register -----------------------*/
N/* Bit field positions: */
N#define SSP_RIS_RORRIS_Pos                      0
N#define SSP_RIS_RTRIS_Pos                       1
N#define SSP_RIS_RXRIS_Pos                       2
N#define SSP_RIS_TXRIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_RIS_RORRIS                          ((uint32_t)0x00000001)
N#define SSP_RIS_RTRIS                           ((uint32_t)0x00000002)
N#define SSP_RIS_RXRIS                           ((uint32_t)0x00000004)
N#define SSP_RIS_TXRIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_RIS */
N
N/** @defgroup Periph_SSP_MIS	SSP MIS
N  * @{
N  */ 
N
N/*-- SSP_MIS: SSP Masked Interrupt Pending Register ----------------*/
N/* Bit field positions: */
N#define SSP_MIS_RORMIS_Pos                      0
N#define SSP_MIS_RTMIS_Pos                       1
N#define SSP_MIS_RXMIS_Pos                       2
N#define SSP_MIS_TXMIS_Pos                       3
N
N/* Bit field masks: */
N#define SSP_MIS_RORMIS                          ((uint32_t)0x00000001)
N#define SSP_MIS_RTMIS                           ((uint32_t)0x00000002)
N#define SSP_MIS_RXMIS                           ((uint32_t)0x00000004)
N#define SSP_MIS_TXMIS                           ((uint32_t)0x00000008)
N
N/** @} */ /* End of group SSP_MIS */
N
N/** @defgroup Periph_SSP_ICR	SSP ICR
N  * @{
N  */ 
N
N/*-- SSP_ICR: SSP Interrupt Clear Register -------------------------*/
N/* Bit field positions: */
N#define SSP_ICR_RORIC_Pos                       0
N#define SSP_ICR_RTIC_Pos                        1
N
N/* Bit field masks: */
N#define SSP_ICR_RORIC                           ((uint32_t)0x00000001)
N#define SSP_ICR_RTIC                            ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_ICR */
N
N/** @defgroup Periph_SSP_DMACR	SSP DMACR
N  * @{
N  */ 
N
N/*-- SSP_DMACR: SSP DMA Control Register ---------------------------*/
N/* Bit field positions: */
N#define SSP_DMACR_RXDMAE_Pos                    0
N#define SSP_DMACR_TXDMAE_Pos                    1
N
N/* Bit field masks: */
N#define SSP_DMACR_RXDMAE                        ((uint32_t)0x00000001)
N#define SSP_DMACR_TXDMAE                        ((uint32_t)0x00000002)
N
N/** @} */ /* End of group SSP_DMACR */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_SSP */
N
N/** @defgroup MDR32Fx_Periph_I2C I2C
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_I2C_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_I2C_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PRL;
X  volatile uint32_t PRL;
N  __IO uint32_t PRH;
X  volatile uint32_t PRH;
N  __IO uint32_t CTR;
X  volatile uint32_t CTR;
N  __IO uint32_t RXD;
X  volatile uint32_t RXD;
N  __IO uint32_t STA;
X  volatile uint32_t STA;
N  __IO uint32_t TXD;
X  volatile uint32_t TXD;
N  __IO uint32_t CMD;
X  volatile uint32_t CMD;
N}MDR_I2C_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_I2C_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_I2C_CTR	I2C CTR
N  * @{
N  */ 
N
N/*-- I2C_CTR: I2C Control Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CTR_S_I2C_Pos                       5
N#define I2C_CTR_EN_INT_Pos                      6
N#define I2C_CTR_EN_I2C_Pos                      7
N
N/* Bit field masks: */
N#define I2C_CTR_S_I2C                           ((uint32_t)0x00000020)
N#define I2C_CTR_EN_INT                          ((uint32_t)0x00000040)
N#define I2C_CTR_EN_I2C                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CTR */
N
N/** @defgroup Periph_I2C_STA	I2C STA
N  * @{
N  */ 
N
N/*-- I2C_STA: I2C Status Register ----------------------------------*/
N/* Bit field positions: */
N#define I2C_STA_INT_Pos                         0
N#define I2C_STA_TR_PROG_Pos                     1
N#define I2C_STA_LOST_ARB_Pos                    5
N#define I2C_STA_BUSY_Pos                        6
N#define I2C_STA_RX_ACK_Pos                      7
N
N/* Bit field masks: */
N#define I2C_STA_INT                             ((uint32_t)0x00000001)
N#define I2C_STA_TR_PROG                         ((uint32_t)0x00000002)
N#define I2C_STA_LOST_ARB                        ((uint32_t)0x00000020)
N#define I2C_STA_BUSY                            ((uint32_t)0x00000040)
N#define I2C_STA_RX_ACK                          ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_STA */
N
N/** @defgroup Periph_I2C_CMD	I2C CMD
N  * @{
N  */ 
N
N/*-- I2C_CMD: I2C Command Register ---------------------------------*/
N/* Bit field positions: */
N#define I2C_CMD_CLRINT_Pos                      0
N#define I2C_CMD_ACK_Pos                         3
N#define I2C_CMD_WR_Pos                          4
N#define I2C_CMD_RD_Pos                          5
N#define I2C_CMD_STOP_Pos                        6
N#define I2C_CMD_START_Pos                       7
N
N/* Bit field masks: */
N#define I2C_CMD_CLRINT                          ((uint32_t)0x00000001)
N#define I2C_CMD_ACK                             ((uint32_t)0x00000008)
N#define I2C_CMD_WR                              ((uint32_t)0x00000010)
N#define I2C_CMD_RD                              ((uint32_t)0x00000020)
N#define I2C_CMD_STOP                            ((uint32_t)0x00000040)
N#define I2C_CMD_START                           ((uint32_t)0x00000080)
N
N/** @} */ /* End of group I2C_CMD */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_I2C */
N
N/** @defgroup MDR32Fx_Periph_POWER POWER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_POWER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_POWER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t PVDCS;
X  volatile uint32_t PVDCS;
N}MDR_POWER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_POWER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_POWER_PVDCS	POWER PVDCS
N  * @{
N  */ 
N
N/*-- POWER_PVDCS: POWER Power Detector Control/Status Register -----*/
N/* Bit field positions: */
N#define POWER_PVDCS_PVDEN_Pos                   0
N#define POWER_PVDCS_PBLS_Pos                    1
N#define POWER_PVDCS_PLS_Pos                     3
N#define POWER_PVDCS_PVBD_Pos                    6
N#define POWER_PVDCS_PVD_Pos                     7
N#define POWER_PVDCS_IEPVBD_Pos                  8
N#define POWER_PVDCS_IEPVD_Pos                   9
N#define POWER_PVDCS_INVB_Pos                    10
N#define POWER_PVDCS_INV_Pos                     11
N
N/* Bit field masks: */
N#define POWER_PVDCS_PVDEN                       ((uint32_t)0x00000001)
N#define POWER_PVDCS_PBLS_Msk                    ((uint32_t)0x00000006)
N#define POWER_PVDCS_PLS_Msk                     ((uint32_t)0x00000038)
N#define POWER_PVDCS_PVBD                        ((uint32_t)0x00000040)
N#define POWER_PVDCS_PVD                         ((uint32_t)0x00000080)
N#define POWER_PVDCS_IEPVBD                      ((uint32_t)0x00000100)
N#define POWER_PVDCS_IEPVD                       ((uint32_t)0x00000200)
N#define POWER_PVDCS_INVB                        ((uint32_t)0x00000400)
N#define POWER_PVDCS_INV                         ((uint32_t)0x00000800)
N
N/** @} */ /* End of group POWER_PVDCS */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_POWER */
N
N/** @defgroup MDR32Fx_Periph_WWDG WWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_WWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CR;
X  volatile uint32_t CR;
N  __IO uint32_t CFR;
X  volatile uint32_t CFR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_WWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_WWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_WWDG_CR	WWDG CR
N  * @{
N  */ 
N
N/*-- WWDG_CR: WWDG Command Register --------------------------------*/
N/* Bit field positions: */
N#define WWDG_CR_T_Pos                           0
N#define WWDG_CR_WDGA_Pos                        7
N
N/* Bit field masks: */
N#define WWDG_CR_T_Msk                           ((uint32_t)0x0000007F)
N#define WWDG_CR_WDGA                            ((uint32_t)0x00000080)
N
N/** @} */ /* End of group WWDG_CR */
N
N/** @defgroup Periph_WWDG_CFR	WWDG CFR
N  * @{
N  */ 
N
N/*-- WWDG_CFR: WWDG Configuration Register -------------------------*/
N/* Bit field positions: */
N#define WWDG_CFR_W_Pos                          0
N#define WWDG_CFR_WGTB_Pos                       7
N#define WWDG_CFR_EWI_Pos                        9
N
N/* Bit field masks: */
N#define WWDG_CFR_W_Msk                          ((uint32_t)0x0000007F)
N#define WWDG_CFR_WGTB_Msk                       ((uint32_t)0x00000180)
N#define WWDG_CFR_EWI                            ((uint32_t)0x00000200)
N
N/** @} */ /* End of group WWDG_CFR */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_WWDG */
N
N/** @defgroup MDR32Fx_Periph_IWDG IWDG
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_IWDG_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t KR;
X  volatile uint32_t KR;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t RLR;
X  volatile uint32_t RLR;
N  __IO uint32_t SR;
X  volatile uint32_t SR;
N}MDR_IWDG_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_IWDG_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_IWDG_SR	IWDG SR
N  * @{
N  */ 
N
N/*-- IWDG_SR: IWDG Status Register ---------------------------------*/
N/* Bit field positions: */
N#define IWDG_SR_PVU_Pos                         0
N#define IWDG_SR_RVU_Pos                         1
N
N/* Bit field masks: */
N#define IWDG_SR_PVU                             ((uint32_t)0x00000001)
N#define IWDG_SR_RVU                             ((uint32_t)0x00000002)
N
N/** @} */ /* End of group IWDG_SR */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_IWDG */
N
N/** @defgroup MDR32Fx_Periph_TIMER TIMER
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_TIMER_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CNT;
X  volatile uint32_t CNT;
N  __IO uint32_t PSG;
X  volatile uint32_t PSG;
N  __IO uint32_t ARR;
X  volatile uint32_t ARR;
N  __IO uint32_t CNTRL;
X  volatile uint32_t CNTRL;
N  __IO uint32_t CCR1;
X  volatile uint32_t CCR1;
N  __IO uint32_t CCR2;
X  volatile uint32_t CCR2;
N  __IO uint32_t CCR3;
X  volatile uint32_t CCR3;
N  __IO uint32_t CCR4;
X  volatile uint32_t CCR4;
N  __IO uint32_t CH1_CNTRL;
X  volatile uint32_t CH1_CNTRL;
N  __IO uint32_t CH2_CNTRL;
X  volatile uint32_t CH2_CNTRL;
N  __IO uint32_t CH3_CNTRL;
X  volatile uint32_t CH3_CNTRL;
N  __IO uint32_t CH4_CNTRL;
X  volatile uint32_t CH4_CNTRL;
N  __IO uint32_t CH1_CNTRL1;
X  volatile uint32_t CH1_CNTRL1;
N  __IO uint32_t CH2_CNTRL1;
X  volatile uint32_t CH2_CNTRL1;
N  __IO uint32_t CH3_CNTRL1;
X  volatile uint32_t CH3_CNTRL1;
N  __IO uint32_t CH4_CNTRL1;
X  volatile uint32_t CH4_CNTRL1;
N  __IO uint32_t CH1_DTG;
X  volatile uint32_t CH1_DTG;
N  __IO uint32_t CH2_DTG;
X  volatile uint32_t CH2_DTG;
N  __IO uint32_t CH3_DTG;
X  volatile uint32_t CH3_DTG;
N  __IO uint32_t CH4_DTG;
X  volatile uint32_t CH4_DTG;
N  __IO uint32_t BRKETR_CNTRL;
X  volatile uint32_t BRKETR_CNTRL;
N  __IO uint32_t STATUS;
X  volatile uint32_t STATUS;
N  __IO uint32_t IE;
X  volatile uint32_t IE;
N  __IO uint32_t DMA_RE;
X  volatile uint32_t DMA_RE;
N  __IO uint32_t CH1_CNTRL2;
X  volatile uint32_t CH1_CNTRL2;
N  __IO uint32_t CH2_CNTRL2;
X  volatile uint32_t CH2_CNTRL2;
N  __IO uint32_t CH3_CNTRL2;
X  volatile uint32_t CH3_CNTRL2;
N  __IO uint32_t CH4_CNTRL2;
X  volatile uint32_t CH4_CNTRL2;
N  __IO uint32_t CCR11;
X  volatile uint32_t CCR11;
N  __IO uint32_t CCR21;
X  volatile uint32_t CCR21;
N  __IO uint32_t CCR31;
X  volatile uint32_t CCR31;
N  __IO uint32_t CCR41;
X  volatile uint32_t CCR41;
N}MDR_TIMER_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_TIMER_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_TIMER_CNTRL	TIMER CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CNTRL: Timer Control Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_CNTRL_CNT_EN_Pos                  0
N#define TIMER_CNTRL_ARRB_EN_Pos                 1
N#define TIMER_CNTRL_WR_CMPL_Pos                 2
N#define TIMER_CNTRL_DIR_Pos                     3
N#define TIMER_CNTRL_FDTS_Pos                    4
N#define TIMER_CNTRL_CNT_MODE_Pos                6
N#define TIMER_CNTRL_EVENT_SEL_Pos               8
N
N/* Bit field masks: */
N#define TIMER_CNTRL_CNT_EN                      ((uint32_t)0x00000001)
N#define TIMER_CNTRL_ARRB_EN                     ((uint32_t)0x00000002)
N#define TIMER_CNTRL_WR_CMPL                     ((uint32_t)0x00000004)
N#define TIMER_CNTRL_DIR                         ((uint32_t)0x00000008)
N#define TIMER_CNTRL_FDTS_Msk                    ((uint32_t)0x00000030)
N#define TIMER_CNTRL_CNT_MODE_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CNTRL_EVENT_SEL_Msk               ((uint32_t)0x00000F00)
N
N/** @} */ /* End of group TIMER_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL	TIMER CH CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL: Timer Channel Control Register ----------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL_CHFLTR_Pos               0
N#define TIMER_CH_CNTRL_CHSEL_Pos                4
N#define TIMER_CH_CNTRL_CHPSC_Pos                6
N#define TIMER_CH_CNTRL_OCCE_Pos                 8
N#define TIMER_CH_CNTRL_OCCM_Pos                 9
N#define TIMER_CH_CNTRL_BRKEN_Pos                12
N#define TIMER_CH_CNTRL_ETREN_Pos                13
N#define TIMER_CH_CNTRL_WR_CMPL_Pos              14
N#define TIMER_CH_CNTRL_CAP_NPWM_Pos             15
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL_CHFLTR_Msk               ((uint32_t)0x0000000F)
N#define TIMER_CH_CNTRL_CHSEL_Msk                ((uint32_t)0x00000030)
N#define TIMER_CH_CNTRL_CHPSC_Msk                ((uint32_t)0x000000C0)
N#define TIMER_CH_CNTRL_OCCE                     ((uint32_t)0x00000100)
N#define TIMER_CH_CNTRL_OCCM_Msk                 ((uint32_t)0x00000E00)
N#define TIMER_CH_CNTRL_BRKEN                    ((uint32_t)0x00001000)
N#define TIMER_CH_CNTRL_ETREN                    ((uint32_t)0x00002000)
N#define TIMER_CH_CNTRL_WR_CMPL                  ((uint32_t)0x00004000)
N#define TIMER_CH_CNTRL_CAP_NPWM                 ((uint32_t)0x00008000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL */
N
N/** @defgroup Periph_TIMER_CH_CNTRL1	TIMER CH CNTRL1
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL1: Timer Channel Control1 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL1_SELOE_Pos               0
N#define TIMER_CH_CNTRL1_SELO_Pos                2
N#define TIMER_CH_CNTRL1_INV_Pos                 4
N#define TIMER_CH_CNTRL1_NSELOE_Pos              8
N#define TIMER_CH_CNTRL1_NSELO_Pos               10
N#define TIMER_CH_CNTRL1_NINV_Pos                12
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL1_SELOE_Msk               ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL1_SELO_Msk                ((uint32_t)0x0000000C)
N#define TIMER_CH_CNTRL1_INV                     ((uint32_t)0x00000010)
N#define TIMER_CH_CNTRL1_NSELOE_Msk              ((uint32_t)0x00000300)
N#define TIMER_CH_CNTRL1_NSELO_Msk               ((uint32_t)0x00000C00)
N#define TIMER_CH_CNTRL1_NINV                    ((uint32_t)0x00001000)
N
N/** @} */ /* End of group TIMER_CH_CNTRL1 */
N
N/** @defgroup Periph_TIMER_CH_DTG	TIMER CH DTG
N  * @{
N  */ 
N
N/*-- TIMER_CH_DTG: Timer Channel DTG Register ----------------------*/
N/* Bit field positions: */
N#define TIMER_CH_DTGX_Pos                       0
N#define TIMER_CH_DTG_EDTS_Pos                   4
N#define TIMER_CH_DTG_Pos                        8
N
N/* Bit field masks: */
N#define TIMER_CH_DTGX_Msk                       ((uint32_t)0x0000000F)
N#define TIMER_CH_DTG_EDTS                       ((uint32_t)0x00000010)
N#define TIMER_CH_DTG_Msk                        ((uint32_t)0x0000FF00)
N
N/** @} */ /* End of group TIMER_CH_DTG */
N
N/** @defgroup Periph_TIMER_BRKETR_CNTRL	TIMER BRKETR CNTRL
N  * @{
N  */ 
N
N/*-- TIMER_BRKETR_CNTRL: Timer BRK/ETR Control Register ------------*/
N/* Bit field positions: */
N#define TIMER_BRKETR_CNTRL_BRK_INV_Pos          0
N#define TIMER_BRKETR_CNTRL_ETR_INV_Pos          1
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Pos          2
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Pos       4
N
N/* Bit field masks: */
N#define TIMER_BRKETR_CNTRL_BRK_INV              ((uint32_t)0x00000001)
N#define TIMER_BRKETR_CNTRL_ETR_INV              ((uint32_t)0x00000002)
N#define TIMER_BRKETR_CNTRL_ETR_PSC_Msk          ((uint32_t)0x0000000C)
N#define TIMER_BRKETR_CNTRL_ETR_FILTER_Msk       ((uint32_t)0x000000F0)
N
N/** @} */ /* End of group TIMER_BRKETR_CNTRL */
N
N/** @defgroup Periph_TIMER_STATUS	TIMER STATUS
N  * @{
N  */ 
N
N/*-- TIMER_STATUS: Timer Status Register ---------------------------*/
N/* Bit field positions: */
N#define TIMER_STATUS_CNT_ZERO_EVENT_Pos         0
N#define TIMER_STATUS_CNT_ARR_EVENT_Pos          1
N#define TIMER_STATUS_ETR_RE_EVENT_Pos           2
N#define TIMER_STATUS_ETR_FE_EVENT_Pos           3
N#define TIMER_STATUS_BRK_EVENT_Pos              4
N#define TIMER_STATUS_CCR_CAP_EVENT_Pos          5
N#define TIMER_STATUS_CCR_REF_EVENT_Pos          9
N#define TIMER_STATUS_CCR1_CAP_EVENT_Pos         13
N
N/* Bit field masks: */
N#define TIMER_STATUS_CNT_ZERO_EVENT             ((uint32_t)0x00000001)
N#define TIMER_STATUS_CNT_ARR_EVENT              ((uint32_t)0x00000002)
N#define TIMER_STATUS_ETR_RE_EVENT               ((uint32_t)0x00000004)
N#define TIMER_STATUS_ETR_FE_EVENT               ((uint32_t)0x00000008)
N#define TIMER_STATUS_BRK_EVENT                  ((uint32_t)0x00000010)
N#define TIMER_STATUS_CCR_CAP_EVENT_Msk          ((uint32_t)0x000001E0)
N#define TIMER_STATUS_CCR_REF_EVENT_Msk          ((uint32_t)0x00001E00)
N#define TIMER_STATUS_CCR1_CAP_EVENT_Msk         ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_STATUS */
N
N/** @defgroup Periph_TIMER_IE	TIMER IE
N  * @{
N  */ 
N
N/*-- TIMER_IE: Timer Interrupt Enable Register ---------------------*/
N/* Bit field positions: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE_Pos          0
N#define TIMER_IE_CNT_ARR_EVENT_IE_Pos           1
N#define TIMER_IE_ETR_RE_EVENT_IE_Pos            2
N#define TIMER_IE_ETR_FE_EVENT_IE_Pos            3
N#define TIMER_IE_BRK_EVENT_IE_Pos               4
N#define TIMER_IE_CCR_CAP_EVENT_IE_Pos           5
N#define TIMER_IE_CCR_REF_EVENT_IE_Pos           9
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Pos          13
N
N/* Bit field masks: */
N#define TIMER_IE_CNT_ZERO_EVENT_IE              ((uint32_t)0x00000001)
N#define TIMER_IE_CNT_ARR_EVENT_IE               ((uint32_t)0x00000002)
N#define TIMER_IE_ETR_RE_EVENT_IE                ((uint32_t)0x00000004)
N#define TIMER_IE_ETR_FE_EVENT_IE                ((uint32_t)0x00000008)
N#define TIMER_IE_BRK_EVENT_IE                   ((uint32_t)0x00000010)
N#define TIMER_IE_CCR_CAP_EVENT_IE_Msk           ((uint32_t)0x000001E0)
N#define TIMER_IE_CCR_REF_EVENT_IE_Msk           ((uint32_t)0x00001E00)
N#define TIMER_IE_CCR1_CAP_EVENT_IE_Msk          ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_IE */
N
N/** @defgroup Periph_TIMER_DMA_RE	TIMER DMA RE
N  * @{
N  */ 
N
N/*-- TIMER_DMA_RE: Timer DMA Request Enable Register ---------------*/
N/* Bit field positions: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE_Pos      0
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE_Pos       1
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE_Pos        2
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE_Pos        3
N#define TIMER_DMA_RE_BRK_EVENT_RE_Pos           4
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Pos       5
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Pos       9
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Pos      13
N
N/* Bit field masks: */
N#define TIMER_DMA_RE_CNT_ZERO_EVENT_RE          ((uint32_t)0x00000001)
N#define TIMER_DMA_RE_CNT_ARR_EVENT_RE           ((uint32_t)0x00000002)
N#define TIMER_DMA_RE_ETR_RE_EVENT_RE            ((uint32_t)0x00000004)
N#define TIMER_DMA_RE_ETR_FE_EVENT_RE            ((uint32_t)0x00000008)
N#define TIMER_DMA_RE_BRK_EVENT_RE               ((uint32_t)0x00000010)
N#define TIMER_DMA_RE_CCR_CAP_EVENT_RE_Msk       ((uint32_t)0x000001E0)
N#define TIMER_DMA_RE_CCR_REF_EVENT_RE_Msk       ((uint32_t)0x00001E00)
N#define TIMER_DMA_RE_CCR1_CAP_EVENT_RE_Msk      ((uint32_t)0x0001E000)
N
N/** @} */ /* End of group TIMER_DMA_RE */
N
N/** @defgroup Periph_TIMER_CH_CNTRL2	TIMER CH CNTRL2
N  * @{
N  */ 
N
N/*-- TIMER_CH_CNTRL2: Timer Channel Control2 Register --------------*/
N/* Bit field positions: */
N#define TIMER_CH_CNTRL2_CHSEL1_Pos              0
N#define TIMER_CH_CNTRL2_CCR1_EN_Pos             2
N#define TIMER_CH_CNTRL2_CCRRLD_Pos              3
N
N/* Bit field masks: */
N#define TIMER_CH_CNTRL2_CHSEL1_Msk              ((uint32_t)0x00000003)
N#define TIMER_CH_CNTRL2_CCR1_EN                 ((uint32_t)0x00000004)
N#define TIMER_CH_CNTRL2_CCRRLD                  ((uint32_t)0x00000008)
N
N/** @} */ /* End of group TIMER_CH_CNTRL2 */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_TIMER */
N
N/** @defgroup MDR32Fx_Periph_ADC ADC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_ADC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_ADC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t ADC1_CFG;
X  volatile uint32_t ADC1_CFG;
N  __IO uint32_t ADC2_CFG;
X  volatile uint32_t ADC2_CFG;
N  __IO uint32_t ADC1_H_LEVEL;
X  volatile uint32_t ADC1_H_LEVEL;
N  __IO uint32_t ADC2_H_LEVEL;
X  volatile uint32_t ADC2_H_LEVEL;
N  __IO uint32_t ADC1_L_LEVEL;
X  volatile uint32_t ADC1_L_LEVEL;
N  __IO uint32_t ADC2_L_LEVEL;
X  volatile uint32_t ADC2_L_LEVEL;
N  __IO uint32_t ADC1_RESULT;
X  volatile uint32_t ADC1_RESULT;
N  __IO uint32_t ADC2_RESULT;
X  volatile uint32_t ADC2_RESULT;
N  __IO uint32_t ADC1_STATUS;
X  volatile uint32_t ADC1_STATUS;
N  __IO uint32_t ADC2_STATUS;
X  volatile uint32_t ADC2_STATUS;
N  __IO uint32_t ADC1_CHSEL;
X  volatile uint32_t ADC1_CHSEL;
N  __IO uint32_t ADC2_CHSEL;
X  volatile uint32_t ADC2_CHSEL;
N}MDR_ADC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_ADC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_ADC1_CFG	ADC1 CFG
N  * @{
N  */ 
N
N/*-- ADC1_CFG: ADC1 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC1_CFG_REG_ADON_Pos                   0
N#define ADC1_CFG_REG_GO_Pos                     1
N#define ADC1_CFG_REG_CLKS_Pos                   2
N#define ADC1_CFG_REG_SAMPLE_Pos                 3
N#define ADC1_CFG_REG_CHS_Pos                    4
N#define ADC1_CFG_REG_CHCH_Pos                   9
N#define ADC1_CFG_REG_RNGC_Pos                   10
N#define ADC1_CFG_M_REF_Pos                      11
N#define ADC1_CFG_REG_DIVCLK_Pos                 12
N#define ADC1_CFG_SYNC_CONVER_Pos                16
N#define ADC1_CFG_TS_EN_Pos                      17
N#define ADC1_CFG_TS_BUF_EN_Pos                  18
N#define ADC1_CFG_SEL_TS_Pos                     19
N#define ADC1_CFG_SEL_VREF_Pos                   20
N#define ADC1_CFG_TR_Pos                         21
N#define ADC1_CFG_DELAY_GO_Pos                   25
N#define ADC1_CFG_DELAY_ADC_Pos                  28
N
N/* Bit field masks: */
N#define ADC1_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC1_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC1_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC1_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC1_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC1_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC1_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC1_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC1_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC1_CFG_SYNC_CONVER                    ((uint32_t)0x00010000)
N#define ADC1_CFG_TS_EN                          ((uint32_t)0x00020000)
N#define ADC1_CFG_TS_BUF_EN                      ((uint32_t)0x00040000)
N#define ADC1_CFG_SEL_TS                         ((uint32_t)0x00080000)
N#define ADC1_CFG_SEL_VREF                       ((uint32_t)0x00100000)
N#define ADC1_CFG_TR_Msk                         ((uint32_t)0x01E00000)
N#define ADC1_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N#define ADC1_CFG_DELAY_ADC_Msk                  ((uint32_t)0xF0000000)
N
N/** @} */ /* End of group ADC1_CFG */
N
N/** @defgroup Periph_ADC2_CFG	ADC2 CFG
N  * @{
N  */ 
N
N/*-- ADC2_CFG: ADC2 Configuration Register -------------------------*/
N/* Bit field positions: */
N#define ADC2_CFG_REG_ADON_Pos                   0
N#define ADC2_CFG_REG_GO_Pos                     1
N#define ADC2_CFG_REG_CLKS_Pos                   2
N#define ADC2_CFG_REG_SAMPLE_Pos                 3
N#define ADC2_CFG_REG_CHS_Pos                    4
N#define ADC2_CFG_REG_CHCH_Pos                   9
N#define ADC2_CFG_REG_RNGC_Pos                   10
N#define ADC2_CFG_M_REF_Pos                      11
N#define ADC2_CFG_REG_DIVCLK_Pos                 12
N#define ADC2_CFG_ADC1_OP_Pos                    17
N#define ADC2_CFG_ADC2_OP_Pos                    18
N#define ADC2_CFG_DELAY_GO_Pos                   25
N
N/* Bit field masks: */
N#define ADC2_CFG_REG_ADON                       ((uint32_t)0x00000001)
N#define ADC2_CFG_REG_GO                         ((uint32_t)0x00000002)
N#define ADC2_CFG_REG_CLKS                       ((uint32_t)0x00000004)
N#define ADC2_CFG_REG_SAMPLE                     ((uint32_t)0x00000008)
N#define ADC2_CFG_REG_CHS_Msk                    ((uint32_t)0x000001F0)
N#define ADC2_CFG_REG_CHCH                       ((uint32_t)0x00000200)
N#define ADC2_CFG_REG_RNGC                       ((uint32_t)0x00000400)
N#define ADC2_CFG_M_REF                          ((uint32_t)0x00000800)
N#define ADC2_CFG_REG_DIVCLK_Msk                 ((uint32_t)0x0000F000)
N#define ADC2_CFG_ADC1_OP                        ((uint32_t)0x00020000)
N#define ADC2_CFG_ADC2_OP                        ((uint32_t)0x00040000)
N#define ADC2_CFG_DELAY_GO_Msk                   ((uint32_t)0x0E000000)
N
N/** @} */ /* End of group ADC2_CFG */
N
N/** @defgroup Periph_ADC1_RESULT	ADC1 RESULT
N  * @{
N  */ 
N
N/*-- ADC1_RESULT: ADC1 Result Register -----------------------------*/
N/*-- ADC2_RESULT: ADC2 Result Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_RESULT_Pos                          0
N#define ADC_RESULT_CHANNEL_Pos                  16
N
N/* Bit field masks: */
N#define ADC_RESULT_Msk                          ((uint32_t)0x00000FFF)
N#define ADC_RESULT_CHANNEL_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group ADC1_RESULT */
N
N/** @defgroup Periph_ADC1_STATUS	ADC1 STATUS
N  * @{
N  */ 
N
N/*-- ADC1_STATUS: ADC1 Status Register -----------------------------*/
N/*-- ADC2_STATUS: ADC2 Status Register -----------------------------*/
N/* Bit field positions: */
N#define ADC_STATUS_FLG_REG_OVERWRITE_Pos        0
N#define ADC_STATUS_FLG_REG_AWOIFEN_Pos          1
N#define ADC_STATUS_FLG_REG_EOCIF_Pos            2
N#define ADC_STATUS_AWOIF_IE_Pos                 3
N#define ADC_STATUS_ECOIF_IE_Pos                 4
N
N/* Bit field masks: */
N#define ADC_STATUS_FLG_REG_OVERWRITE            ((uint32_t)0x00000001)
N#define ADC_STATUS_FLG_REG_AWOIFEN              ((uint32_t)0x00000002)
N#define ADC_STATUS_FLG_REG_EOCIF                ((uint32_t)0x00000004)
N#define ADC_STATUS_AWOIF_IE                     ((uint32_t)0x00000008)
N#define ADC_STATUS_ECOIF_IE                     ((uint32_t)0x00000010)
N
N/** @} */ /* End of group ADC1_STATUS */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_ADC */
N
N/** @defgroup MDR32Fx_Periph_DAC DAC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_DAC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_DAC_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t DAC1_DATA;
X  volatile uint32_t DAC1_DATA;
N  __IO uint32_t DAC2_DATA;
X  volatile uint32_t DAC2_DATA;
N}MDR_DAC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_DAC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_DAC_CFG	DAC CFG
N  * @{
N  */ 
N
N/*-- DAC_CFG: DAC Configuration Register ---------------------------*/
N/* Bit field positions: */
N#define DAC_CFG_M_REF0_Pos                      0
N#define DAC_CFG_M_REF1_Pos                      1
N#define DAC_CFG_ON_DAC0_Pos                     2
N#define DAC_CFG_ON_DAC1_Pos                     3
N#define DAC_CFG_SYNC_A_Pos                      4
N
N/* Bit field masks: */
N#define DAC_CFG_M_REF0                          ((uint32_t)0x00000001)
N#define DAC_CFG_M_REF1                          ((uint32_t)0x00000002)
N#define DAC_CFG_ON_DAC0                         ((uint32_t)0x00000004)
N#define DAC_CFG_ON_DAC1                         ((uint32_t)0x00000008)
N#define DAC_CFG_SYNC_A                          ((uint32_t)0x00000010)
N
N/** @} */ /* End of group DAC_CFG */
N
N/** @defgroup Periph_DAC1_DATA	DAC1 DATA
N  * @{
N  */ 
N
N/*-- DAC1_DATA: DAC1 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC1_DATA_DAC0DATA_Pos                  0
N#define DAC1_DATA_DAC1DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC1_DATA_DAC0DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC1_DATA_DAC1DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC1_DATA */
N
N/** @defgroup Periph_DAC2_DATA	DAC2 DATA
N  * @{
N  */ 
N
N/*-- DAC2_DATA: DAC2 Data Register ---------------------------------*/
N/* Bit field positions: */
N#define DAC2_DATA_DAC1DATA_Pos                  0
N#define DAC2_DATA_DAC0DATA_Pos                  16
N
N/* Bit field masks: */
N#define DAC2_DATA_DAC1DATA_Msk                  ((uint32_t)0x00000FFF)
N#define DAC2_DATA_DAC0DATA_Msk                  ((uint32_t)0x0FFF0000)
N
N/** @} */ /* End of group DAC2_DATA */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_DAC */
N
N/** @defgroup MDR32Fx_Periph_COMP COMP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_COMP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_COMP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t CFG;
X  volatile uint32_t CFG;
N  __IO uint32_t RESULT;
X  volatile uint32_t RESULT;
N  __IO uint32_t RESULT_LATCH;
X  volatile uint32_t RESULT_LATCH;
N}MDR_COMP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_COMP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_COMP_CFG	COMP CFG
N  * @{
N  */ 
N
N/*-- COMP_CFG: COMP Configuration Register -------------------------*/
N/* Bit field positions: */
N#define COMP_CFG_ON_Pos                         0
N#define COMP_CFG_CVRR_Pos                       1
N#define COMP_CFG_CVRSS_Pos                      2
N#define COMP_CFG_CVREN_Pos                      3
N#define COMP_CFG_CVR_Pos                        4
N#define COMP_CFG_CREF_Pos                       8
N#define COMP_CFG_CCH_Pos                        9
N#define COMP_CFG_INV_Pos                        11
N#define COMP_CFG_READY_Pos                      12
N#define COMP_CFG_CMPIE_Pos                      13
N
N/* Bit field masks: */
N#define COMP_CFG_ON                             ((uint32_t)0x00000001)
N#define COMP_CFG_CVRR                           ((uint32_t)0x00000002)
N#define COMP_CFG_CVRSS                          ((uint32_t)0x00000004)
N#define COMP_CFG_CVREN                          ((uint32_t)0x00000008)
N#define COMP_CFG_CVR_Msk                        ((uint32_t)0x000000F0)
N#define COMP_CFG_CREF                           ((uint32_t)0x00000100)
N#define COMP_CFG_CCH_Msk                        ((uint32_t)0x00000600)
N#define COMP_CFG_INV                            ((uint32_t)0x00000800)
N#define COMP_CFG_READY                          ((uint32_t)0x00001000)
N#define COMP_CFG_CMPIE                          ((uint32_t)0x00002000)
N
N/** @} */ /* End of group COMP_CFG */
N
N/** @defgroup Periph_COMP_RESULT	COMP RESULT
N  * @{
N  */ 
N
N/*-- COMP_RESULT: COMP Result Register -----------------------------*/
N/* Bit field positions: */
N#define COMP_RESULT_RSLT_SY_Pos                 0
N#define COMP_RESULT_RSLT_AS_Pos                 1
N#define COMP_RESULT_RST_LCH_Pos                 2
N
N/* Bit field masks: */
N#define COMP_RESULT_RSLT_SY                     ((uint32_t)0x00000001)
N#define COMP_RESULT_RSLT_AS                     ((uint32_t)0x00000002)
N#define COMP_RESULT_RST_LCH                     ((uint32_t)0x00000004)
N
N/** @} */ /* End of group COMP_RESULT */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_COMP */
N
N/** @defgroup MDR32Fx_Periph_PORT PORT
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_PORT_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_PORT_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t RXTX;
X  volatile uint32_t RXTX;
N  __IO uint32_t OE;
X  volatile uint32_t OE;
N  __IO uint32_t FUNC;
X  volatile uint32_t FUNC;
N  __IO uint32_t ANALOG;
X  volatile uint32_t ANALOG;
N  __IO uint32_t PULL;
X  volatile uint32_t PULL;
N  __IO uint32_t PD;
X  volatile uint32_t PD;
N  __IO uint32_t PWR;
X  volatile uint32_t PWR;
N  __IO uint32_t GFEN;
X  volatile uint32_t GFEN;
N}MDR_PORT_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_PORT_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_PORT_FUNC	PORT FUNC
N  * @{
N  */ 
N
N/*-- PORT_FUNC: PORT Function Register -----------------------------*/
N/* Bit field positions: */
N#define PORT_FUNC_MODE0_Pos                     0
N#define PORT_FUNC_MODE1_Pos                     2
N#define PORT_FUNC_MODE2_Pos                     4
N#define PORT_FUNC_MODE3_Pos                     6
N#define PORT_FUNC_MODE4_Pos                     8
N#define PORT_FUNC_MODE5_Pos                     10
N#define PORT_FUNC_MODE6_Pos                     12
N#define PORT_FUNC_MODE7_Pos                     14
N#define PORT_FUNC_MODE8_Pos                     16
N#define PORT_FUNC_MODE9_Pos                     18
N#define PORT_FUNC_MODE10_Pos                    20
N#define PORT_FUNC_MODE11_Pos                    22
N#define PORT_FUNC_MODE12_Pos                    24
N#define PORT_FUNC_MODE13_Pos                    26
N#define PORT_FUNC_MODE14_Pos                    28
N#define PORT_FUNC_MODE15_Pos                    30
N
N/* Bit field masks: */
N#define PORT_FUNC_MODE0_Msk                     ((uint32_t)0x00000003)
N#define PORT_FUNC_MODE1_Msk                     ((uint32_t)0x0000000C)
N#define PORT_FUNC_MODE2_Msk                     ((uint32_t)0x00000030)
N#define PORT_FUNC_MODE3_Msk                     ((uint32_t)0x000000C0)
N#define PORT_FUNC_MODE4_Msk                     ((uint32_t)0x00000300)
N#define PORT_FUNC_MODE5_Msk                     ((uint32_t)0x00000C00)
N#define PORT_FUNC_MODE6_Msk                     ((uint32_t)0x00003000)
N#define PORT_FUNC_MODE7_Msk                     ((uint32_t)0x0000C000)
N#define PORT_FUNC_MODE8_Msk                     ((uint32_t)0x00030000)
N#define PORT_FUNC_MODE9_Msk                     ((uint32_t)0x000C0000)
N#define PORT_FUNC_MODE10_Msk                    ((uint32_t)0x00300000)
N#define PORT_FUNC_MODE11_Msk                    ((uint32_t)0x00C00000)
N#define PORT_FUNC_MODE12_Msk                    ((uint32_t)0x03000000)
N#define PORT_FUNC_MODE13_Msk                    ((uint32_t)0x0C000000)
N#define PORT_FUNC_MODE14_Msk                    ((uint32_t)0x30000000)
N#define PORT_FUNC_MODE15_Msk                    ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_FUNC */
N
N/** @defgroup Periph_PORT_PULL	PORT PULL
N  * @{
N  */ 
N
N/*-- PORT_PULL: PORT Pull Up/Down Register -------------------------*/
N/* Bit field positions: */
N#define PORT_PULL_DOWN_Pos                      0
N#define PORT_PULL_UP_Pos                        16
N
N/* Bit field masks: */
N#define PORT_PULL_DOWN_Msk                      ((uint32_t)0x0000FFFF)
N#define PORT_PULL_UP_Msk                        ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PULL */
N
N/** @defgroup Periph_PORT_PD	PORT PD
N  * @{
N  */ 
N
N/*-- PORT_PD: PORT Driver Mode Register ----------------------------*/
N/* Bit field positions: */
N#define PORT_PD_Pos                             0
N#define PORT_PD_SHM_Pos                         16
N
N/* Bit field masks: */
N#define PORT_PD_Msk                             ((uint32_t)0x0000FFFF)
N#define PORT_PD_SHM_Msk                         ((uint32_t)0xFFFF0000)
N
N/** @} */ /* End of group PORT_PD */
N
N/** @defgroup Periph_PORT_PWR	PORT PWR
N  * @{
N  */ 
N
N/*-- PORT_PWR: PORT Power Register ---------------------------------*/
N/* Bit field positions: */
N#define PORT_PWR0_Pos                           0
N#define PORT_PWR1_Pos                           2
N#define PORT_PWR2_Pos                           4
N#define PORT_PWR3_Pos                           6
N#define PORT_PWR4_Pos                           8
N#define PORT_PWR5_Pos                           10
N#define PORT_PWR6_Pos                           12
N#define PORT_PWR7_Pos                           14
N#define PORT_PWR8_Pos                           16
N#define PORT_PWR9_Pos                           18
N#define PORT_PWR10_Pos                          20
N#define PORT_PWR11_Pos                          22
N#define PORT_PWR12_Pos                          24
N#define PORT_PWR13_Pos                          26
N#define PORT_PWR14_Pos                          28
N#define PORT_PWR15_Pos                          30
N
N/* Bit field masks: */
N#define PORT_PWR0_Msk                           ((uint32_t)0x00000003)
N#define PORT_PWR1_Msk                           ((uint32_t)0x0000000C)
N#define PORT_PWR2_Msk                           ((uint32_t)0x00000030)
N#define PORT_PWR3_Msk                           ((uint32_t)0x000000C0)
N#define PORT_PWR4_Msk                           ((uint32_t)0x00000300)
N#define PORT_PWR5_Msk                           ((uint32_t)0x00000C00)
N#define PORT_PWR6_Msk                           ((uint32_t)0x00003000)
N#define PORT_PWR7_Msk                           ((uint32_t)0x0000C000)
N#define PORT_PWR8_Msk                           ((uint32_t)0x00030000)
N#define PORT_PWR9_Msk                           ((uint32_t)0x000C0000)
N#define PORT_PWR10_Msk                          ((uint32_t)0x00300000)
N#define PORT_PWR11_Msk                          ((uint32_t)0x00C00000)
N#define PORT_PWR12_Msk                          ((uint32_t)0x03000000)
N#define PORT_PWR13_Msk                          ((uint32_t)0x0C000000)
N#define PORT_PWR14_Msk                          ((uint32_t)0x30000000)
N#define PORT_PWR15_Msk                          ((uint32_t)0xC0000000)
N
N/** @} */ /* End of group PORT_PWR */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_PORT */
N
N/** @defgroup MDR32Fx_Periph_BKP BKP
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_BKP_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_BKP_TypeDef structure */
Ntypedef struct
N{
N  __IO uint32_t REG_00;
X  volatile uint32_t REG_00;
N  __IO uint32_t REG_01;
X  volatile uint32_t REG_01;
N  __IO uint32_t REG_02;
X  volatile uint32_t REG_02;
N  __IO uint32_t REG_03;
X  volatile uint32_t REG_03;
N  __IO uint32_t REG_04;
X  volatile uint32_t REG_04;
N  __IO uint32_t REG_05;
X  volatile uint32_t REG_05;
N  __IO uint32_t REG_06;
X  volatile uint32_t REG_06;
N  __IO uint32_t REG_07;
X  volatile uint32_t REG_07;
N  __IO uint32_t REG_08;
X  volatile uint32_t REG_08;
N  __IO uint32_t REG_09;
X  volatile uint32_t REG_09;
N  __IO uint32_t REG_0A;
X  volatile uint32_t REG_0A;
N  __IO uint32_t REG_0B;
X  volatile uint32_t REG_0B;
N  __IO uint32_t REG_0C;
X  volatile uint32_t REG_0C;
N  __IO uint32_t REG_0D;
X  volatile uint32_t REG_0D;
N  __IO uint32_t REG_0E;
X  volatile uint32_t REG_0E;
N  __IO uint32_t REG_0F;
X  volatile uint32_t REG_0F;
N  __IO uint32_t RTC_CNT;
X  volatile uint32_t RTC_CNT;
N  __IO uint32_t RTC_DIV;
X  volatile uint32_t RTC_DIV;
N  __IO uint32_t RTC_PRL;
X  volatile uint32_t RTC_PRL;
N  __IO uint32_t RTC_ALRM;
X  volatile uint32_t RTC_ALRM;
N  __IO uint32_t RTC_CS;
X  volatile uint32_t RTC_CS;
N}MDR_BKP_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_BKP_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_BKP_REG_0E	BKP REG 0E
N  * @{
N  */ 
N
N/*-- BKP_REG_0E: Backup Register 14 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0E_LOW_Pos                      0
N#define BKP_REG_0E_SELECTRI_Pos                 3
N#define BKP_REG_0E_JTAGA_Pos                    6
N#define BKP_REG_0E_JTAGB_Pos                    7
N#define BKP_REG_0E_TRIM_Pos                     8
N#define BKP_REG_0E_FPOR_Pos                     11
N#define BKP_REG_0E_BKP_REG_Pos                  12
N
N/* Bit field masks: */
N#define BKP_REG_0E_LOW_Msk                      ((uint32_t)0x00000007)
N#define BKP_REG_0E_SELECTRI_Msk                 ((uint32_t)0x00000038)
N#define BKP_REG_0E_JTAGA                        ((uint32_t)0x00000040)
N#define BKP_REG_0E_JTAGB                        ((uint32_t)0x00000080)
N#define BKP_REG_0E_TRIM_Msk                     ((uint32_t)0x00000700)
N#define BKP_REG_0E_FPOR                         ((uint32_t)0x00000800)
N#define BKP_REG_0E_BKP_REG_Msk                  ((uint32_t)0xFFFFF000)
N
N/** @} */ /* End of group BKP_REG_0E */
N
N/** @defgroup Periph_BKP_REG_0F	BKP REG 0F
N  * @{
N  */ 
N
N/*-- BKP_REG_0F: Backup Register 15 --------------------------------*/
N/* Bit field positions: */
N#define BKP_REG_0F_LSE_ON_Pos                   0
N#define BKP_REG_0F_LSE_BYP_Pos                  1
N#define BKP_REG_0F_RTC_SEL_Pos                  2
N#define BKP_REG_0F_RTC_EN_Pos                   4
N#define BKP_REG_0F_CAL_Pos                      5
N#define BKP_REG_0F_LSE_RDY_Pos                  13
N#define BKP_REG_0F_BKP_REG_Pos                  14
N#define BKP_REG_0F_LSI_ON_Pos                   15
N#define BKP_REG_0F_LSI_TRIM_Pos                 16
N#define BKP_REG_0F_LSI_RDY_Pos                  21
N#define BKP_REG_0F_HSI_ON_Pos                   22
N#define BKP_REG_0F_HSI_RDY_Pos                  23
N#define BKP_REG_0F_HSI_TRIM_Pos                 24
N#define BKP_REG_0F_STANDBY_Pos                  30
N#define BKP_REG_0F_RTC_RESET_Pos                31
N
N/* Bit field masks: */
N#define BKP_REG_0F_LSE_ON                       ((uint32_t)0x00000001)
N#define BKP_REG_0F_LSE_BYP                      ((uint32_t)0x00000002)
N#define BKP_REG_0F_RTC_SEL_Msk                  ((uint32_t)0x0000000C)
N#define BKP_REG_0F_RTC_EN                       ((uint32_t)0x00000010)
N#define BKP_REG_0F_CAL_Msk                      ((uint32_t)0x00001FE0)
N#define BKP_REG_0F_LSE_RDY                      ((uint32_t)0x00002000)
N#define BKP_REG_0F_BKP_REG                      ((uint32_t)0x00004000)
N#define BKP_REG_0F_LSI_ON                       ((uint32_t)0x00008000)
N#define BKP_REG_0F_LSI_TRIM_Msk                 ((uint32_t)0x001F0000)
N#define BKP_REG_0F_LSI_RDY                      ((uint32_t)0x00200000)
N#define BKP_REG_0F_HSI_ON                       ((uint32_t)0x00400000)
N#define BKP_REG_0F_HSI_RDY                      ((uint32_t)0x00800000)
N#define BKP_REG_0F_HSI_TRIM_Msk                 ((uint32_t)0x3F000000)
N#define BKP_REG_0F_STANDBY                      ((uint32_t)0x40000000)
N#define BKP_REG_0F_RTC_RESET                    ((uint32_t)0x80000000)
N
N/** @} */ /* End of group BKP_REG_0F */
N
N/** @defgroup Periph_BKP_RTC_CS	BKP RTC CS
N  * @{
N  */ 
N
N/*-- BKP_RTC_CS: Backup Realtime clock Register --------------------*/
N/* Bit field positions: */
N#define BKP_RTC_CS_OWF_Pos                      0
N#define BKP_RTC_CS_SECF_Pos                     1
N#define BKP_RTC_CS_ALRF_Pos                     2
N#define BKP_RTC_CS_OWF_IE_Pos                   3
N#define BKP_RTC_CS_SECF_IE_Pos                  4
N#define BKP_RTC_CS_ALRF_IE_Pos                  5
N#define BKP_RTC_CS_WEC_Pos                      6
N
N/* Bit field masks: */
N#define BKP_RTC_CS_OWF                          ((uint32_t)0x00000001)
N#define BKP_RTC_CS_SECF                         ((uint32_t)0x00000002)
N#define BKP_RTC_CS_ALRF                         ((uint32_t)0x00000004)
N#define BKP_RTC_CS_OWF_IE                       ((uint32_t)0x00000008)
N#define BKP_RTC_CS_SECF_IE                      ((uint32_t)0x00000010)
N#define BKP_RTC_CS_ALRF_IE                      ((uint32_t)0x00000020)
N#define BKP_RTC_CS_WEC                          ((uint32_t)0x00000040)
N
N/** @} */ /* End of group BKP_RTC_CS */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_BKP */
N
N/** @defgroup MDR32Fx_Periph_EBC EBC
N  * @{
N  */
N
N/** @defgroup MDR32Fx_Periph_EBC_Data_Structures Data Structures
N  * @{
N  */
N
N/* MDR_EBC_TypeDef structure */
Ntypedef struct
N{
N       uint32_t RESERVED0[20];
N  __IO uint32_t NAND_CYCLES;
X  volatile uint32_t NAND_CYCLES;
N  __IO uint32_t CONTROL;
X  volatile uint32_t CONTROL;
N#if defined (USE_MDR1986VE94)
X#if 0L
S  __IO uint32_t MEM_REGION[4];
N#endif
N}MDR_EBC_TypeDef;
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Data_Structures */
N
N/** @defgroup MDR32Fx_Periph_EBC_Defines Defines
N  * @{
N  */
N
N/** @defgroup Periph_EBC_NAND_CYCLES	EBC NAND CYCLES
N  * @{
N  */ 
N
N/*-- EBC_NAND_CYCLES: EBC NAND Timing Register ---------------------*/
N/* Bit field positions: */
N#define EBC_NAND_CYCLES_TRC_Pos                 0
N#define EBC_NAND_CYCLES_TWC_Pos                 4
N#define EBC_NAND_CYCLES_TREA_Pos                8
N#define EBC_NAND_CYCLES_TWP_Pos                 12
N#define EBC_NAND_CYCLES_TWHR_Pos                16
N#define EBC_NAND_CYCLES_TALEA_Pos               20
N#define EBC_NAND_CYCLES_TRR_Pos                 24
N
N/* Bit field masks: */
N#define EBC_NAND_CYCLES_TRC_Msk                 ((uint32_t)0x0000000F)
N#define EBC_NAND_CYCLES_TWC_Msk                 ((uint32_t)0x000000F0)
N#define EBC_NAND_CYCLES_TREA_Msk                ((uint32_t)0x00000F00)
N#define EBC_NAND_CYCLES_TWP_Msk                 ((uint32_t)0x0000F000)
N#define EBC_NAND_CYCLES_TWHR_Msk                ((uint32_t)0x000F0000)
N#define EBC_NAND_CYCLES_TALEA_Msk               ((uint32_t)0x00F00000)
N#define EBC_NAND_CYCLES_TRR_Msk                 ((uint32_t)0x0F000000)
N
N/** @} */ /* End of group EBC_NAND_CYCLES */
N
N/** @defgroup Periph_EBC_CONTROL	EBC CONTROL
N  * @{
N  */ 
N
N/*-- EBC_CONTROL: EBC Control Register -----------------------------*/
N/* Bit field positions: */
N#define EBC_CONTROL_ROM_Pos                     0
N#define EBC_CONTROL_RAM_Pos                     1
N#define EBC_CONTROL_NAND_Pos                    2
N#define EBC_CONTROL_CPOL_Pos                    3
N#define EBC_CONTROL_BUSY_Pos                    7
N#define EBC_CONTROL_WAIT_STATE_Pos              12
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY_Pos					16
S	#define EBC_CONTROL_FF_RDY_Pos					17
N#endif
N
N/* Bit field masks: */
N#define EBC_CONTROL_ROM                         ((uint32_t)0x00000001)
N#define EBC_CONTROL_RAM                         ((uint32_t)0x00000002)
N#define EBC_CONTROL_NAND                        ((uint32_t)0x00000004)
N#define EBC_CONTROL_CPOL                        ((uint32_t)0x00000008)
N#define EBC_CONTROL_BUSY                        ((uint32_t)0x00000080)
N#define EBC_CONTROL_WAIT_STATE_Msk              ((uint32_t)0x0000F000)
N#if defined (USE_MDR1986VE94)
X#if 0L
S	#define EBC_CONTROL_FS_RDY					((uint32_t)0x00010000)
S	#define EBC_CONTROL_FF_RDY					((uint32_t)0x00020000)
N#endif
N
N
N/** @} */ /* End of group EBC_CONTROL */
N
N#if defined (USE_MDR1986VE94)
X#if 0L
S
S/** @defgroup Periph_EBC_RAM_CYCLESx	EBC RAM CYCLESx
S  * @{
S  */
S
S/*-- EBC_RAM_CYCLESx: Register customization options exchange with RAM -------*/
S/* Bit field positions: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE_Pos			0
S#define EBC_RAM_CYCLES_WS_ACTIVE_Pos			1
S#define EBC_RAM_CYCLES_WS_SETUP_Pos				8
S#define EBC_RAM_CYCLES_WS_HOLD_Pos				11
S#define EBC_RAM_CYCLES_USE_READY_Pos			14
S
S/* Bit field masks: */
S#define EBC_RAM_CYCLES_ENABLE_TUNE				((uint32_t)0x00000001)
S#define EBC_RAM_CYCLES_WS_ACTIVE_Msk			((uint32_t)0x000000FE)
S#define EBC_RAM_CYCLES_WS_SETUP_Msk				((uint32_t)0x00000700)
S#define EBC_RAM_CYCLES_WS_HOLD_Msk				((uint32_t)0x00003200)
S#define EBC_RAM_CYCLES_USE_READY				((uint32_t)0x00004000)
S
S/** @} */ /* End of group EBC_RAM_CYCLESx */
N#endif
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC_Defines */
N
N/** @} */ /* End of group MDR32Fx_Periph_EBC */
N
N/** @} */ /* End of group __MDR32Fx_Peripheral_Units */
N
N
N/** @defgroup __Peripheral_Memory_Map Peripheral Memory Map
N  * @{
N  */
N
N#define MDR_CAN1_BASE       (0x40000000)
N#define MDR_CAN2_BASE       (0x40008000)
N#define MDR_USB_BASE        (0x40010000)
N#define MDR_EEPROM_BASE     (0x40018000)
N#define MDR_RST_CLK_BASE    (0x40020000)
N#define MDR_DMA_BASE        (0x40028000)
N#define MDR_UART1_BASE      (0x40030000)
N#define MDR_UART2_BASE      (0x40038000)
N#define MDR_SSP1_BASE       (0x40040000)
N#define MDR_I2C_BASE        (0x40050000)
N#define MDR_POWER_BASE      (0x40058000)
N#define MDR_WWDG_BASE       (0x40060000)
N#define MDR_IWDG_BASE       (0x40068000)
N#define MDR_TIMER1_BASE     (0x40070000)
N#define MDR_TIMER2_BASE     (0x40078000)
N#define MDR_TIMER3_BASE     (0x40080000)
N#define MDR_ADC_BASE        (0x40088000)
N#define MDR_DAC_BASE        (0x40090000)
N#define MDR_COMP_BASE       (0x40098000)
N#define MDR_SSP2_BASE       (0x400A0000)
N#define MDR_PORTA_BASE      (0x400A8000)
N#define MDR_PORTB_BASE      (0x400B0000)
N#define MDR_PORTC_BASE      (0x400B8000)
N#define MDR_PORTD_BASE      (0x400C0000)
N#define MDR_PORTE_BASE      (0x400C8000)
N#define MDR_BKP_BASE        (0x400D8000)
N#define MDR_PORTF_BASE      (0x400E8000)
N#define MDR_EBC_BASE        (0x400F0000)
N
N/** @} */ /* End of group __Peripheral_Memory_Map */
N
N/** @defgroup __Peripheral_declaration Peripheral declaration
N  * @{
N  */
N
N#define MDR_CAN1            ((MDR_CAN_TypeDef     *) MDR_CAN1_BASE)
N#define MDR_CAN2            ((MDR_CAN_TypeDef     *) MDR_CAN2_BASE)
N#define MDR_USB             ((MDR_USB_TypeDef     *) MDR_USB_BASE)
N#define MDR_EEPROM          ((MDR_EEPROM_TypeDef  *) MDR_EEPROM_BASE)
N#define MDR_RST_CLK         ((MDR_RST_CLK_TypeDef *) MDR_RST_CLK_BASE)
N#define MDR_DMA             ((MDR_DMA_TypeDef     *) MDR_DMA_BASE)
N#define MDR_UART1           ((MDR_UART_TypeDef    *) MDR_UART1_BASE)
N#define MDR_UART2           ((MDR_UART_TypeDef    *) MDR_UART2_BASE)
N#define MDR_SSP1            ((MDR_SSP_TypeDef     *) MDR_SSP1_BASE)
N#define MDR_I2C             ((MDR_I2C_TypeDef     *) MDR_I2C_BASE)
N#define MDR_POWER           ((MDR_POWER_TypeDef   *) MDR_POWER_BASE)
N#define MDR_WWDG            ((MDR_WWDG_TypeDef    *) MDR_WWDG_BASE)
N#define MDR_IWDG            ((MDR_IWDG_TypeDef    *) MDR_IWDG_BASE)
N#define MDR_TIMER1          ((MDR_TIMER_TypeDef   *) MDR_TIMER1_BASE)
N#define MDR_TIMER2          ((MDR_TIMER_TypeDef   *) MDR_TIMER2_BASE)
N#define MDR_TIMER3          ((MDR_TIMER_TypeDef   *) MDR_TIMER3_BASE)
N#define MDR_ADC             ((MDR_ADC_TypeDef     *) MDR_ADC_BASE)
N#define MDR_DAC             ((MDR_DAC_TypeDef     *) MDR_DAC_BASE)
N#define MDR_COMP            ((MDR_COMP_TypeDef    *) MDR_COMP_BASE)
N#define MDR_SSP2            ((MDR_SSP_TypeDef     *) MDR_SSP2_BASE)
N#define MDR_PORTA           ((MDR_PORT_TypeDef    *) MDR_PORTA_BASE)
N#define MDR_PORTB           ((MDR_PORT_TypeDef    *) MDR_PORTB_BASE)
N#define MDR_PORTC           ((MDR_PORT_TypeDef    *) MDR_PORTC_BASE)
N#define MDR_PORTD           ((MDR_PORT_TypeDef    *) MDR_PORTD_BASE)
N#define MDR_PORTE           ((MDR_PORT_TypeDef    *) MDR_PORTE_BASE)
N#define MDR_BKP             ((MDR_BKP_TypeDef     *) MDR_BKP_BASE)
N#define MDR_PORTF           ((MDR_PORT_TypeDef    *) MDR_PORTF_BASE)
N#define MDR_EBC             ((MDR_EBC_TypeDef     *) MDR_EBC_BASE)
N
N/** @} */ /* End of group __Peripheral_declaration */
N
N#ifdef __cplusplus
S}
N#endif
N
N/** @} */ /* End of group __MDR32Fx_Peripheral */
N
N/** @} */ /* End of group MDR1986VE9x */
N
N/** @} */ /* End of group __CMSIS */
N
N#endif /* __MDR32FX_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32Fx.h */
L 66 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config\MDR32F9Qx_config.h" 2
N#elif defined (USE_MDR1986VE1T)
S	#include "MDR1986VE1T.h"
S#elif defined ( USE_MDR1986VE3 )
S	#include "MDR1986VE3.h"
S#elif defined (USE_MDR1986BE4)
S	#include "MDR1986BE4.h"
N#endif
N
N/* Uncomment the line(s) below to define used JTAG port(s). Leave all commented
N * if there is no JTAG ports */
N#if (((!defined(USE_MDR1986VE3)) || (!defined(USE_MDR1986VE1T))) && (defined(USE_MDR1986VE9x)))
X#if (((!0L) || (!0L)) && (1L))
N/* #define USE_JTAG_A */
N #define USE_JTAG_B 
N#endif
N
N/* Target system parameters */
N/* RST_CLK generators frequencies in HZ */
N#define HSI_Value       ((uint32_t)8000000)
N#define HSE_Value       ((uint32_t)16000000)
N#define HSE2_Value      ((uint32_t)25000000)
N#define LSI_Value       ((uint32_t)40000)
N#define LSE_Value       ((uint32_t)32768)
N
N/* RST_CLK frequencies startup timeouts settings */
N#define HSEonTimeOut    ((uint16_t)0x0600)
N#define HSE2onTimeOut	((uint16_t)0x8000)
N#define LSEonTimeOut    ((uint16_t)0x0600)
N#define HSIonTimeOut    ((uint16_t)0x0600)
N#define LSIonTimeOut    ((uint16_t)0x0600)
N#define PLLCPUonTimeOut ((uint16_t)0x0600)
N#define PLLUSBonTimeOut ((uint16_t)0x0600)
N
N#define FLASH_PROG_FREQ_MHZ     (8.0)
N/* Use debug uart */
N//#define _USE_DEBUG_UART_
N
N#if defined (_USE_DEBUG_UART_)
X#if 0L
S
S#if defined (USE_MDR1986VE3)
S	#define DEBUG_UART 					MDR_UART2
S	#define DEBUG_UART_PORT				MDR_PORTD
S	#define DEBUG_UART_PINS				(PORT_Pin_13 | PORT_Pin_14)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1986VE1T)
S	#define DEBUG_UART 					MDR_UART1
S	#define DEBUG_UART_PORT				MDR_PORTC
S	#define DEBUG_UART_PINS				(PORT_Pin_3 | PORT_Pin_4)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_MAIN
S	#define DEBUG_BAUD_RATE				115200
S#elif defined (USE_MDR1986VE9x)
S	#define DEBUG_UART 					MDR_UART2
S	#define DEBUG_UART_PORT				MDR_PORTF
S	#define DEBUG_UART_PINS				(PORT_Pin_0 | PORT_Pin_1)
S	#define DEBUG_UART_PINS_FUNCTION	PORT_FUNC_OVERRID
S	#define DEBUG_BAUD_RATE				115200
S#endif
S
S//#define PRINTF_FORMAT_FULL
S//#define PRINTF_FORMAT_LARGE
S
N#endif /* #if defined (_USE_DEBUG_UART_) */
N
N#if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
X#if 0L || 0L
S	#define MIL_STD_1553_TERMINAL_ADDRESS	0x01
N#endif /* #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T ) */
N
N/* RTC configuration parameters */
N#define RTC_CalibratorValue   	0
N#define RTC_PRESCALER_VALUE		32768
N
N/* DMA configuration parameters */
N/* Number of DMA channels to use */
N#define DMA_Channels_Number   32          /* This parameter is in range 1..32 */
N
N/* Alternate Control Data Structure Usage */
N/* This parameter can be a value of:
N    0 = DMA_ALternateDataDisabled;
N    1 = DMA_ALternateDataEnabled; */
N/*#define DMA_AlternateData   0 */          /* DMA_AlternateDataDisabled */
N#define DMA_AlternateData   1             /* DMA_AlternateDataEnabled */
N
N/* USB configuration parameters ----------------------------------------------*/
N/* Uncomment one of the lines below to select the Device Class. Leave all commented
N * if the desired device class is not currently supported by USB library */
N#define USB_DEVICE_CLASS  USB_DEVICE_CLASS_CDC
N
N/* USB Device management */
N/* Uncomment the line below to enable appropriate functionality. */
N/* #define USB_REMOTE_WAKEUP_SUPPORTED */
N/* #define USB_SELF_POWERED_SUPPORTED */
N
N/* Uncomment the line below to let the library provide USB interrupt handler.
N * Leave this line commented if you are willing to implement the handler yourself. */
N#define USB_INT_HANDLE_REQUIRED
N
N/* USB CDC management */
N/* Uncomment the lines below to enable appropriate functionality. */
N/* #define USB_CDC_STATE_REPORTING_SUPPORTED 	*/
N/* #define USB_CDC_ENCAPSULATION_SUPPORTED 	*/
N/* #define USB_CDC_COMM_FEATURE_SUPPORTED 	*/
N#define USB_CDC_LINE_CODING_SUPPORTED 	
N/* #define USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
N/* #define USB_CDC_LINE_BREAK_SUPPORTED 	*/
N
N/* VCOM Echo example flags */
N
N/* Uncomment USB_VCOM_SYNC to enable "reliable delivery" mode: no new data
N * would be received (EP3 will reply NAK) until all previous data is sent
N * to host. */
N//#define USB_VCOM_SYNC
N
N/* Uncomment USB_DEBUG_PROTO to utilize the ring buffer for received setup
N * packets and send/receive byte counters (for debug purposes). */
N//#define USB_DEBUG_PROTO
N
N/* Known errors workaround control -------------------------------------------*/
N/* MDR32F9Qx Series Errata Notice, Error 0002 */
N#define WORKAROUND_MDR32F9QX_ERROR_0002
N
N/* Parameter run-time check support ------------------------------------------*/
N
N/* Select one of the following values of USE_ASSERT_INFO macro to control
N   parameter checking in the Standard Peripheral Library drivers:
N     0 - no parameter checks ("assert_param" macro is disabled);
N     1 - check enabled, source file ID and line number are available;
N     2 - check enabled, source file ID, line number and checking expression
N         (as string) are available (increased code size).
N*/
N #define USE_ASSERT_INFO    0
N/* #define USE_ASSERT_INFO    1 */
N/* #define USE_ASSERT_INFO    2 */
N
N/**
N  * @brief  The assert_param macro is used for function's parameters check.
N  * @param  expr: If expr is false, it calls assert_failed user's function
N  *   which gets the source file ID (see MDR32F9Qx_lib.h), line number and
N  *   expression text (if USE_ASSERT_INFO == 2) of the call that failed. That
N  *   function should not return. If expr is true, nothing is done.
N  * @retval None
N  */
N#if (USE_ASSERT_INFO == 0)
X#if (0 == 0)
N  #define assert_param(expr) ((void)0)
N#elif (USE_ASSERT_INFO == 1)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__))
S  void assert_failed(uint32_t file_id, uint32_t line);
S#elif (USE_ASSERT_INFO == 2)
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed(ASSERT_INFO_FILE_ID, __LINE__, #expr))
S  void assert_failed(uint32_t file_id, uint32_t line, const uint8_t* expr);
S#else
S  #error "Unsupported USE_ASSERT_INFO level"
N#endif /* USE_ASSERT_INFO */
N
N#if defined (__ICCARM__)
X#if 0L
S	#define __attribute__(name_section)
S	#if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
S		#pragma section = "EXECUTABLE_MEMORY_SECTION"
S		#define IAR_SECTION(section) @ section
S	#elif defined (USE_MDR1986VE9x)
S		#define IAR_SECTION(section)
S	#endif
N#endif
N#if defined (__CMCARM__)
X#if 0L
S		#define __attribute__(name_section)
S		#define IAR_SECTION(section)
N#endif
N
N#if defined (__CC_ARM)
X#if 1L
N	#define IAR_SECTION(section)
N#endif
N
N#endif /* __MDR32F9Qx_CONFIG_H */
N
N/******************* (C) COPYRIGHT 2011 Milandr *********************************
N*
N* END OF FILE MDR32F9Qx_config.h */
L 34 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_port.h" 2
N#include "MDR32F9Qx_lib.h"
N
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup PORT
N  * @{
N  */
N
N/** @defgroup PORT_Exported_Types PORT Exported Types
N  * @{
N  */
N
N#if defined (USE_MDR1986VE9x) || defined (USE_MDR1986VE1T)
X#if 1L || 0L
N#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) || \
N                                    ((PERIPH) == MDR_PORTB) || \
N                                    ((PERIPH) == MDR_PORTC) || \
N                                    ((PERIPH) == MDR_PORTD) || \
N                                    ((PERIPH) == MDR_PORTE) || \
N                                    ((PERIPH) == MDR_PORTF))
X#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) ||                                     ((PERIPH) == MDR_PORTB) ||                                     ((PERIPH) == MDR_PORTC) ||                                     ((PERIPH) == MDR_PORTD) ||                                     ((PERIPH) == MDR_PORTE) ||                                     ((PERIPH) == MDR_PORTF))
N#endif
N#if defined (USE_MDR1986VE3)
X#if 0L
S#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) || \
S                                    ((PERIPH) == MDR_PORTB) || \
S                                    ((PERIPH) == MDR_PORTC) || \
S                                    ((PERIPH) == MDR_PORTD) || \
S                                    ((PERIPH) == MDR_PORTE) || \
S                                    ((PERIPH) == MDR_PORTF) || \
S                                    ((PERIPH) == MDR_PORTG) || \
S                                    ((PERIPH) == MDR_PORTH) || \
S                                    ((PERIPH) == MDR_PORTI))
X#define IS_PORT_ALL_PERIPH(PERIPH) (((PERIPH) == MDR_PORTA) ||                                     ((PERIPH) == MDR_PORTB) ||                                     ((PERIPH) == MDR_PORTC) ||                                     ((PERIPH) == MDR_PORTD) ||                                     ((PERIPH) == MDR_PORTE) ||                                     ((PERIPH) == MDR_PORTF) ||                                     ((PERIPH) == MDR_PORTG) ||                                     ((PERIPH) == MDR_PORTH) ||                                     ((PERIPH) == MDR_PORTI))
N#endif
N
N/**
N  * @brief  Configuration OE enumeration
N  */
N
Ntypedef enum
N{
N  PORT_OE_IN            = 0x0,
N  PORT_OE_OUT           = 0x1
N}PORT_OE_TypeDef;
N
N#define IS_PORT_OE(OE) (((OE) == PORT_OE_IN) || ((OE) == PORT_OE_OUT))
N
N
N/**
N  * @brief  Configuration Mode enumeration
N  */
N
Ntypedef enum
N{
N  PORT_MODE_ANALOG      = 0x0,
N  PORT_MODE_DIGITAL     = 0x1
N}PORT_MODE_TypeDef;
N
N#define IS_PORT_MODE(MODE) (((MODE) == PORT_MODE_ANALOG) || ((MODE) == PORT_MODE_DIGITAL))
N
N
N/**
N  * @brief  Configuration PULL_UP enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PULL_UP_OFF      = 0x0,
N  PORT_PULL_UP_ON       = 0x1
N}PORT_PULL_UP_TypeDef;
N
N#define IS_PORT_PULL_UP(PULL_UP) (((PULL_UP) == PORT_PULL_UP_OFF) || ((PULL_UP) == PORT_PULL_UP_ON))
N
N
N/**
N  * @brief  Configuration PULL_DOWN enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PULL_DOWN_OFF    = 0x0,
N  PORT_PULL_DOWN_ON     = 0x1
N}PORT_PULL_DOWN_TypeDef;
N
N#define IS_PORT_PULL_DOWN(PULL_DOWN) (((PULL_DOWN) == PORT_PULL_DOWN_ON) || \
N                                      ((PULL_DOWN) == PORT_PULL_DOWN_OFF))
X#define IS_PORT_PULL_DOWN(PULL_DOWN) (((PULL_DOWN) == PORT_PULL_DOWN_ON) ||                                       ((PULL_DOWN) == PORT_PULL_DOWN_OFF))
N
N/**
N  * @brief  Configuration PD_SHM enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PD_SHM_OFF       = 0x0,
N  PORT_PD_SHM_ON        = 0x1
N}PORT_PD_SHM_TypeDef;
N
N#define IS_PORT_PD_SHM(PORT_PD_SHM) (((PORT_PD_SHM) == PORT_PD_SHM_OFF) || \
N                                     ((PORT_PD_SHM) == PORT_PD_SHM_ON))
X#define IS_PORT_PD_SHM(PORT_PD_SHM) (((PORT_PD_SHM) == PORT_PD_SHM_OFF) ||                                      ((PORT_PD_SHM) == PORT_PD_SHM_ON))
N
N
N/**
N  * @brief  Configuration PD_PD enumeration
N  */
N
Ntypedef enum
N{
N  PORT_PD_DRIVER        = 0x0,
N  PORT_PD_OPEN          = 0x1
N}PORT_PD_TypeDef;
N
N#define IS_PORT_PD(PORT_PD) (((PORT_PD) == PORT_PD_DRIVER) || ((PORT_PD) == PORT_PD_OPEN))
N
N/**
N  * @brief  Configuration GFEN enumeration
N  */
N
Ntypedef enum
N{
N  PORT_GFEN_OFF         = 0x0,
N  PORT_GFEN_ON          = 0x1
N}PORT_GFEN_TypeDef;
N
N#define IS_PORT_GFEN(PORT_GFEN) (((PORT_GFEN) == PORT_GFEN_OFF) || ((PORT_GFEN) == PORT_GFEN_ON))
N
N
N/**
N  * @brief  Configuration Function enumeration
N  */
N
Ntypedef enum
N{
N  PORT_FUNC_PORT        = 0x0,
N  PORT_FUNC_MAIN        = 0x1,
N  PORT_FUNC_ALTER       = 0x2,
N  PORT_FUNC_OVERRID     = 0x3
N}PORT_FUNC_TypeDef;
N
N#define IS_PORT_FUNC(FUNC) (((FUNC) == PORT_FUNC_PORT)  || ((FUNC) == PORT_FUNC_MAIN) || \
N                            ((FUNC) == PORT_FUNC_ALTER) || ((FUNC) == PORT_FUNC_OVERRID))
X#define IS_PORT_FUNC(FUNC) (((FUNC) == PORT_FUNC_PORT)  || ((FUNC) == PORT_FUNC_MAIN) ||                             ((FUNC) == PORT_FUNC_ALTER) || ((FUNC) == PORT_FUNC_OVERRID))
N
N/**
N  * @brief  Configuration Speed enumeration
N  */
N
Ntypedef enum
N{
N  PORT_OUTPUT_OFF       = 0x0,
N  PORT_SPEED_SLOW       = 0x1,
N  PORT_SPEED_FAST       = 0x2,
N  PORT_SPEED_MAXFAST    = 0x3
N}PORT_SPEED_TypeDef;
N
N#define IS_PORT_SPEED(SPEED) (((SPEED) == PORT_OUTPUT_OFF) || ((SPEED) == PORT_SPEED_SLOW) || \
N                              ((SPEED) == PORT_SPEED_FAST) || ((SPEED) == PORT_SPEED_MAXFAST))
X#define IS_PORT_SPEED(SPEED) (((SPEED) == PORT_OUTPUT_OFF) || ((SPEED) == PORT_SPEED_SLOW) ||                               ((SPEED) == PORT_SPEED_FAST) || ((SPEED) == PORT_SPEED_MAXFAST))
N
N
N/**
N  * @brief  PORT Init structure definition
N  */
N
Ntypedef struct
N{
N  uint16_t PORT_Pin;                     /*!< Specifies PORT pins to be configured.
N                                              This parameter is a mask of @ref PORT_pins_define values. */
N  PORT_OE_TypeDef PORT_OE;               /*!< Specifies in/out mode for the selected pins.
N                                              This parameter is one of @ref PORT_OE_TypeDef values. */
N  PORT_PULL_UP_TypeDef PORT_PULL_UP;     /*!< Specifies pull up state for the selected pins.
N                                              This parameter is one of @ref PORT_PULL_UP_TypeDef values. */
N  PORT_PULL_DOWN_TypeDef PORT_PULL_DOWN; /*!< Specifies pull down state for the selected pins.
N                                              This parameter is one of @ref PORT_PULL_DOWN_TypeDef values. */
N  PORT_PD_SHM_TypeDef PORT_PD_SHM;       /*!< Specifies SHM state for the selected pins.
N                                              This parameter is one of @ref PORT_PD_SHM_TypeDef values. */
N  PORT_PD_TypeDef PORT_PD;               /*!< Specifies PD state for the selected pins.
N                                              This parameter is one of @ref PORT_PD_TypeDef values. */
N  PORT_GFEN_TypeDef PORT_GFEN;           /*!< Specifies GFEN state for the selected pins.
N                                              This parameter is one of @ref PORT_GFEN_TypeDef values. */
N  PORT_FUNC_TypeDef PORT_FUNC;           /*!< Specifies operating function for the selected pins.
N                                              This parameter is one of @ref PORT_FUNC_TypeDef values. */
N  PORT_SPEED_TypeDef PORT_SPEED;         /*!< Specifies the speed for the selected pins.
N                                              This parameter is one of @ref PORT_SPEED_TypeDef values. */
N  PORT_MODE_TypeDef PORT_MODE;           /*!< Specifies the operating mode for the selected pins.
N                                              This parameter is one of @ref PORT_MODE_TypeDef values. */
N}PORT_InitTypeDef;
N
N
N/**
N  * @brief  Bit_SET and Bit_RESET enumeration
N  */
N
Ntypedef enum
N{
N  Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N
N#define IS_PORT_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N
N/** @} */ /* End of group PORT_Exported_Types */
N
N/** @defgroup PORT_Exported_Constants PORT Exported Constants
N  * @{
N  */
N
N/** @defgroup PORT_JTAG_define PORT JTAG define
N  * @{
N  */
N
N#if defined (USE_JTAG_A)
X#if 0L
S#define PORT_JTAG                   MDR_PORTB    /*!< Port containing JTAG interface */
S#define PORT_JTAG_Msk               0x001FU      /*!< JTAG pins */
S
N#elif defined (USE_JTAG_B)
X#elif 1L
N#define PORT_JTAG                   MDR_PORTD    /*!< Port containing JTAG interface */
N#define PORT_JTAG_Msk               0x001FU      /*!< JTAG pins */
N
N#endif
N
N#if defined (PORT_JTAG)
X#if 1L
N#define JTAG_PINS(PORT)             (((PORT) == PORT_JTAG) ? PORT_JTAG_Msk : 0)
N
N#else
S#define JTAG_PINS(PORT)             0
S
N#endif
N
N#define IS_NOT_JTAG_PIN(PORT, PIN)  (((PIN) & JTAG_PINS(PORT)) == 0x00)
N
N
N/** @} */ /* End of group PORT_JTAG_define */
N
N/** @defgroup PORT_pins_define PORT pins define
N  * @{
N  */
N
N#define PORT_Pin_0                  0x0001U  /*!< Pin 0 selected */
N#define PORT_Pin_1                  0x0002U  /*!< Pin 1 selected */
N#define PORT_Pin_2                  0x0004U  /*!< Pin 2 selected */
N#define PORT_Pin_3                  0x0008U  /*!< Pin 3 selected */
N#define PORT_Pin_4                  0x0010U  /*!< Pin 4 selected */
N#define PORT_Pin_5                  0x0020U  /*!< Pin 5 selected */
N#define PORT_Pin_6                  0x0040U  /*!< Pin 6 selected */
N#define PORT_Pin_7                  0x0080U  /*!< Pin 7 selected */
N#define PORT_Pin_8                  0x0100U  /*!< Pin 8 selected */
N#define PORT_Pin_9                  0x0200U  /*!< Pin 9 selected */
N#define PORT_Pin_10                 0x0400U  /*!< Pin 10 selected */
N#define PORT_Pin_11                 0x0800U  /*!< Pin 11 selected */
N#define PORT_Pin_12                 0x1000U  /*!< Pin 12 selected */
N#define PORT_Pin_13                 0x2000U  /*!< Pin 13 selected */
N#define PORT_Pin_14                 0x4000U  /*!< Pin 14 selected */
N#define PORT_Pin_15                 0x8000U  /*!< Pin 15 selected */
N#define PORT_Pin_All                0xFFFFU  /*!< All pins selected */
N
N#define IS_PORT_PIN(PIN)            ((((PIN) & (uint32_t)0xFFFF0000UL) == 0x00) && \
N                                     ((PIN) != 0x00))
X#define IS_PORT_PIN(PIN)            ((((PIN) & (uint32_t)0xFFFF0000UL) == 0x00) &&                                      ((PIN) != 0x00))
N
N#define IS_GET_PORT_PIN(PIN)        (((PIN) == PORT_Pin_0 ) || \
N                                     ((PIN) == PORT_Pin_1 ) || \
N                                     ((PIN) == PORT_Pin_2 ) || \
N                                     ((PIN) == PORT_Pin_3 ) || \
N                                     ((PIN) == PORT_Pin_4 ) || \
N                                     ((PIN) == PORT_Pin_5 ) || \
N                                     ((PIN) == PORT_Pin_6 ) || \
N                                     ((PIN) == PORT_Pin_7 ) || \
N                                     ((PIN) == PORT_Pin_8 ) || \
N                                     ((PIN) == PORT_Pin_9 ) || \
N                                     ((PIN) == PORT_Pin_10) || \
N                                     ((PIN) == PORT_Pin_11) || \
N                                     ((PIN) == PORT_Pin_12) || \
N                                     ((PIN) == PORT_Pin_13) || \
N                                     ((PIN) == PORT_Pin_14) || \
N                                     ((PIN) == PORT_Pin_15))
X#define IS_GET_PORT_PIN(PIN)        (((PIN) == PORT_Pin_0 ) ||                                      ((PIN) == PORT_Pin_1 ) ||                                      ((PIN) == PORT_Pin_2 ) ||                                      ((PIN) == PORT_Pin_3 ) ||                                      ((PIN) == PORT_Pin_4 ) ||                                      ((PIN) == PORT_Pin_5 ) ||                                      ((PIN) == PORT_Pin_6 ) ||                                      ((PIN) == PORT_Pin_7 ) ||                                      ((PIN) == PORT_Pin_8 ) ||                                      ((PIN) == PORT_Pin_9 ) ||                                      ((PIN) == PORT_Pin_10) ||                                      ((PIN) == PORT_Pin_11) ||                                      ((PIN) == PORT_Pin_12) ||                                      ((PIN) == PORT_Pin_13) ||                                      ((PIN) == PORT_Pin_14) ||                                      ((PIN) == PORT_Pin_15))
N
N/** @} */ /* End of group PORT_pins_define */
N
N/** @} */ /* End of group PORT_Exported_Constants */
N
N/** @defgroup PORT_Exported_Macros PORT Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group PORT_Exported_Macros */
N
N/** @defgroup PORT_Exported_Functions PORT Exported Functions
N  * @{
N  */
N
Nvoid PORT_DeInit(MDR_PORT_TypeDef* PORTx);
Nvoid PORT_Init(MDR_PORT_TypeDef* PORTx, const PORT_InitTypeDef* PORT_InitStruct);
Nvoid PORT_StructInit(PORT_InitTypeDef* PORT_InitStruct);
N
Nuint8_t PORT_ReadInputDataBit(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin);
Nuint32_t PORT_ReadInputData(MDR_PORT_TypeDef* PORTx);
N
Nvoid PORT_SetBits(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin);
Nvoid PORT_ResetBits(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin);
Nvoid PORT_WriteBit(MDR_PORT_TypeDef* PORTx, uint32_t PORT_Pin, BitAction BitVal);
Nvoid PORT_Write(MDR_PORT_TypeDef* PORTx, uint32_t PortVal);
N
N/** @} */ /* End of group PORT_Exported_Functions */
N
N/** @} */ /* End of group PORT */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_PORT_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32F9Qx_port.h */
L 2 "main.c" 2
N#include <MDR32Fx.h>
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_uart.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_uart.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_uart.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    27/04/2010
N  * @brief   This file contains all the functions prototypes for the UART
N  *          firmware library.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_uart.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_UART_H
N#define __MDR32F9Qx_UART_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_config.h"
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup UART
N  * @{
N  */
N
N/** @defgroup UART_Exported_Types UART Exported Types
N  * @{
N  */
N
Ntypedef enum {BaudRateInvalid = 0, BaudRateValid = !BaudRateInvalid} BaudRateStatus;
N
N/**
N  * @brief  UART Init Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t UART_BaudRate;            /*!< This member configures the UART communication baud rate.
N                                          The baud rate is computed using the following formula:
N                                           - IntegerDivider = ((UARTCLK) / (16 * (UART_InitStruct->UART_BaudRate)))
N                                           - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 64) + 0.5 */
N  uint16_t UART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
N                                          This parameter is one of @ref UART_Word_Length values. */
N  uint16_t UART_StopBits;            /*!< Specifies the number of stop bits transmitted.
N                                          This parameter is one of @ref UART_Stop_Bits values. */
N  uint16_t UART_Parity;              /*!< Specifies the parity mode.
N                                          This parameter is one of @ref UART_Parity values. */
N  uint16_t UART_FIFOMode;            /*!< Specifies the FIFO mode.
N                                          This parameter is one of @ref UART_FIFO_Mode values. */
N  uint16_t UART_HardwareFlowControl; /*!< Specifies whether the hardware flow control mode is enabled or disabled.
N                                          This parameter is one of @ref UART_Hardware_Flow_Control values. */
N}UART_InitTypeDef;
N
N/** @} */ /* End of group UART_Exported_Types */
N
N
N/** @defgroup UART_Exported_Constants UART Exported Constants
N  * @{
N  */
N
N#if defined (USE_MDR1986VE9x) || defined(USE_MDR1986VE1T)
X#if 1L || 0L
N
N#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) || \
N                                             ((PERIPH) == MDR_UART2))
X#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) ||                                              ((PERIPH) == MDR_UART2))
N#elif defined (USE_MDR1986VE3)
S
S#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) || \
S                                            ((PERIPH) == MDR_UART2) || \
S                                            ((PERIPH) == MDR_UART3) || \
S                                            ((PERIPH) == MDR_UART4))
X#define IS_UART_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_UART1) ||                                             ((PERIPH) == MDR_UART2) ||                                             ((PERIPH) == MDR_UART3) ||                                             ((PERIPH) == MDR_UART4))
N#endif
N
N/** @defgroup UART_Word_Length UART Word Length
N  * @{
N  */
N
N#define UART_WordLength5b                   ((uint16_t)0x0000)
N#define UART_WordLength6b                   ((uint16_t)0x0020)
N#define UART_WordLength7b                   ((uint16_t)0x0040)
N#define UART_WordLength8b                   ((uint16_t)0x0060)
N
N#define IS_UART_WORD_LENGTH(LENGTH)         (((LENGTH) == UART_WordLength5b) || \
N                                             ((LENGTH) == UART_WordLength6b) || \
N                                             ((LENGTH) == UART_WordLength7b) || \
N                                             ((LENGTH) == UART_WordLength8b))
X#define IS_UART_WORD_LENGTH(LENGTH)         (((LENGTH) == UART_WordLength5b) ||                                              ((LENGTH) == UART_WordLength6b) ||                                              ((LENGTH) == UART_WordLength7b) ||                                              ((LENGTH) == UART_WordLength8b))
N
N/** @} */ /* End of group UART_Word_Length */
N
N/** @defgroup UART_Stop_Bits UART Stop Bits
N  * @{
N  */
N
N#define UART_StopBits1                      ((uint16_t)0x0000)
N#define UART_StopBits2                      ((uint16_t)0x0008)
N
N#define IS_UART_STOPBITS(STOPBITS)          (((STOPBITS) == UART_StopBits1) || \
N                                             ((STOPBITS) == UART_StopBits2))
X#define IS_UART_STOPBITS(STOPBITS)          (((STOPBITS) == UART_StopBits1) ||                                              ((STOPBITS) == UART_StopBits2))
N
N/** @} */ /* End of group UART_Stop_Bits */
N
N/** @defgroup UART_Parity UART Parity
N  * @{
N  */
N
N#define UART_Parity_No                      ((uint16_t)0x0000)
N#define UART_Parity_Even                    ((uint16_t)0x0006)
N#define UART_Parity_Odd                     ((uint16_t)0x0002)
N#define UART_Parity_1                       ((uint16_t)0x0082)
N#define UART_Parity_0                       ((uint16_t)0x0086)
N
N#define IS_UART_PARITY(PARITY)              (((PARITY) == UART_Parity_No)   || \
N                                             ((PARITY) == UART_Parity_Even) || \
N                                             ((PARITY) == UART_Parity_Odd)  || \
N                                             ((PARITY) == UART_Parity_1)    || \
N                                             ((PARITY) == UART_Parity_0))
X#define IS_UART_PARITY(PARITY)              (((PARITY) == UART_Parity_No)   ||                                              ((PARITY) == UART_Parity_Even) ||                                              ((PARITY) == UART_Parity_Odd)  ||                                              ((PARITY) == UART_Parity_1)    ||                                              ((PARITY) == UART_Parity_0))
N
N/** @} */ /* End of group UART_Parity */
N
N/** @defgroup UART_FIFO_Mode UART FIFO Mode
N  * @{
N  */
N
N#define UART_FIFO_OFF                       ((uint16_t)0x0000)
N#define UART_FIFO_ON                        ((uint16_t)0x0010)
N
N#define IS_UART_FIFOMODE(FIFOMODE)          (((FIFOMODE) == UART_FIFO_ON) || \
N                                             ((FIFOMODE) == UART_FIFO_OFF))
X#define IS_UART_FIFOMODE(FIFOMODE)          (((FIFOMODE) == UART_FIFO_ON) ||                                              ((FIFOMODE) == UART_FIFO_OFF))
N
N/** @} */ /* End of group UART_FIFO_Mode */
N
N/** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
N  * @{
N  */
N#define UART_HardwareFlowControl_None       ((uint16_t)0x0000)
N#define UART_HardwareFlowControl_CTSEn      ((uint16_t)0x8000)
N#define UART_HardwareFlowControl_RTSEn      ((uint16_t)0x4000)
N#define UART_HardwareFlowControl_Out2       ((uint16_t)0x2000)
N#define UART_HardwareFlowControl_Out1       ((uint16_t)0x1000)
N#define UART_HardwareFlowControl_RTS        ((uint16_t)0x0800)
N#define UART_HardwareFlowControl_DTR        ((uint16_t)0x0400)
N#define UART_HardwareFlowControl_RXE        ((uint16_t)0x0200)
N#define UART_HardwareFlowControl_TXE        ((uint16_t)0x0100)
N#define UART_HardwareFlowControl_LBE        ((uint16_t)0x0080)
N
N#define UART_HARDWARE_FLOW_CONTROL_MASK		((uint16_t)0xFF80)
N
N#define IS_UART_HARDWARE_FLOW_CONTROL(CONTROL) 		((CONTROL&(~(UART_HARDWARE_FLOW_CONTROL_MASK))) == 0)
N
N/** @} */ /* End of group UART_Hardware_Flow_Control */
N
N/** @defgroup UART_Interrupt_definition UART Interrupt definition
N  * @{
N  */
N
N#define UART_IT_OE                          ((uint32_t)0x00000400)
N#define UART_IT_BE                          ((uint32_t)0x00000200)
N#define UART_IT_PE                          ((uint32_t)0x00000100)
N#define UART_IT_FE                          ((uint32_t)0x00000080)
N#define UART_IT_RT                          ((uint32_t)0x00000040)
N#define UART_IT_TX                          ((uint32_t)0x00000020)
N#define UART_IT_RX                          ((uint32_t)0x00000010)
N#define UART_IT_DSR                         ((uint32_t)0x00000008)
N#define UART_IT_DCD                         ((uint32_t)0x00000004)
N#define UART_IT_CTS                         ((uint32_t)0x00000002)
N#define UART_IT_RI                          ((uint32_t)0x00000001)
N
N#define IS_UART_CONFIG_IT(IT)               (((IT) == UART_IT_OE)  || ((IT) == UART_IT_BE)  || \
N                                             ((IT) == UART_IT_PE)  || ((IT) == UART_IT_FE)  || \
N                                             ((IT) == UART_IT_RT)  || ((IT) == UART_IT_TX)  || \
N                                             ((IT) == UART_IT_RX)  || ((IT) == UART_IT_DSR) || \
N                                             ((IT) == UART_IT_DCD) || ((IT) == UART_IT_CTS) || \
N                                             ((IT) == UART_IT_RI))
X#define IS_UART_CONFIG_IT(IT)               (((IT) == UART_IT_OE)  || ((IT) == UART_IT_BE)  ||                                              ((IT) == UART_IT_PE)  || ((IT) == UART_IT_FE)  ||                                              ((IT) == UART_IT_RT)  || ((IT) == UART_IT_TX)  ||                                              ((IT) == UART_IT_RX)  || ((IT) == UART_IT_DSR) ||                                              ((IT) == UART_IT_DCD) || ((IT) == UART_IT_CTS) ||                                              ((IT) == UART_IT_RI))
N
N/** @} */ /* End of group UART_Interrupt_definition */
N
N/** @defgroup UART_DMA_interrupt_definition UART DMA interrupt definition
N  * @{
N  */
N
N#define UART_IT_FIFO_LVL_2words             ((uint32_t)0x00000000)
N#define UART_IT_FIFO_LVL_4words             ((uint32_t)0x00000001)
N#define UART_IT_FIFO_LVL_8words             ((uint32_t)0x00000002)
N#define UART_IT_FIFO_LVL_12words            ((uint32_t)0x00000003)
N#define UART_IT_FIFO_LVL_14words            ((uint32_t)0x00000004)
N
N#define IS_UART_IT_FIFO_LVL(IT_FIFO_LVL)    (((IT_FIFO_LVL) == UART_IT_FIFO_LVL_2words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_4words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_8words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_12words) || \
N                                             ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_14words))
X#define IS_UART_IT_FIFO_LVL(IT_FIFO_LVL)    (((IT_FIFO_LVL) == UART_IT_FIFO_LVL_2words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_4words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_8words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_12words) ||                                              ((IT_FIFO_LVL) == UART_IT_FIFO_LVL_14words))
N
N/** @} */ /* End of group UART_DMA_interrupt_definition */
N
N/** @defgroup UART_DMA_request UART DMA request
N  * @{
N  */
N
N#define UART_DMA_RXE                        ((uint32_t)0x00000001)
N#define UART_DMA_TXE                        ((uint32_t)0x00000002)
N#define UART_DMA_ONERR                      ((uint32_t)0x00000004)
N
N#define IS_UART_DMAREQ(DMAREQ)              (((DMAREQ) == UART_DMA_RXE) || \
N                                             ((DMAREQ) == UART_DMA_TXE) || \
N                                             ((DMAREQ) == UART_DMA_ONERR))
X#define IS_UART_DMAREQ(DMAREQ)              (((DMAREQ) == UART_DMA_RXE) ||                                              ((DMAREQ) == UART_DMA_TXE) ||                                              ((DMAREQ) == UART_DMA_ONERR))
N
N/** @} */ /* End of group UART_DMA_request */
N
N/** @defgroup UART_IrDA_Low_Power UART IrDA Low Power
N  * @{
N  */
N
N#define UART_IrDAMode_LowPower              ((uint32_t)0x00000004)
N#define UART_IrDAMode_Normal                ((uint32_t)0x00000000)
N
N#define IS_UART_IRDA_MODE(MODE)             (((MODE) == UART_IrDAMode_LowPower) || \
N                                             ((MODE) == UART_IrDAMode_Normal))
X#define IS_UART_IRDA_MODE(MODE)             (((MODE) == UART_IrDAMode_LowPower) ||                                              ((MODE) == UART_IrDAMode_Normal))
N
N/** @} */ /* End of group UART_IrDA_Low_Power */
N
N/** @defgroup UART_Flags UART Flags
N  * @{
N  */
N
N#define UART_FLAG_RI                        ((uint32_t)0x00000100)
N#define UART_FLAG_TXFE                      ((uint32_t)0x00000080)
N#define UART_FLAG_RXFF                      ((uint32_t)0x00000040)
N#define UART_FLAG_TXFF                      ((uint32_t)0x00000020)
N#define UART_FLAG_RXFE                      ((uint32_t)0x00000010)
N#define UART_FLAG_BUSY                      ((uint32_t)0x00000008)
N#define UART_FLAG_DCD                       ((uint32_t)0x00000004)
N#define UART_FLAG_DSR                       ((uint32_t)0x00000002)
N#define UART_FLAG_CTS                       ((uint32_t)0x00000001)
N
N#define IS_UART_FLAG(FLAG)                  (((FLAG) == UART_FLAG_RI)   || ((FLAG) == UART_FLAG_TXFE) || \
N                                             ((FLAG) == UART_FLAG_RXFF) || ((FLAG) == UART_FLAG_TXFF) || \
N                                             ((FLAG) == UART_FLAG_RXFE) || ((FLAG) == UART_FLAG_BUSY) || \
N                                             ((FLAG) == UART_FLAG_DCD)  || ((FLAG) == UART_FLAG_DSR)  || \
N                                             ((FLAG) == UART_FLAG_CTS))
X#define IS_UART_FLAG(FLAG)                  (((FLAG) == UART_FLAG_RI)   || ((FLAG) == UART_FLAG_TXFE) ||                                              ((FLAG) == UART_FLAG_RXFF) || ((FLAG) == UART_FLAG_TXFF) ||                                              ((FLAG) == UART_FLAG_RXFE) || ((FLAG) == UART_FLAG_BUSY) ||                                              ((FLAG) == UART_FLAG_DCD)  || ((FLAG) == UART_FLAG_DSR)  ||                                              ((FLAG) == UART_FLAG_CTS))
N
N#define IS_UART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) <= 921600))
N
N/** @} */ /* End of group UART_Flags */
N
N/** @defgroup UART_Data_Status UART Data Status
N  * @{
N  */
N
N#define UART_Data_OE                        0x0B
N#define UART_Data_BE                        0x0A
N#define UART_Data_PE                        0x09
N#define UART_Data_FE                        0x08
N
N#define UART_Data_OE_Msk                    ((uint32_t)(1 << UART_Data_OE))
N#define UART_Data_BE_Msk                    ((uint32_t)(1 << UART_Data_BE))
N#define UART_Data_PE_Msk                    ((uint32_t)(1 << UART_Data_FE))
N#define UART_Data_FE_Msk                    ((uint32_t)(1 << UART_Data_PE))
N
N#define UART_Data(DATA)                     ((uint8_t)DATA)
N#define UART_Flags(DATA)                    ((uint8_t)(DATA >> 8))
N#define UART_CheckDataStatus(DATA, BIT)     ((((uint32_t)DATA) << (31 - BIT)) >> 31)
N
N#define IS_UART_DATA(DATA)                  ((DATA) <= 0xFF)
N
N/** @} */ /* End of group UART_Data_Status */
N
N/** @defgroup UART_Clock_BRG UART Clock BRG
N  * @{
N  */
N
N#define UART_HCLKdiv1                       ((uint32_t)0x00000000)
N#define UART_HCLKdiv2                       ((uint32_t)0x00000001)
N#define UART_HCLKdiv4                       ((uint32_t)0x00000002)
N#define UART_HCLKdiv8                       ((uint32_t)0x00000003)
N#define UART_HCLKdiv16                      ((uint32_t)0x00000004)
N#define UART_HCLKdiv32                      ((uint32_t)0x00000005)
N#define UART_HCLKdiv64                      ((uint32_t)0x00000006)
N#define UART_HCLKdiv128                     ((uint32_t)0x00000007)
N
N#define IS_UART_CLOCK_BRG(BRG)              (((BRG) >= 0) && ((BRG) <= 7))
N
N/** @} */ /* End of group UART_Clock_BRG */
N
N/** @} */ /* End of group UART_Exported_Constants */
N
N/** @defgroup UART_Exported_Macros UART Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group UART_Exported_Macros */
N
N/** @defgroup UART_Exported_Functions UART Exported Functions
N  * @{
N  */
N
Nvoid UART_DeInit(MDR_UART_TypeDef* UARTx);
NBaudRateStatus UART_Init(MDR_UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct);
Nvoid UART_StructInit(UART_InitTypeDef* UART_InitStruct);
N
Nvoid UART_Cmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState);
N
Nvoid UART_ITConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT, FunctionalState NewState);
NITStatus UART_GetITStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_IT);
NITStatus UART_GetITStatusMasked(MDR_UART_TypeDef* UARTx, uint32_t UART_IT);
Nvoid UART_ClearITPendingBit(MDR_UART_TypeDef* UARTx, uint32_t UART_IT);
N
Nvoid UART_DMAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT_RB_LVL, uint32_t UART_IT_TB_LVL);
Nvoid UART_DMACmd(MDR_UART_TypeDef* UARTx, uint32_t UART_DMAReq, FunctionalState NewState);
N
Nvoid UART_SendData(MDR_UART_TypeDef* UARTx, uint16_t Data);
Nuint16_t UART_ReceiveData(MDR_UART_TypeDef* UARTx);
Nvoid UART_BreakLine(MDR_UART_TypeDef* UARTx, FunctionalState NewState);
N
Nvoid UART_IrDAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IrDAMode);
Nvoid UART_IrDACmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState);
N
NFlagStatus UART_GetFlagStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_FLAG);
Nvoid UART_BRGInit(MDR_UART_TypeDef* UARTx, uint32_t UART_BRG);
N
N/** @} */ /* End of group UART_Exported_Functions */
N
N/** @} */ /* End of group UART */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_UART_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********
N*
N* END OF FILE MDR32F9Qx_uart.h */
L 5 "main.c" 2
N#include "MDR32F9Qx_rst_clk.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_rst_clk.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_rst_clk.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    23/09/2011
N  * @brief   This file contains all the functions prototypes for the RST_CLK
N  *          firmware library.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_rst_clk.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_RST_CLK_H
N#define __MDR32F9Qx_RST_CLK_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup RST_CLK
N  * @{
N  */
N
N/** @defgroup RST_CLK_Exported_Types RST_CLK Exported Types
N  * @{
N  */
N
N/**
N  * @brief Structure type for modules clocks frequencies expressed in Hz
N  */
N
Ntypedef struct
N{
N  uint32_t CPU_CLK_Frequency;
N  uint32_t USB_CLK_Frequency;
N  uint32_t ADC_CLK_Frequency;
N  uint32_t RTCHSI_Frequency;
N  uint32_t RTCHSE_Frequency;
N}RST_CLK_FreqTypeDef;
N
N/**
N  * @brief RST_CLK unit non-volatile settings init structure
N  */
N
Ntypedef struct {
N     uint32_t REG_0F;
N} Init_NonVolatile_RST_CLK_TypeDef;
N
N/** @} */ /* End of group RST_CLK_Exported_Types */
N
N/** @defgroup RST_CLK_Exported_Constants RST_CLK Exported Constants
N  * @{
N  */
N
N/** @defgroup HSE_configuration HSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE (High Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_HSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_HSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_HSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) || \
N                                              ((HSE) == RST_CLK_HSE_ON)  || \
N                                              ((HSE) == RST_CLK_HSE_Bypass))
X#define IS_RST_CLK_HSE(HSE)                  (((HSE) == RST_CLK_HSE_OFF) ||                                               ((HSE) == RST_CLK_HSE_ON)  ||                                               ((HSE) == RST_CLK_HSE_Bypass))
N
N/** @} */ /* End of group HSE_configuration */
N
N
N#if defined  (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
X#if 0L || 0L
S/** @defgroup HSE2_configuration HSE2 configuration
S *  @{
S */
S
S/**
S  * @brief RST_CLK HSE2 (High Speed External 2 ) clock mode and source selection constants
S  */
S
S#define RST_CLK_HSE2_OFF						((uint32_t)0x00000000)
S#define RST_CLK_HSE2_ON							((uint32_t)0x00000004)
S#define RST_CLK_HSE2_Bypass						((uint32_t)0x00000008)
S
S#define IS_RST_CLK_HSE2(HSE2)                  	(((HSE2) == RST_CLK_HSE2_OFF) || \
S                                              	 ((HSE2) == RST_CLK_HSE2_ON)  || \
S                                              	 ((HSE2) == RST_CLK_HSE2_Bypass))
X#define IS_RST_CLK_HSE2(HSE2)                  	(((HSE2) == RST_CLK_HSE2_OFF) ||                                               	 ((HSE2) == RST_CLK_HSE2_ON)  ||                                               	 ((HSE2) == RST_CLK_HSE2_Bypass))
S
S/** @} */ /* End of group HSE2_configuration */
S
N#endif /* #if defined  (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
N
N/** @defgroup LSE_configuration LSE configuration
N  * @{
N  */
N
N/**
N  * @brief RST_CLK LSE (Low Speed External) clock mode and source selection constants
N  */
N
N#define RST_CLK_LSE_OFF                      ((uint32_t)0x00000000)
N#define RST_CLK_LSE_ON                       ((uint32_t)0x00000001)
N#define RST_CLK_LSE_Bypass                   ((uint32_t)0x00000002)
N
N#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) || \
N                                              ((LSE) == RST_CLK_LSE_ON)  || \
N                                              ((LSE) == RST_CLK_LSE_Bypass))
X#define IS_RST_CLK_LSE(LSE)                  (((LSE) == RST_CLK_LSE_OFF) ||                                               ((LSE) == RST_CLK_LSE_ON)  ||                                               ((LSE) == RST_CLK_LSE_Bypass))
N
N/** @} */ /* End of group LSE_configuration */
N
N/** @defgroup CPU_PLL_entry_clock_source CPU PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_CPU_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) || \
N                                             ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
X#define IS_RST_CLK_CPU_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_CPU_PLLsrcHSIdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSIdiv2) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv1) ||                                              ((SRC) == RST_CLK_CPU_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group CPU_PLL_entry_clock_source */
N
N/** @defgroup CPU_PLL_clock_multiplier CPU_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK PLL_CPU_MUL multiplier of the CPU_C1 clock constants
N  */
N
N#define RST_CLK_CPU_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_CPU_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_CPU_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_CPU_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_CPU_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_CPU_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_CPU_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_CPU_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_CPU_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_CPU_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_CPU_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_CPU_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_CPU_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_CPU_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_CPU_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_CPU_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_CPU_PLL_MUL(SRC)             ((SRC>=0) && (SRC<16))
N
N/** @} */ /* End of group CPU_PLL_clock_multiplier */
N
N
N/** @defgroup USB_PLL_entry_clock_source USB PLL entry clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_PLL clock mode and source selection constants
N  */
N
N#define RST_CLK_USB_PLLsrcHSIdiv1           ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLsrcHSIdiv2           ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLsrcHSEdiv1           ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLsrcHSEdiv2           ((uint32_t)0x00000003)
N
N#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||\
N                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
X#define IS_RST_CLK_USB_PLL_SOURCE(SRC)      (((SRC) == RST_CLK_USB_PLLsrcHSIdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSIdiv2) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv1) ||                                             ((SRC) == RST_CLK_USB_PLLsrcHSEdiv2))
N
N/** @} */ /* End of group USB_PLL_entry_clock_source */
N
N/** @defgroup USB_PLL_clock_multiplier USB_PLL clock multiplier
N  * @{
N  */
N
N/**
N  * @brief RST_CLK USB_C1 clock PLL_USB_MUL multiplier constants
N  */
N
N#define RST_CLK_USB_PLLmul1                     ((uint32_t)0x00000000)
N#define RST_CLK_USB_PLLmul2                     ((uint32_t)0x00000001)
N#define RST_CLK_USB_PLLmul3                     ((uint32_t)0x00000002)
N#define RST_CLK_USB_PLLmul4                     ((uint32_t)0x00000003)
N#define RST_CLK_USB_PLLmul5                     ((uint32_t)0x00000004)
N#define RST_CLK_USB_PLLmul6                     ((uint32_t)0x00000005)
N#define RST_CLK_USB_PLLmul7                     ((uint32_t)0x00000006)
N#define RST_CLK_USB_PLLmul8                     ((uint32_t)0x00000007)
N#define RST_CLK_USB_PLLmul9                     ((uint32_t)0x00000008)
N#define RST_CLK_USB_PLLmul10                    ((uint32_t)0x00000009)
N#define RST_CLK_USB_PLLmul11                    ((uint32_t)0x0000000A)
N#define RST_CLK_USB_PLLmul12                    ((uint32_t)0x0000000B)
N#define RST_CLK_USB_PLLmul13                    ((uint32_t)0x0000000C)
N#define RST_CLK_USB_PLLmul14                    ((uint32_t)0x0000000D)
N#define RST_CLK_USB_PLLmul15                    ((uint32_t)0x0000000E)
N#define RST_CLK_USB_PLLmul16                    ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_USB_PLL_MUL(SRC)             ((SRC>=0) && (SRC<16))
N
N/** @} */ /* End of group USB_PLL_clock_multiplier */
N
N
N/** @defgroup CPU_CLK_divider CPU CLK divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_PLL output clock CPU_CLK_DIV divider constants
N  */
N
N#define RST_CLK_CPUclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_CPUclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_CPUclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_CPUclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_CPUclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_CPUclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_CPUclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_CPUclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV2)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV4)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV8)   || \
N                                               ((DIV) == RST_CLK_CPUclkDIV16)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV32)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV64)  || \
N                                               ((DIV) == RST_CLK_CPUclkDIV128) || \
N                                               ((DIV) == RST_CLK_CPUclkDIV256))
X#define IS_RST_CLK_CPUclkDIV(DIV)             (((DIV) == RST_CLK_CPUclkDIV1)   ||                                                ((DIV) == RST_CLK_CPUclkDIV2)   ||                                                ((DIV) == RST_CLK_CPUclkDIV4)   ||                                                ((DIV) == RST_CLK_CPUclkDIV8)   ||                                                ((DIV) == RST_CLK_CPUclkDIV16)  ||                                                ((DIV) == RST_CLK_CPUclkDIV32)  ||                                                ((DIV) == RST_CLK_CPUclkDIV64)  ||                                                ((DIV) == RST_CLK_CPUclkDIV128) ||                                                ((DIV) == RST_CLK_CPUclkDIV256))
N
N/** @} */ /* End of group CPU_CLK_divider */
N
N/** @defgroup CPU_CLK_selector CPU CLK selector
N  * @{
N  */
N
N/**
N  * @brief RST_CLK CPU_CLK source CPU_CLK selector constants
N  */
N
N#define RST_CLK_CPUclkHSI                     ((uint32_t)0x00000000)
N#define RST_CLK_CPUclkCPU_C3                  ((uint32_t)0x00000100)
N#define RST_CLK_CPUclkLSE                     ((uint32_t)0x00000200)
N#define RST_CLK_CPUclkLSI                     ((uint32_t)0x00000300)
N
N#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    || \
N                                               ((SRC) == RST_CLK_CPUclkCPU_C3) || \
N                                               ((SRC) == RST_CLK_CPUclkLSE)    || \
N                                               ((SRC) == RST_CLK_CPUclkLSI))
X#define IS_RST_CPU_CLK(SRC)                   (((SRC) == RST_CLK_CPUclkHSI)    ||                                                ((SRC) == RST_CLK_CPUclkCPU_C3) ||                                                ((SRC) == RST_CLK_CPUclkLSE)    ||                                                ((SRC) == RST_CLK_CPUclkLSI))
N
N/** @} */ /* End of group CPU_CLK_selector */
N
N/** @defgroup ADC_MCO_CLOCK_source ADC clock source
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CLK selector constants
N  */
N#define RST_CLK_ADCclkCPU_C1                  ((uint32_t)0x00000020)
N#define RST_CLK_ADCclkUSB_C1                  ((uint32_t)0x00000021)
N#define RST_CLK_ADCclkCPU_C2                  ((uint32_t)0x00000022)
N#define RST_CLK_ADCclkUSB_C2                  ((uint32_t)0x00000023)
N#define RST_CLK_ADCclkLSE                     ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkLSI                     ((uint32_t)0x00000010)
N#define RST_CLK_ADCclkHSI_C1                  ((uint32_t)0x00000030)
N
N#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C1) || \
N                                               ((SRC) == RST_CLK_ADCclkCPU_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkUSB_C2) || \
N                                               ((SRC) == RST_CLK_ADCclkLSE)    || \
N                                               ((SRC) == RST_CLK_ADCclkLSI)    || \
N                                               ((SRC) == RST_CLK_ADCclkHSI_C1))
X#define IS_RST_CLK_ADCclk(SRC)                (((SRC) == RST_CLK_ADCclkCPU_C1) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C1) ||                                                ((SRC) == RST_CLK_ADCclkCPU_C2) ||                                                ((SRC) == RST_CLK_ADCclkUSB_C2) ||                                                ((SRC) == RST_CLK_ADCclkLSE)    ||                                                ((SRC) == RST_CLK_ADCclkLSI)    ||                                                ((SRC) == RST_CLK_ADCclkHSI_C1))
N/** @} */ /* End of group ADC_MCO_CLOCK_source */
N
N/** @defgroup ADC_MCO_CS3_SEL ADC clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK ADC_CS2_SEL output clock ADC_CS3_SEL divider constants
N  */
N
N#define RST_CLK_ADCclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_ADCclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_ADCclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_ADCclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_ADCclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_ADCclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_ADCclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_ADCclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_ADCclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_ADCclkDivValue(SRC)        (((SRC) == RST_CLK_ADCclkDIV1)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV2)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV4)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV8)    || \
N                                               ((SRC) == RST_CLK_ADCclkDIV16)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV32)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV64)   || \
N                                               ((SRC) == RST_CLK_ADCclkDIV128)  || \
N                                               ((SRC) == RST_CLK_ADCclkDIV256))
X#define IS_RST_CLK_ADCclkDivValue(SRC)        (((SRC) == RST_CLK_ADCclkDIV1)    ||                                                ((SRC) == RST_CLK_ADCclkDIV2)    ||                                                ((SRC) == RST_CLK_ADCclkDIV4)    ||                                                ((SRC) == RST_CLK_ADCclkDIV8)    ||                                                ((SRC) == RST_CLK_ADCclkDIV16)   ||                                                ((SRC) == RST_CLK_ADCclkDIV32)   ||                                                ((SRC) == RST_CLK_ADCclkDIV64)   ||                                                ((SRC) == RST_CLK_ADCclkDIV128)  ||                                                ((SRC) == RST_CLK_ADCclkDIV256))
N
N/** @} */ /* End of group ADC_MCO_CS3_SEL */
N
N/** @defgroup AUC_MCO_CLOCK_source AUC clock source
N *  @{
N */
N
N/**
N * @brief RST_CLK AUC_CLK selector constants
N */
N#define RST_CLK_AUCclkHSI_C1						((uint32_t)0x00000000)
N#define RST_CLK_AUCclkHSI_2_C1						((uint32_t)0x00010000)
N#define RST_CLK_AUCclkHSE_C1						((uint32_t)0x00020000)
N#define RST_CLK_AUCclkHSE_2_C1						((uint32_t)0x00030000)
N#define RST_CLK_AUCclkPLLCPU						((uint32_t)0x00100000)
N#define RST_CLK_AUCclkPLLUSB						((uint32_t)0x00200000)
N
N#define IS_RST_CLK_AUCclk(SRC)						(((SRC) == RST_CLK_AUCclkHSI_C1)   || \
N													 ((SRC) == RST_CLK_AUCclkHSI_2_C1) || \
N													 ((SRC) == RST_CLK_AUCclkHSE_C1)   || \
N													 ((SRC) == RST_CLK_AUCclkHSE_2_C1) || \
N													 ((SRC) == RST_CLK_AUCclkPLLCPU)   || \
N													 ((SRC) == RST_CLK_AUCclkPLLUSB))
X#define IS_RST_CLK_AUCclk(SRC)						(((SRC) == RST_CLK_AUCclkHSI_C1)   || 													 ((SRC) == RST_CLK_AUCclkHSI_2_C1) || 													 ((SRC) == RST_CLK_AUCclkHSE_C1)   || 													 ((SRC) == RST_CLK_AUCclkHSE_2_C1) || 													 ((SRC) == RST_CLK_AUCclkPLLCPU)   || 													 ((SRC) == RST_CLK_AUCclkPLLUSB))
N/** @} */ /* End of group AUC_MCO_CLOCK_source */
N
N/** @defgroup AUCclkDIV_divider AUC MCO divider
N *	@{
N */
N
N /**
N  * @brief AUC_MCO_CLK AUC_CLK output clock AUC_CLK_DIV divider
N  */
N#define RST_CLK_AUCclkDIV1							((uint32_t)0x00000000)
N#define RST_CLK_AUCclkDIV2							((uint32_t)0x08000000 | 0x00000000)
N#define RST_CLK_AUCclkDIV4							((uint32_t)0x08000000 | 0x01000000)
N#define RST_CLK_AUCclkDIV8							((uint32_t)0x08000000 | 0x02000000)
N#define RST_CLK_AUCclkDIV16							((uint32_t)0x08000000 | 0x03000000)
N#define RST_CLK_AUCclkDIV32							((uint32_t)0x08000000 | 0x04000000)
N#define RST_CLK_AUCclkDIV64							((uint32_t)0x08000000 | 0x05000000)
N#define RST_CLK_AUCclkDIV128						((uint32_t)0x08000000 | 0x06000000)
N#define RST_CLK_AUCclkDIV256						((uint32_t)0x08000000 | 0x07000000)
N
N#define IS_RST_CLK_AUCclkDIV(DIV)					(((DIV) == RST_CLK_AUCclkDIV1)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV2)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV4)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV8)   || \
N													 ((DIV) == RST_CLK_AUCclkDIV16)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV32)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV64)  || \
N													 ((DIV) == RST_CLK_AUCclkDIV128) || \
N													 ((DIV) == RST_CLK_AUCclkDIV256))
X#define IS_RST_CLK_AUCclkDIV(DIV)					(((DIV) == RST_CLK_AUCclkDIV1)   || 													 ((DIV) == RST_CLK_AUCclkDIV2)   || 													 ((DIV) == RST_CLK_AUCclkDIV4)   || 													 ((DIV) == RST_CLK_AUCclkDIV8)   || 													 ((DIV) == RST_CLK_AUCclkDIV16)  || 													 ((DIV) == RST_CLK_AUCclkDIV32)  || 													 ((DIV) == RST_CLK_AUCclkDIV64)  || 													 ((DIV) == RST_CLK_AUCclkDIV128) || 													 ((DIV) == RST_CLK_AUCclkDIV256))
N/** @} */ /* End of group AUCclkDIV_divider */
N
N
N/** @defgroup CLK_peripheral CLK peripheral
N  * @{
N  */
N
N/**
N  * @brief RST_CLK peripheral modules clock constants
N  */
N
N#define PCLK_BIT(BASE)              ((uint32_t)(1 << ((((uint32_t)BASE) >> 15) & 0x1F)))
N#if defined USE_MDR1986VE3
X#if 0L
S	#define PCLK_BIT2(BASE)				((uint32_t)(1 << ((((uint32_t)BASE) >> 15) & 0x0F)))
N#endif
N
N#ifdef USE_MDR1986VE9x /* For cortex M3 */
N
N	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
N	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
N	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
N	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
N	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
N	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
N	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
N	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
N	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
N	#define RST_CLK_PCLK_09             PCLK_BIT(0x40048000)
N	#define RST_CLK_PCLK_I2C            PCLK_BIT(MDR_I2C_BASE)
N	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
N	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
N	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
N	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
N	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
N	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
N	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
N	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
N	#define RST_CLK_PCLK_COMP           PCLK_BIT(MDR_COMP_BASE)
N	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
N	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
N	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
N	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
N	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
N	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
N	#define RST_CLK_PCLK_26             PCLK_BIT(0x400D0000)
N	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
N	#define RST_CLK_PCLK_28             PCLK_BIT(0x400E0000)
N	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
N	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
N	#define RST_CLK_PCLK_31             PCLK_BIT(0x400F8000)
N
N	#define IS_RST_CLK_PCLK(PCLK)       ((((PCLK) & RST_CLK_PCLK_09) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_26) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_28) == 0x00) && \
N										 (((PCLK) & RST_CLK_PCLK_31) == 0x00))
X	#define IS_RST_CLK_PCLK(PCLK)       ((((PCLK) & RST_CLK_PCLK_09) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_26) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_28) == 0x00) && 										 (((PCLK) & RST_CLK_PCLK_31) == 0x00))
N#endif // #ifdef USE_MDR1986VE9x /* For cortex M3 */
N
N#if defined (USE_MDR1986VE1T)
X#if 0L
S	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
S	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
S	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
S	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
S	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
S	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
S	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
S	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
S	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15531  PCLK_BIT(MDR_MIL_STD_15531_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15532  PCLK_BIT(MDR_MIL_STD_15532_BASE)
S	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
S	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
S	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
S	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
S	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
S	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
S	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
S	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
S	#define RST_CLK_PCLK_TIMER4         PCLK_BIT(MDR_TIMER4_BASE)
S	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
S	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
S	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
S	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
S	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
S	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
S	#define RST_CLK_PCLK_ARINC429R      PCLK_BIT(MDR_ARINC429R_BASE)
S	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
S	#define RST_CLK_PCLK_ARINC429T      PCLK_BIT(MDR_ARINC429T_BASE)
S	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
S	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
S	#define RST_CLK_PCLK_SSP3           PCLK_BIT(MDR_SSP3_BASE)
S
S#define IS_RST_CLK_PCLK(PCLK)			(1)
N#endif /* #if defined (USE_MDR1986VE1T) */
N
N#ifdef USE_MDR1986VE3 /* For Coxtex M1 */
S	#define RST_CLK_PCLK_CAN1           PCLK_BIT(MDR_CAN1_BASE)
S	#define RST_CLK_PCLK_CAN2           PCLK_BIT(MDR_CAN2_BASE)
S	#define RST_CLK_PCLK_USB            PCLK_BIT(MDR_USB_BASE)
S	#define RST_CLK_PCLK_EEPROM         PCLK_BIT(MDR_EEPROM_BASE)
S	#define RST_CLK_PCLK_RST_CLK        PCLK_BIT(MDR_RST_CLK_BASE)
S	#define RST_CLK_PCLK_DMA            PCLK_BIT(MDR_DMA_BASE)
S	#define RST_CLK_PCLK_UART1          PCLK_BIT(MDR_UART1_BASE)
S	#define RST_CLK_PCLK_UART2          PCLK_BIT(MDR_UART2_BASE)
S	#define RST_CLK_PCLK_SSP1           PCLK_BIT(MDR_SSP1_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15531  PCLK_BIT(MDR_MIL_STD_15531_BASE)
S	#define RST_CLK_PCLK_MIL_STD_15532  PCLK_BIT(MDR_MIL_STD_15532_BASE)
S	#define RST_CLK_PCLK_POWER          PCLK_BIT(MDR_POWER_BASE)
S	#define RST_CLK_PCLK_WWDG           PCLK_BIT(MDR_WWDG_BASE)
S	#define RST_CLK_PCLK_IWDG           PCLK_BIT(MDR_IWDG_BASE)
S	#define RST_CLK_PCLK_TIMER1         PCLK_BIT(MDR_TIMER1_BASE)
S	#define RST_CLK_PCLK_TIMER2         PCLK_BIT(MDR_TIMER2_BASE)
S	#define RST_CLK_PCLK_TIMER3         PCLK_BIT(MDR_TIMER3_BASE)
S	#define RST_CLK_PCLK_ADC            PCLK_BIT(MDR_ADC_BASE)
S	#define RST_CLK_PCLK_DAC            PCLK_BIT(MDR_DAC_BASE)
S	#define RST_CLK_PCLK_TIMER4         PCLK_BIT(MDR_TIMER4_BASE)
S	#define RST_CLK_PCLK_SSP2           PCLK_BIT(MDR_SSP2_BASE)
S	#define RST_CLK_PCLK_PORTA          PCLK_BIT(MDR_PORTA_BASE)
S	#define RST_CLK_PCLK_PORTB          PCLK_BIT(MDR_PORTB_BASE)
S	#define RST_CLK_PCLK_PORTC          PCLK_BIT(MDR_PORTC_BASE)
S	#define RST_CLK_PCLK_PORTD          PCLK_BIT(MDR_PORTD_BASE)
S	#define RST_CLK_PCLK_PORTE          PCLK_BIT(MDR_PORTE_BASE)
S	#define RST_CLK_PCLK_ARINC429R      PCLK_BIT(MDR_ARINC429R_BASE)
S	#define RST_CLK_PCLK_BKP            PCLK_BIT(MDR_BKP_BASE)
S	#define RST_CLK_PCLK_ARINC429T      PCLK_BIT(MDR_ARINC429T_BASE)
S	#define RST_CLK_PCLK_PORTF          PCLK_BIT(MDR_PORTF_BASE)
S	#define RST_CLK_PCLK_EBC            PCLK_BIT(MDR_EBC_BASE)
S	#define RST_CLK_PCLK_SSP3           PCLK_BIT(MDR_SSP3_BASE)
S
S	#define RST_CLK_PCLK2_AUDIO_IP		PCLK_BIT2(MDR_AUDIO_IP_BASE)
S	#define RST_CLK_PCLK2_LED			PCLK_BIT2(MDR_LED_BASE)
S	#define RST_CLK_PCLK2_KEYBOARD		PCLK_BIT2(MDR_KEYPAD_BASE)
S	#define RST_CLK_PCLK2_PORTG			PCLK_BIT2(MDR_PORTG_BASE)
S	#define RST_CLK_PCLK2_UART3			PCLK_BIT2(MDR_UART3_BASE)
S	#define RST_CLK_PCLK2_UART4			PCLK_BIT2(MDR_UART4_BASE)
S	#define RST_CLK_PCLK2_SSP4			PCLK_BIT2(MDR_SSP4_BASE)
S	#define RST_CLK_PCLK2_PORTH			PCLK_BIT2(MDR_PORTH_BASE)
S	#define RST_CLK_PCLK2_PORTI			PCLK_BIT2(MDR_PORTI_BASE)
S
S	#define RST_CLK_PCLK2_MASK			(RST_CLK_PCLK2_AUDIO_IP | RST_CLK_PCLK2_KEYBOARD |\
S										 RST_CLK_PCLK2_LED 		| RST_CLK_PCLK2_UART3 	 |\
S										 RST_CLK_PCLK2_UART4	| RST_CLK_PCLK2_SSP4 	 |\
S										 RST_CLK_PCLK2_PORTH 	| RST_CLK_PCLK2_PORTI | RST_CLK_PCLK2_PORTG)
X	#define RST_CLK_PCLK2_MASK			(RST_CLK_PCLK2_AUDIO_IP | RST_CLK_PCLK2_KEYBOARD |										 RST_CLK_PCLK2_LED 		| RST_CLK_PCLK2_UART3 	 |										 RST_CLK_PCLK2_UART4	| RST_CLK_PCLK2_SSP4 	 |										 RST_CLK_PCLK2_PORTH 	| RST_CLK_PCLK2_PORTI | RST_CLK_PCLK2_PORTG)
S
S	#define IS_RST_CLK_PCLK(PCLK)       (1)
S	#define IS_RST_CLK_PCLK2(PCLK2)		(PLCK2 & (~RST_CLK_PCLK2_MASK) == 0)
S
S
N#endif // #ifdef USE_MDR1986VE3 /* For Coxtex M1 */
N
N/** @} */ /* End of group CLK_peripheral */
N
N/** @defgroup RST_CLK_Flag RST_CLK Flag
N  * @{
N  */
N
N/**
N  * @brief RST_CLK flag identifiers
N  */
N
N#define RST_CLK_FLAG_HSIRDY                   ((uint32_t)(0x00 | 23))
N#define RST_CLK_FLAG_LSIRDY                   ((uint32_t)(0x00 | 21))
N#define RST_CLK_FLAG_HSERDY                   ((uint32_t)(0x20 |  2))
N#define RST_CLK_FLAG_HSE2RDY	           	  ((uint32_t)(0x20 |  3))
N#define RST_CLK_FLAG_LSERDY                   ((uint32_t)(0x00 | 13))
N#define RST_CLK_FLAG_PLLCPURDY                ((uint32_t)(0x20 |  1))
N#define RST_CLK_FLAG_PLLUSBRDY                ((uint32_t)(0x20 |  0))
N
N#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_LSIRDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_HSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_HSE2RDY)	  || \
N                                               ((FLAG) == RST_CLK_FLAG_LSERDY)    || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLCPURDY) || \
N                                               ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
X#define IS_RST_CLK_FLAG(FLAG)                 (((FLAG) == RST_CLK_FLAG_HSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_LSIRDY)    ||                                                ((FLAG) == RST_CLK_FLAG_HSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_HSE2RDY)	  ||                                                ((FLAG) == RST_CLK_FLAG_LSERDY)    ||                                                ((FLAG) == RST_CLK_FLAG_PLLCPURDY) ||                                                ((FLAG) == RST_CLK_FLAG_PLLUSBRDY))
N
N/** @} */ /* End of group RST_CLK_Flag */
N
N#define IS_RCC_CLK_HSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x3F)
N#define IS_RCC_CLK_LSI_TRIM_VALUE(TRIM)       ((TRIM) <= 0x1F)
N
N/** @defgroup RST_CLK_HSI_C1_SEL HSI clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSI clock HSI_C1_SEL divider constants
N  */
N
N#define RST_CLK_HSIclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSIclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_HSIclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_HSIclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_HSIclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSIclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSIclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSIclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_HSIclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSIclkDivValue(SRC)        (((SRC) == RST_CLK_HSIclkDIV1)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV2)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV4)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV8)    || \
N                                               ((SRC) == RST_CLK_HSIclkDIV16)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV32)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV64)   || \
N                                               ((SRC) == RST_CLK_HSIclkDIV128)  || \
N                                               ((SRC) == RST_CLK_HSIclkDIV256))
X#define IS_RST_CLK_HSIclkDivValue(SRC)        (((SRC) == RST_CLK_HSIclkDIV1)    ||                                                ((SRC) == RST_CLK_HSIclkDIV2)    ||                                                ((SRC) == RST_CLK_HSIclkDIV4)    ||                                                ((SRC) == RST_CLK_HSIclkDIV8)    ||                                                ((SRC) == RST_CLK_HSIclkDIV16)   ||                                                ((SRC) == RST_CLK_HSIclkDIV32)   ||                                                ((SRC) == RST_CLK_HSIclkDIV64)   ||                                                ((SRC) == RST_CLK_HSIclkDIV128)  ||                                                ((SRC) == RST_CLK_HSIclkDIV256))
N
N/** @} */ /* End of group RST_CLK_HSI_C1_SEL */
N
N/** @defgroup RST_CLK_HSE_C1_SEL HSE clock divider
N  * @{
N  */
N
N/**
N  * @brief RST_CLK HSE clock HSE_C1_SEL divider constants
N  */
N#define RST_CLK_HSEclkDIV1                    ((uint32_t)0x00000000)
N#define RST_CLK_HSEclkDIV2                    ((uint32_t)0x00000008)
N#define RST_CLK_HSEclkDIV4                    ((uint32_t)0x00000009)
N#define RST_CLK_HSEclkDIV8                    ((uint32_t)0x0000000A)
N#define RST_CLK_HSEclkDIV16                   ((uint32_t)0x0000000B)
N#define RST_CLK_HSEclkDIV32                   ((uint32_t)0x0000000C)
N#define RST_CLK_HSEclkDIV64                   ((uint32_t)0x0000000D)
N#define RST_CLK_HSEclkDIV128                  ((uint32_t)0x0000000E)
N#define RST_CLK_HSEclkDIV256                  ((uint32_t)0x0000000F)
N
N#define IS_RST_CLK_HSEclkDivValue(SRC)        (((SRC) == RST_CLK_HSEclkDIV1)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV2)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV4)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV8)    || \
N                                               ((SRC) == RST_CLK_HSEclkDIV16)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV32)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV64)   || \
N                                               ((SRC) == RST_CLK_HSEclkDIV128)  || \
N                                               ((SRC) == RST_CLK_HSEclkDIV256))
X#define IS_RST_CLK_HSEclkDivValue(SRC)        (((SRC) == RST_CLK_HSEclkDIV1)    ||                                                ((SRC) == RST_CLK_HSEclkDIV2)    ||                                                ((SRC) == RST_CLK_HSEclkDIV4)    ||                                                ((SRC) == RST_CLK_HSEclkDIV8)    ||                                                ((SRC) == RST_CLK_HSEclkDIV16)   ||                                                ((SRC) == RST_CLK_HSEclkDIV32)   ||                                                ((SRC) == RST_CLK_HSEclkDIV64)   ||                                                ((SRC) == RST_CLK_HSEclkDIV128)  ||                                                ((SRC) == RST_CLK_HSEclkDIV256))
N
N/** @} */ /* End of group RST_CLK_HSE_C1_SEL */
N
N/** @} */ /* End of group RST_CLK_Exported_Constants */
N
N/** @defgroup RST_CLK_Exported_Macros RST_CLK Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group RST_CLK_Exported_Macros */
N
N/** @defgroup RST_CLK_Exported_Functions RST_CLK Exported Functions
N  * @{
N  */
N
Nvoid RST_CLK_DeInit(void);
Nvoid RST_CLK_WarmDeInit(void);
N
N
Nvoid RST_CLK_HSEconfig(uint32_t RST_CLK_HSE);
NErrorStatus RST_CLK_HSEstatus(void);
N
Nvoid RST_CLK_LSEconfig(uint32_t RST_CLK_LSE);
NErrorStatus RST_CLK_LSEstatus(void);
N
Nvoid RST_CLK_HSIcmd(FunctionalState NewState);
Nvoid RST_CLK_HSIadjust(uint32_t HSItrimValue);
NErrorStatus RST_CLK_HSIstatus(void);
N
Nvoid RST_CLK_LSIcmd(FunctionalState NewState);
Nvoid RST_CLK_LSIadjust(uint32_t LSItrimValue);
NErrorStatus RST_CLK_LSIstatus(void);
N
Nvoid RST_CLK_CPU_PLLconfig(uint32_t RST_CLK_CPU_PLLsource, uint32_t RST_CLK_CPU_PLLmul);
Nvoid RST_CLK_CPU_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_CPU_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_CPU_PLLstatus(void);
N
Nvoid RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue);
Nvoid RST_CLK_CPUclkSelection(uint32_t CPU_CLK);
N
Nvoid RST_CLK_USB_PLLconfig(uint32_t RST_CLK_USB_PLLsource, uint32_t RST_CLK_USB_PLLmul);
Nvoid RST_CLK_USB_PLLuse(FunctionalState UsePLL);
Nvoid RST_CLK_USB_PLLcmd(FunctionalState NewState);
NErrorStatus RST_CLK_USB_PLLstatus(void);
N
Nvoid RST_CLK_USBclkPrescaler(FunctionalState NewState);
Nvoid RST_CLK_USBclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_ADCclkSelection(uint32_t ADC_CLK);
Nvoid RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue);
Nvoid RST_CLK_ADCclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue);
Nvoid RST_CLK_RTC_HSIclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue);
Nvoid RST_CLK_RTC_HSEclkEnable(FunctionalState NewState);
N
Nvoid RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState);
N#if defined (USE_MDR1986VE3)
X#if 0L
S	void RST_CLK_PCLK2cmd ( uint32_t RST_CLK_PCLK2, FunctionalState NewState);
S	void RST_CLK_AUCclkDeInit(void);
S	void RST_CLK_AUCclkSelection(uint32_t AUC_CLK);
S	void RST_CLK_AUCclkPrescaler(uint32_t AUCclkDIVValue);
S	void RST_CLK_AUCclkCMD(FunctionalState NewState);
N#endif
Nvoid RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks);
N
NFlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG);
N
N#if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
X#if 0L || 0L
S	void RST_CLK_HSE2config(uint32_t RST_CLK_HSE2);
S	ErrorStatus RST_CLK_HSE2status(void);
N#endif
N
N/** @} */ /* End of group RST_CLK_Exported_Functions */
N
N/** @} */ /* End of group RST_CLK */
N
N/** @} */ /* End of group __MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_RST_CLK_H */
N
N/******************* (C) COPYRIGHT 2010 Phyton *********************************
N*
N* END OF FILE MDR32F9Qx_rst_clk.h */
L 6 "main.c" 2
N#include "MDR32F9Qx_it.h"
L 1 "MDR32F9Qx_it.h" 1
N/**
N  ******************************************************************************
N  * @file    Examples/MDR32F9Q2_EVAL/UART/Interrupt/MDR32F9Qx_it.h
N  * @author  Milandr Application Team
N  * @version V1.2.0
N  * @date    04/07/2011
N  * @brief   This file contains all the functions prototypes for the interrupt.
N  *
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, MILANDR SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Milandr</center></h2>
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9QX_IT_H
N#define __MDR32F9QX_IT_H
N
N#include "MDR32Fx.h"
N#include "MDR32F9Qx_uart.h"
N
Nvoid NMI_Handler(void);
Nvoid HardFault_Handler(void);
Nvoid MemManage_Handler(void);
Nvoid BusFault_Handler(void);
Nvoid UsageFault_Handler(void);
Nvoid SVC_Handler(void);
Nvoid DebugMon_Handler(void);
Nvoid PendSV_Handler(void);
Nvoid SysTick_Handler(void);
Nvoid CAN1_IRQHandler(void);
Nvoid CAN2_IRQHandler(void);
Nvoid USB_IRQHandler(void);
Nvoid DMA_IRQHandler(void);
Nvoid UART1_IRQHandler(void);
Nvoid UART2_IRQHandler(void);
Nvoid SSP1_IRQHandler(void);
Nvoid I2C_IRQHandler(void);
Nvoid POWER_IRQHandler(void);
Nvoid WWDG_IRQHandler(void);
Nvoid Timer1_IRQHandler(void);
Nvoid Timer2_IRQHandler(void);
Nvoid Timer3_IRQHandler(void);
Nvoid ADC_IRQHandler(void);
Nvoid COMPARATOR_IRQHandler(void);
Nvoid SSP2_IRQHandler(void);
Nvoid BACKUP_IRQHandler(void);
Nvoid EXT_INT1_IRQHandler(void);
Nvoid EXT_INT2_IRQHandler(void);
Nvoid EXT_INT3_IRQHandler(void);
Nvoid EXT_INT4_IRQHandler(void);
N
N#endif /* __MDR32F9QX_IT_H */
N
N/******************* (C) COPYRIGHT 2011 Milandr *********/
N
N/* END OF FILE MDR32F9Qx_it.h */
N
L 7 "main.c" 2
N#include "MDR32F9Qx_ssp.h"
L 1 "C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\MDR32F9Qx_ssp.h" 1
N/**
N  ******************************************************************************
N  * @file    MDR32F9Qx_ssp.h
N  * @author  Phyton Application Team
N  * @version V1.4.0
N  * @date    01/02/2011
N  * @brief   This file contains all the functions prototypes for the SSP
N  *          firmware library.
N  ******************************************************************************
N  * <br><br>
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
N  * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
N  ******************************************************************************
N  * FILE MDR32F9Qx_ssp.h
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MDR32F9Qx_SSP_H
N#define __MDR32F9Qx_SSP_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "MDR32F9Qx_lib.h"
N
N/** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
N  * @{
N  */
N
N/** @addtogroup SSP
N  * @{
N  */
N
N/** @defgroup SSP_Exported_Types SSP Exported Types
N  * @{
N  */
N
N/**
N  * @brief  SSP Init Structure definition
N  */
N
Ntypedef struct
N{
N  uint16_t SSP_SCR;                        /*!< This member configures the SSP communication speed.
N                                                This parameter is number from 0 to 255.
N                                                The information rate is computed using the following formula:
N                                                F_SSPCLK / ( CPSDVR * (1 + SCR) ) */
N  uint16_t SSP_CPSDVSR;                    /*!< This member configures the SSP clock divider.
N                                                This parameter is an even number from 2 to 254 */
N  uint16_t SSP_Mode;                       /*!< Specifies the number of stop bits transmitted.
N                                                This parameter is one of @ref SSP_Mode values. */
N  uint16_t SSP_WordLength;                 /*!< Specifies the number of data bits transmitted or received in a frame.
N                                                This parameter is one of @ref SSP_Word_Length values. */
N  uint16_t SSP_SPH;                        /*!< Specifies the number of stop bits transmitted.
N                                                This parameter is one of @ref SSP_Clock_Phase values. */
N  uint16_t SSP_SPO;                        /*!< Specifies the number of stop bits transmitted.
N                                                This parameter is one of @ref SSP_Clock_Polarity values. */
N  uint16_t SSP_FRF;                        /*!< Specifies the number of stop bits transmitted.
N                                                This parameter is one of @ref SSP_Frame_Format values. */
N  uint16_t SSP_HardwareFlowControl;        /*!< Specifies whether the hardware flow control mode is enabled or disabled.
N                                                This parameter is one of @ref SSP_Hardware_Flow_Control values. */
N}SSP_InitTypeDef;
N
N/** @} */ /* End of group SSP_Exported_Types */
N
N
N/** @defgroup SSP_Exported_Constants SSP Exported Constants
N  * @{
N  */
N
N#ifdef USE_MDR1986VE9x /* For Cortex M3 */
N#define IS_SSP_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_SSP1) || \
N                                            ((PERIPH) == MDR_SSP2))
X#define IS_SSP_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_SSP1) ||                                             ((PERIPH) == MDR_SSP2))
N#endif // #ifdef USE_MDR1986VE9x /* For Cortex M3 */
N
N
N#ifdef USE_MDR1986VE3 /* For Cortex M1 */
S#define IS_SSP_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_SSP1) || \
S                                            ((PERIPH) == MDR_SSP2) || \
S                                            ((PERIPH) == MDR_SSP3) || \
S                                            ((PERIPH) == MDR_SSP4))
X#define IS_SSP_ALL_PERIPH(PERIPH)          (((PERIPH) == MDR_SSP1) ||                                             ((PERIPH) == MDR_SSP2) ||                                             ((PERIPH) == MDR_SSP3) ||                                             ((PERIPH) == MDR_SSP4))
N#endif // #ifdef USE_MDR1986VE3 /* For Cortex M1 */
N
N
N
N#define IS_SSP_SPEED_FACTOR(DIVIDER)       ((DIVIDER) <= 0xFF)
N
N#define IS_SSP_SPEED_DIVIDER(DIVIDER)      (((DIVIDER) <= 0xFE) && \
N                                            ((DIVIDER) >= 0x02) && \
N                                            (((DIVIDER) & 0x01) == 0))
X#define IS_SSP_SPEED_DIVIDER(DIVIDER)      (((DIVIDER) <= 0xFE) &&                                             ((DIVIDER) >= 0x02) &&                                             (((DIVIDER) & 0x01) == 0))
N
N/** @defgroup SSP_Mode SSP Mode
N  * @{
N  */
N
N#define SSP_ModeMaster                     ((uint32_t)0x0000)
N#define SSP_ModeSlave                      ((uint32_t)0x0004)
N
N#define IS_SSP_MODE(MODE)                  (((MODE) == SSP_ModeMaster) || \
N                                            ((MODE) == SSP_ModeSlave))
X#define IS_SSP_MODE(MODE)                  (((MODE) == SSP_ModeMaster) ||                                             ((MODE) == SSP_ModeSlave))
N
N/** @} */ /* End of group SSP_Mode */
N
N/** @defgroup SSP_Word_Length SSP Word Length
N  * @{
N  */
N
N#define SSP_WordLength4b                   ((uint16_t)0x0003)
N#define SSP_WordLength5b                   ((uint16_t)0x0004)
N#define SSP_WordLength6b                   ((uint16_t)0x0005)
N#define SSP_WordLength7b                   ((uint16_t)0x0006)
N#define SSP_WordLength8b                   ((uint16_t)0x0007)
N#define SSP_WordLength9b                   ((uint16_t)0x0008)
N#define SSP_WordLength10b                  ((uint16_t)0x0009)
N#define SSP_WordLength11b                  ((uint16_t)0x000A)
N#define SSP_WordLength12b                  ((uint16_t)0x000B)
N#define SSP_WordLength13b                  ((uint16_t)0x000C)
N#define SSP_WordLength14b                  ((uint16_t)0x000D)
N#define SSP_WordLength15b                  ((uint16_t)0x000E)
N#define SSP_WordLength16b                  ((uint16_t)0x000F)
N
N#define IS_SSP_WORD_LENGTH(LENGTH)         (((LENGTH) == SSP_WordLength4b)  || \
N                                            ((LENGTH) == SSP_WordLength5b)  || \
N                                            ((LENGTH) == SSP_WordLength6b)  || \
N                                            ((LENGTH) == SSP_WordLength7b)  || \
N                                            ((LENGTH) == SSP_WordLength8b)  || \
N                                            ((LENGTH) == SSP_WordLength9b)  || \
N                                            ((LENGTH) == SSP_WordLength10b) || \
N                                            ((LENGTH) == SSP_WordLength11b) || \
N                                            ((LENGTH) == SSP_WordLength12b) || \
N                                            ((LENGTH) == SSP_WordLength13b) || \
N                                            ((LENGTH) == SSP_WordLength14b) || \
N                                            ((LENGTH) == SSP_WordLength15b) || \
N                                            ((LENGTH) == SSP_WordLength16b))
X#define IS_SSP_WORD_LENGTH(LENGTH)         (((LENGTH) == SSP_WordLength4b)  ||                                             ((LENGTH) == SSP_WordLength5b)  ||                                             ((LENGTH) == SSP_WordLength6b)  ||                                             ((LENGTH) == SSP_WordLength7b)  ||                                             ((LENGTH) == SSP_WordLength8b)  ||                                             ((LENGTH) == SSP_WordLength9b)  ||                                             ((LENGTH) == SSP_WordLength10b) ||                                             ((LENGTH) == SSP_WordLength11b) ||                                             ((LENGTH) == SSP_WordLength12b) ||                                             ((LENGTH) == SSP_WordLength13b) ||                                             ((LENGTH) == SSP_WordLength14b) ||                                             ((LENGTH) == SSP_WordLength15b) ||                                             ((LENGTH) == SSP_WordLength16b))
N
N/** @} */ /* End of group SSP_Word_Length */
N
N/** @defgroup SSP_Clock_Phase SSP Clock Phase
N  * @{
N  */
N
N#define SSP_SPH_1Edge                       ((uint16_t)0x0000)
N#define SSP_SPH_2Edge                       ((uint16_t)0x0080)
N
N#define IS_SSP_SPH(PHASE)                   (((PHASE) == SSP_SPH_1Edge) || \
N                                             ((PHASE) == SSP_SPH_2Edge))
X#define IS_SSP_SPH(PHASE)                   (((PHASE) == SSP_SPH_1Edge) ||                                              ((PHASE) == SSP_SPH_2Edge))
N
N/** @} */ /* End of group SSP_Clock_Phase */
N
N/** @defgroup SSP_Clock_Polarity SSP Clock Polarity
N  * @{
N  */
N
N#define SSP_SPO_Low                         ((uint16_t)0x0000)
N#define SSP_SPO_High                        ((uint16_t)0x0040)
N
N#define IS_SSP_SPO(LEVEL)                   (((LEVEL) == SSP_SPO_Low) || \
N                                             ((LEVEL) == SSP_SPO_High))
X#define IS_SSP_SPO(LEVEL)                   (((LEVEL) == SSP_SPO_Low) ||                                              ((LEVEL) == SSP_SPO_High))
N
N/** @} */ /* End of group SSP_Clock_Polarity */
N
N/** @defgroup SSP_Frame_Format SSP Frame Format
N  * @{
N  */
N
N#define SSP_FRF_SPI_Motorola                ((uint16_t)0x0000)
N#define SSP_FRF_SSI_TI                      ((uint16_t)0x0010)
N#define SSP_FRF_Microwire                   ((uint16_t)0x0020)
N
N#define IS_SSP_FRF(FORMAT)                  (((FORMAT) == SSP_FRF_SPI_Motorola) || \
N                                             ((FORMAT) == SSP_FRF_SSI_TI)       || \
N                                             ((FORMAT) == SSP_FRF_Microwire))
X#define IS_SSP_FRF(FORMAT)                  (((FORMAT) == SSP_FRF_SPI_Motorola) ||                                              ((FORMAT) == SSP_FRF_SSI_TI)       ||                                              ((FORMAT) == SSP_FRF_Microwire))
N
N/** @} */ /* End of group SSP_Frame_Format */
N
N/** @defgroup SSP_Hardware_Flow_Control SSP Hardware Flow Control
N  * @{
N  */
N#define SSP_HardwareFlowControl_None        ((uint16_t)0x0000)
N#define SSP_HardwareFlowControl_SOD         ((uint16_t)0x0008)
N#define SSP_HardwareFlowControl_SSE         ((uint16_t)0x0002)
N#define SSP_HardwareFlowControl_LBM         ((uint16_t)0x0001)
N
N#define SSP_HardwareFlowControl_MASK		((uint16_t)(SSP_HardwareFlowControl_None |\
N													  SSP_HardwareFlowControl_SSE |\
N													  SSP_HardwareFlowControl_LBM))
X#define SSP_HardwareFlowControl_MASK		((uint16_t)(SSP_HardwareFlowControl_None |													  SSP_HardwareFlowControl_SSE |													  SSP_HardwareFlowControl_LBM))
N
N#define IS_SSP_HARDWARE_FLOW_CONTROL(CONTROL) \
N                              ((CONTROL & (~SSP_HardwareFlowControl_MASK)) == 0)
X#define IS_SSP_HARDWARE_FLOW_CONTROL(CONTROL)                               ((CONTROL & (~SSP_HardwareFlowControl_MASK)) == 0)
N/** @} */ /* End of group SSP_Hardware_Flow_Control */
N
N/** @defgroup SSP_Flags SSP Flags
N  * @{
N  */
N
N#define SSP_FLAG_BSY                        ((uint16_t)0x0010)
N#define SSP_FLAG_RFF                        ((uint16_t)0x0008)
N#define SSP_FLAG_RNE                        ((uint16_t)0x0004)
N#define SSP_FLAG_TNF                        ((uint16_t)0x0002)
N#define SSP_FLAG_TFE                        ((uint16_t)0x0001)
N
N#define IS_SSP_FLAG(FLAG)                   (((FLAG) == SSP_FLAG_BSY) || \
N                                             ((FLAG) == SSP_FLAG_RFF) || \
N                                             ((FLAG) == SSP_FLAG_RNE) || \
N                                             ((FLAG) == SSP_FLAG_TNF) || \
N                                             ((FLAG) == SSP_FLAG_TFE))
X#define IS_SSP_FLAG(FLAG)                   (((FLAG) == SSP_FLAG_BSY) ||                                              ((FLAG) == SSP_FLAG_RFF) ||                                              ((FLAG) == SSP_FLAG_RNE) ||                                              ((FLAG) == SSP_FLAG_TNF) ||                                              ((FLAG) == SSP_FLAG_TFE))
N
N/** @} */ /* End of group SSP_Flags */
N
N/** @defgroup SSP_Interrupt_definition SSP Interrupt definition
N  * @{
N  */
N
N#define SSP_IT_TX                           ((uint32_t)0x00000008)
N#define SSP_IT_RX                           ((uint32_t)0x00000004)
N#define SSP_IT_RT                           ((uint32_t)0x00000002)
N#define SSP_IT_ROR                          ((uint32_t)0x00000001)
N
N#define SSP_IT_MASK							(SSP_IT_TX | SSP_IT_RX |\
N											 SSP_IT_RT | SSP_IT_ROR)
X#define SSP_IT_MASK							(SSP_IT_TX | SSP_IT_RX |											 SSP_IT_RT | SSP_IT_ROR)
N
N#define IS_SSP_CONFIG_IT(IT)				((IT) & (~SSP_IT_MASK) == 0)
N
N/*
N#define IS_SSP_CONFIG_IT(IT)                (((IT) == SSP_IT_TX) || \
N                                             ((IT) == SSP_IT_RX) || \
N                                             ((IT) == SSP_IT_RT) || \
N                                             ((IT) == SSP_IT_ROR))
X
N*/
N
N#define IS_SSP_RESET_IT(IT)                 (((IT) == SSP_IT_RT) || \
N                                             ((IT) == SSP_IT_ROR))
X#define IS_SSP_RESET_IT(IT)                 (((IT) == SSP_IT_RT) ||                                              ((IT) == SSP_IT_ROR))
N
N/** @} */ /* End of group SSP_Interrupt_definition */
N
N/** @defgroup SSP_DMA_request SSP DMA request
N  * @{
N  */
N
N#define SSP_DMA_TXE                         ((uint32_t)0x00000002)
N#define SSP_DMA_RXE                         ((uint32_t)0x00000001)
N
N#define IS_SSP_DMAREQ(DMAREQ)               (((DMAREQ) == SSP_DMA_TXE) || \
N                                             ((DMAREQ) == SSP_DMA_RXE))
X#define IS_SSP_DMAREQ(DMAREQ)               (((DMAREQ) == SSP_DMA_TXE) ||                                              ((DMAREQ) == SSP_DMA_RXE))
N
N/** @} */ /* End of group SSP_DMA_request */
N
N/** @defgroup SSP_Clock_BRG SSP Clock BRG
N  * @{
N  */
N
N#define SSP_HCLKdiv1                        ((uint32_t)0x00000000)
N#define SSP_HCLKdiv2                        ((uint32_t)0x00000001)
N#define SSP_HCLKdiv4                        ((uint32_t)0x00000002)
N#define SSP_HCLKdiv8                        ((uint32_t)0x00000003)
N#define SSP_HCLKdiv16                       ((uint32_t)0x00000004)
N#define SSP_HCLKdiv32                       ((uint32_t)0x00000005)
N#define SSP_HCLKdiv64                       ((uint32_t)0x00000006)
N#define SSP_HCLKdiv128                      ((uint32_t)0x00000007)
N
N#define IS_SSP_CLOCK_BRG(BRG)               ((BRG) <= 7)
N
N/** @} */ /* End of group SSP_Clock_BRG */
N
N/** @} */ /* End of group SSP_Exported_Constants */
N
N/** @defgroup SSP_Exported_Macros SSP Exported Macros
N  * @{
N  */
N
N/** @} */ /* End of group SSP_Exported_Macros */
N
N/** @defgroup SSP_Exported_Functions SSP Exported Functions
N  * @{
N  */
N
Nvoid SSP_DeInit(MDR_SSP_TypeDef* SSPx);
Nvoid SSP_Init(MDR_SSP_TypeDef* SSPx, const SSP_InitTypeDef* SSP_InitStruct);
Nvoid SSP_StructInit(SSP_InitTypeDef* SSP_InitStruct);
Nvoid SSP_Cmd(MDR_SSP_TypeDef* SSPx, FunctionalState NewState);
N
Nvoid SSP_ITConfig(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT, FunctionalState NewState);
NITStatus SSP_GetITStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT);
NITStatus SSP_GetITStatusMasked(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT);
Nvoid SSP_ClearITPendingBit(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT);
N
Nvoid SSP_DMACmd(MDR_SSP_TypeDef* SSPx, uint32_t SSP_DMAReq, FunctionalState NewState);
N
Nvoid SSP_SendData(MDR_SSP_TypeDef* SSPx, uint16_t Data);
Nuint16_t SSP_ReceiveData(MDR_SSP_TypeDef* SSPx);
N
NFlagStatus SSP_GetFlagStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_FLAG);
Nvoid SSP_BRGInit(MDR_SSP_TypeDef* SSPx, uint32_t SSP_BRG);
N
N/** @} */ /* End of group SSP_Exported_Functions */
N
N/** @} */ /* End of group SSP */
N
N/** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
N
N#ifdef __cplusplus
S} // extern "C" block end
N#endif
N
N#endif /* __MDR32F9Qx_SSP_H */
N
N/******************* (C) COPYRIGHT 2011 Phyton *********
N*
N* END OF FILE MDR32F9Qx_ssp.h */
L 8 "main.c" 2
N
N
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 185525 $ Codemist 0.03
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5050106
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199901L)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 11 "main.c" 2
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 185531 $
N * Checkin $Date: 2014-05-29 15:16:06 +0100 (Thu, 29 May 2014) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5050106
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 12 "main.c" 2
N
N#include "spec_1508pl10.h"
L 1 "spec_1508pl10.h" 1
N
Ntypedef struct reg_1508pl10   //flags //Init_pins_for_DDS   pins_DDS;  //   
N{
N           char            Name[5];  // 
N  unsigned char       T_Amp_pres:1; //  "0"
N  unsigned char          T_Fop_o:1; //      0    1  
N
N  unsigned char             T_vr:1;   // 
N  unsigned char             T_Pd:1;   // 
N  unsigned char          T_Del_m:1;   // 
N
N  unsigned char               Kz:1; //    Z  . 0    1   
N  unsigned char               FD:2; //  FD1, FD0     : 00 - 17|01 - 29 | 10 - 52| 11 - 100 
N 
N  unsigned char               Kb:1; //    Fdiv2(14) 0      1     
N  unsigned char               Kp:1; //     . 0    1   
N
N  unsigned char             Kok:1; //    . 0    (.  ) 1   
N  unsigned char             Kpo:1; //     Fdiv3(9). 0      1     
N  unsigned char             Klt:1; //    . 0        1       .
N                                   //       ,    Fd2 (Down)      
N
N  unsigned char            KREF4:1; //   
N  unsigned char            KREF3:1; //   
N
N  unsigned char            KREF2:1; //   
N  unsigned char            KREF1:1; //   
N  unsigned char            KREF0:1; //   
N
N  unsigned int             Kosn16_19:4; //     
N  unsigned int             Kosn00_15:16; //     
N
N
N} reg_1508pl10;
L 14 "main.c" 2
N
N#define PA2_1 PORT_SetBits  (MDR_PORTA, PORT_Pin_2)
N#define PA2_0 PORT_ResetBits(MDR_PORTA, PORT_Pin_2)
N
N#define RE_485_1 PA2_1 
N#define RE_485_0 PA2_0 
N
N#define PC0_1 PORT_SetBits  (MDR_PORTC, PORT_Pin_0)
N#define PC0_0 PORT_ResetBits(MDR_PORTC, PORT_Pin_0)
N
N#define DE_485_1 PC0_1 
N#define DE_485_0 PC0_0 
N
N#define PB8_1 PORT_SetBits  (MDR_PORTB, PORT_Pin_8)
N#define PB8_0 PORT_ResetBits(MDR_PORTB, PORT_Pin_8)
N
N#define PWR_OFF PB8_1 
N#define PWR_ON  PB8_0 
N
N#define PC1_1 PORT_SetBits  (MDR_PORTC, PORT_Pin_1)
N#define PC1_0 PORT_ResetBits(MDR_PORTC, PORT_Pin_1)
N
N#define ZAHVAT_OFF PC1_1 
N#define ZAHVAT_ON  PC1_0 
N
N#define PA6_1  PORT_SetBits  (MDR_PORTA, PORT_Pin_6)
N#define PA6_0  PORT_ResetBits(MDR_PORTA, PORT_Pin_6)
N
N#define LED1_OFF PA6_1 
N#define LED1_ON  PA6_0 
N
N#define PA7_1  PORT_SetBits  (MDR_PORTA, PORT_Pin_7)
N#define PA7_0  PORT_ResetBits(MDR_PORTA, PORT_Pin_7)
N
N#define LED2_OFF PA7_1 
N#define LED2_ON  PA7_0 
N
N
N//===========================================================================================================
N
Nstatic PORT_InitTypeDef PortInit;
Nstatic UART_InitTypeDef UART_InitStructure;
Nstatic SSP_InitTypeDef sSSP;
N
N//SPI
N
N
Nuint8_t TxIdx = 0, RxIdx = 0;
N
N// UART
N
N unsigned char DataTr_flag=0;
N unsigned char Data_in_port=0;
N unsigned char DontConnect_flag=0;      
N unsigned      CntDown = 0;             
N unsigned char CyclEnd_flag=0;          
N                                        
N unsigned char RcvBufOverflow_flag=0;    
N                                        
N unsigned char BufIsRead_flag=0;       
N unsigned char Data4TrAbsent_flag=1;    
N#define buf_size 256
N unsigned char TrBuf[buf_size];
X unsigned char TrBuf[256];
N unsigned char RcvBuf[buf_size];
X unsigned char RcvBuf[256];
N unsigned char sch_buf=0;
N
N                                         
N                                       
N unsigned char *pTr_Buf;                
N unsigned char *pcur_Tr;                
N unsigned char *pRcv_Buf;           
N unsigned char *pcur_Rcv;
N
N void fillBuf  (         char* ptrBuf, unsigned short lengthBuf, unsigned char symb );
N void clearBuf (         char* ptrBuf, unsigned short lengthBuf );
N void zputs    (              char* s, unsigned char s_size );
N  int getStr   (              char* s, unsigned char* s_size );
N
N  //  UART
N
N  uint32_t uart1_IT_TX_flag=RESET;
N  uint32_t uart1_IT_RX_flag=RESET;
N
N  uint32_t uart2_IT_TX_flag=RESET;
N  uint32_t uart2_IT_RX_flag=RESET;
N
N
N#define Bufer_size  64     //16384
N
Nvolatile  unsigned int  text_lengh;
N
N
Nunsigned int j_pack=0;
Nunsigned char packet[4][32];
Nunsigned char flag_clear=0;
N char ok[5];
Nunsigned int led_tick;
Nint *pointer1;
Nunsigned adspChipVersion;
Nunsigned nn=0;
Nunsigned tt;
Nunsigned tested;
Nshort sch_uart;
Nunsigned char  sch_plis_ppi=0;
Nunsigned char  flag_test_sync=0;
Nunsigned char  sch_packet_UDP_reciv=0;
N
N char s1[Bufer_size];
X char s1[64];
Nunsigned l1= 5;
N char s2[Bufer_size];
X char s2[64];
Nunsigned l2=6;
N char s3[Bufer_size];
X char s3[64];
Nunsigned l3=7;
N char sr[Bufer_size];
X char sr[64];
Nstatic  char lsr=0;
Nunsigned char lk;
Nunsigned int dFo1;
N
N//-------------------------------------
Nuint32_t Temp, CurrentLed = 0;
Nuint32_t i=0;
N
Nunsigned short flag_rsv=0;
N//-------------------------------------
N
N#define dT_kalibrovka 304
N#define dT_pomeha 512   
N#define Test_delay 5
N#define  u16 unsigned short
N#define  u32 unsigned int   
N#define  u8  unsigned char
N#define  CPUacceler          1     
N
N
N//*************************************************************************
N       unsigned char  k;
N        char  strng[Bufer_size];
X        char  strng[64];
N
N volatile unsigned    char lsym;
N volatile unsigned    char  sym;
N volatile unsigned    char flag;
N volatile unsigned    char packet_flag;
N volatile unsigned      char  NB;
N
N  unsigned    char Adress=0x36;       
N  unsigned    char Master_flag=0x0;   
N
N  static volatile   unsigned    char packet_sum;
N  static volatile   unsigned    char crc,comanda=1;
N  static volatile   unsigned    char     InOut[Bufer_size];
X  static volatile   unsigned    char     InOut[64];
N 
N  static volatile    char      Word [Bufer_size];     
X  static volatile    char      Word [64];     
N  static volatile    char DATA_Word [Bufer_size];    
X  static volatile    char DATA_Word [64];    
N  static volatile    char DATA_Word2[Bufer_size];     
X  static volatile    char DATA_Word2[64];     
N  static volatile unsigned    char crc_ok;
N  static volatile unsigned    char packet_ok;
N  unsigned    char ink1;  
N  unsigned    char data_in;
N  static volatile unsigned    char index_word=0;
N  static volatile unsigned    char index_data_word =0;
N  static volatile unsigned    char index_data_word2=0;
N  static volatile unsigned    char data_flag=0;
N  static volatile unsigned    char data_flag2=0;
N  unsigned    char crc_input; 
N  unsigned    char crc_comp;  
N  unsigned    char sch_obmen=0;
N  unsigned    char   Process_code=0;
N  unsigned    char   Test_f_mono=0;
N
Nvolatile  unsigned int   sch_avariya=0;
N  
N               
N unsigned volatile int  time_uart;  
N unsigned volatile int  tick_wait;
N      
N    unsigned  char UDP_TCP_flag=0;
N    
N                     unsigned char CRC_m[3][6];  
N                     unsigned char K615_indik=0;  
N              volatile       unsigned char K615_crc_sch=0;   
N              volatile       unsigned char K615_crc_sch2=0;  
N      
N          unsigned  char Error_ethernet_obmen=0;  
N volatile unsigned  char flag_pachka_sinhron;  
N
N volatile  unsigned  char flag_pachka_TXT; // 
N volatile  unsigned  char flag_pachka_TXT2; // 
N
N volatile  unsigned  int sch_pachek_test=0;
N
N
N  unsigned volatile char          flag_K615_event; 
N
N volatile   unsigned char flag_cikl_ON=0;
N volatile   unsigned char flag_Ethernet_packet_rcv=0;
N volatile            int sch_UDP_pakets=0;
N
N        unsigned char flag_process=1;
N        unsigned char flag_event_K615_run=0;
N        unsigned int  delay_process=400;
N
N        unsigned char flag_uart_trcv=0;
N
N        unsigned char Pachka_START=0;
N        unsigned char   sync_flag=0;
N
N      volatile  unsigned char   sync_sch_flag=3;
N      unsigned volatile char tick_us;
N
N    unsigned char sinc_type=0;
N
N   volatile unsigned char  flag_MASTER_pachka=0;
N   volatile unsigned int   TNC_number_run=0;
N            unsigned char  flag_form_packet_SDRAM=0;
N			unsigned char  otvet_flag=0;
N			unsigned char  SYS_LIFE=0;
N			
N
N
N //*************************************************************************    
N 
N unsigned volatile  char index1  =0;
N unsigned volatile char lsym1    =0;
N unsigned volatile char pack_ok1 =0;
N unsigned volatile char pack_sum1=0;   
N unsigned volatile char sym1     =0;  
N  
N volatile unsigned char               Flag_K611=0;
N volatile unsigned char          Flag_init_K611=0;
N volatile unsigned char       Flag_control_K611=0;
N volatile unsigned char   Flag_control_sig_K611=0;
N volatile unsigned char   Flag_control_end_K611=0;
N volatile unsigned char    Flag_zahvat_sig_K611=0;
N volatile  unsigned char   Flag_zahvat_end_K611=0;
N volatile unsigned char              Qwant_K611=0;
N volatile unsigned char     Flag_zahvat_OK_K611=0;
N volatile unsigned char     Flag_signal_OK_K611=0;
N
N
N volatile unsigned char                  PROCESS=0;
N
N  unsigned char   test1=0;
N  unsigned char   test2=0;
N
N volatile unsigned char sys_life_k612=0;
N volatile unsigned char sys_life_k613=0;
N
Nvolatile  unsigned char AVARIYA_flag=0;
N
N unsigned volatile int  tick_process;
N unsigned volatile int  tick_process_K611;
N unsigned volatile int  tick_process_K615;
N unsigned volatile int  tick_process_K612;
N unsigned volatile int  tick_process_K613;
N unsigned volatile int  tick_process_OK;
N unsigned volatile int  tick_TCP;
N unsigned volatile int  tick_UDP;
N
N  
N unsigned volatile char flag_Ethernet;  
N       unsigned volatile char flag_Ethernet_Terminal=0; 
N
N     
N   volatile    unsigned char flag_PPI_sz1 =0;
N   volatile    unsigned char flag_PPI_sz2 =0;
N   volatile    unsigned char flag_PPI_sinc=0;
N   volatile    unsigned char flag_contr_TNC_TNO=0;
N   volatile    unsigned char flag_Packet_form=0;
N
N   unsigned char flag_PPI_START=0;
N
N
N       unsigned char label_PPI=0;
N       unsigned char Test_PPI_flag1=0;
N       unsigned char Test_PPI_flag2=0;
N       unsigned char Test_PPI_flag3=0;
N
N       unsigned char RESET_SINTEZ_flag=0;
N
N   volatile    unsigned int time_TNO=0;
N   volatile    unsigned int time_TNC=0;
N
N   volatile    unsigned int time_TNO_min=0;
N   volatile    unsigned int time_TNC_min=0;
N
N   volatile    unsigned int time_TNO_max=0;
N   volatile    unsigned int time_TNC_max=0;
N
N   volatile    unsigned char flag_1HZ_sync=0;
N               unsigned char flag_START_packa_SINTEZ=0;
N			   unsigned char flag_status_ZAHVAT=0;
N			   unsigned char FLAG_INIT_FOCH=0;	
N			   unsigned char FLAG_INIT_MENU=0;	
N			   unsigned char FLAG_INIT_n_FOCH=0; //   	
N			   unsigned char FLAG_LED_n=0; //   			   
N  //------------------------------------------------------------------
N
N 
N
N
N
Nreg_1508pl10 reg_FAPCH1={ 
N              {'','','','','1'},  
N              0,// .     .
N							0,//    0    1  
N							0,// .     .
N							0,// .     .
N							0,// .     .
N							0,//  Z  . 0    1   
N						  0x0,//  FD1, FD0     : 00 - 17|01 - 29 | 10 - 52| 11 - 100 
N						    0,//    Fdiv2(14) 0      1     
N						    0,//     . 0    1   
N						    0,//    . 0    (.  ) 1   
N						    0,//     Fdiv3(9). 0      1     
N						    1,//    . 0        1       .       ,    Fd2 (Down)      
N						    0,//    00 - Kdiv1 = 10 ; 01 - Kdiv1 = 80 ; 10 - Kdiv1 = 100; 11 - Kdiv1 = 125   
N						    0,//
N						    0,// 000 - Kdiv2 = 160; 001 - Kdiv2 = 80; 010 - Kdiv2 = 40; 011 - Kdiv2 = 20; 100 - Kdiv2 = 200; 101 - Kdiv2 = 100;    
N						    0,//
N						    0,//
N						    0,//       
N						  240 //       
N
N                          }; 
N
N reg_1508pl10 reg_FAPCH2={ 
N              {'','','','','2'},     
N              0,// .     .
N							0,//    0    1  
N							0,// .     .
N							0,// .     .
N							0,// .     .
N							0,//  Z  . 0    1   
N						  0x0,//  FD1, FD0     : 00 - 17|01 - 29 | 10 - 52| 11 - 100 
N						    0,//    Fdiv2(14) 0      1     
N						    0,//     . 0    1   
N						    0,//    . 0    (.  ) 1   
N						    0,//     Fdiv3(9). 0      1     
N						    1,//    . 0        1       .       ,    Fd2 (Down)      
N						    0,//    00 - Kdiv1 = 10 ; 01 - Kdiv1 = 80 ; 10 - Kdiv1 = 100; 11 - Kdiv1 = 125   
N						    0,//
N						    0,// 000 - Kdiv2 = 160; 001 - Kdiv2 = 80; 010 - Kdiv2 = 40; 011 - Kdiv2 = 20; 100 - Kdiv2 = 200; 101 - Kdiv2 = 100;    
N						    0,//
N						    0,//
N						    0,//       
N						  240 //       
N
N                          };    
N
N//------------------------------------
Nvoid Uart1PinCfg(void)
N{
N  /* Fill PortInit structure*/
N    PortInit.PORT_PULL_UP = PORT_PULL_UP_OFF;
N    PortInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF;
N    PortInit.PORT_PD_SHM = PORT_PD_SHM_OFF;
N    PortInit.PORT_PD = PORT_PD_DRIVER;
N    PortInit.PORT_GFEN = PORT_GFEN_OFF;
N    PortInit.PORT_FUNC = PORT_FUNC_ALTER;
N    PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N    PortInit.PORT_MODE = PORT_MODE_DIGITAL;
N    /* Configure PORTB pins 6 (UART1_RX) as input */
N    PortInit.PORT_OE = PORT_OE_IN;
N    PortInit.PORT_Pin = PORT_Pin_6;
X    PortInit.PORT_Pin = 0x0040U;
N    PORT_Init(MDR_PORTB, &PortInit);
X    PORT_Init(((MDR_PORT_TypeDef *) (0x400B0000)), &PortInit);
N    /* Configure PORTB pins 5 (UART1_TX) as output */
N    PortInit.PORT_OE = PORT_OE_OUT;
N    PortInit.PORT_Pin = PORT_Pin_5;
X    PortInit.PORT_Pin = 0x0020U;
N    PORT_Init(MDR_PORTB, &PortInit);  
X    PORT_Init(((MDR_PORT_TypeDef *) (0x400B0000)), &PortInit);  
N}
N
Nvoid Uart2PinCfg(void)
N{
N	
N	  /* Fill PortInit structure*/
N    PortInit.PORT_PULL_UP = PORT_PULL_UP_OFF;
N    PortInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF;
N    PortInit.PORT_PD_SHM = PORT_PD_SHM_OFF;
N    PortInit.PORT_PD = PORT_PD_DRIVER;
N    PortInit.PORT_GFEN = PORT_GFEN_OFF;
N    PortInit.PORT_FUNC = PORT_FUNC_ALTER;
N    PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N    PortInit.PORT_MODE = PORT_MODE_DIGITAL;
N    /* Configure PORTD pins 0 (UART2_RX) as input */
N    PortInit.PORT_OE = PORT_OE_IN;
N    PortInit.PORT_Pin = PORT_Pin_0;
X    PortInit.PORT_Pin = 0x0001U;
N    PORT_Init(MDR_PORTD, &PortInit);
X    PORT_Init(((MDR_PORT_TypeDef *) (0x400C0000)), &PortInit);
N    /* Configure PORTD pins 1 (UART2_TX) as output */
N    PortInit.PORT_OE = PORT_OE_OUT;
N    PortInit.PORT_Pin = PORT_Pin_1;
X    PortInit.PORT_Pin = 0x0002U;
N    PORT_Init(MDR_PORTD, &PortInit); 
X    PORT_Init(((MDR_PORT_TypeDef *) (0x400C0000)), &PortInit); 
N
N
N}
Nvoid MltPinCfg (void)
N{
N
N
N  /* Fill PortInit structure*/
N    PortInit.PORT_PULL_UP   = PORT_PULL_UP_ON;
N    PortInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF;
N    PortInit.PORT_PD_SHM    = PORT_PD_SHM_OFF;
N    PortInit.PORT_PD        = PORT_PD_DRIVER;
N    PortInit.PORT_GFEN      = PORT_GFEN_OFF;
N	
N  /* Configure PORTA pins 2,5 for mlt out data  */
N  PortInit.PORT_Pin   = (PORT_Pin_2 |  PORT_Pin_5);
X  PortInit.PORT_Pin   = (0x0004U |  0x0020U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N  PORT_Init(MDR_PORTA, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400A8000)), &PortInit);
N /* Configure PORTA pins 3 for mlt input  */
N  PortInit.PORT_Pin   = (PORT_Pin_3);
X  PortInit.PORT_Pin   = (0x0008U);
N  PortInit.PORT_OE    = PORT_OE_IN;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N  PORT_Init(MDR_PORTA, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400A8000)), &PortInit);
N
N  /* Configure PORTB pins 9,10 for mlt output  */
N  PortInit.PORT_Pin   = (PORT_Pin_8|PORT_Pin_9 | PORT_Pin_10);
X  PortInit.PORT_Pin   = (0x0100U|0x0200U | 0x0400U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N  PORT_Init(MDR_PORTB, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400B0000)), &PortInit);
N   /* Configure PORTB pins 7 for mlt input */
N  PortInit.PORT_Pin   = (PORT_Pin_7 );
X  PortInit.PORT_Pin   = (0x0080U );
N  PortInit.PORT_OE    = PORT_OE_IN;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N    PORT_Init(MDR_PORTB, &PortInit);
X    PORT_Init(((MDR_PORT_TypeDef *) (0x400B0000)), &PortInit);
N
N  /* Configure PORTC pins 0,2 for mlt output */
N  PortInit.PORT_Pin   = (PORT_Pin_0|PORT_Pin_1);
X  PortInit.PORT_Pin   = (0x0001U|0x0002U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N  PORT_Init(MDR_PORTC, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400B8000)), &PortInit);
N  
N   /* Configure PORTC pins 2 for mlt input */
N  PortInit.PORT_Pin   = (PORT_Pin_2);
X  PortInit.PORT_Pin   = (0x0004U);
N  PortInit.PORT_OE    = PORT_OE_IN;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N  PORT_Init(MDR_PORTC, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400B8000)), &PortInit);
N 
N 
N    /* Configure PORTE pins 6 for mlt output */
N  PortInit.PORT_Pin   = (PORT_Pin_6);
X  PortInit.PORT_Pin   = (0x0040U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N  PORT_Init(MDR_PORTE, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400C8000)), &PortInit);
N   /* Configure PORTE pins 0,1,2,3,7 for mlt input */
N  PortInit.PORT_Pin   = (PORT_Pin_0|PORT_Pin_1|PORT_Pin_2|PORT_Pin_3|PORT_Pin_7);
X  PortInit.PORT_Pin   = (0x0001U|0x0002U|0x0004U|0x0008U|0x0080U);
N  PortInit.PORT_OE    = PORT_OE_IN;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_MAXFAST;
N  PORT_Init(MDR_PORTE, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400C8000)), &PortInit);
N
N}
N
Nvoid LedPinGfg (void)
N{
N  /* Configure PORTA pins 6,7 for output to switch LEDs on/off */
N  PortInit.PORT_Pin   = (PORT_Pin_6 | PORT_Pin_7);
X  PortInit.PORT_Pin   = (0x0040U | 0x0080U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_SLOW;
N
N  PORT_Init(MDR_PORTA, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400A8000)), &PortInit);
N
N    /* Configure PORTB pins 8 for output to switch LEDs on/off */
N  PortInit.PORT_Pin   = (PORT_Pin_8);
X  PortInit.PORT_Pin   = (0x0100U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_SLOW;
N
N  PORT_Init(MDR_PORTB, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400B0000)), &PortInit);
N
N      /* Configure PORTC pins 1 for output to switch LEDs on/off */
N  PortInit.PORT_Pin   = (PORT_Pin_1);
X  PortInit.PORT_Pin   = (0x0002U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_SLOW;
N
N  PORT_Init(MDR_PORTC, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400B8000)), &PortInit);
N}
N
N
Nvoid Uart2Setup(void)
N{
N	unsigned int temp;
N 
N    UART_InitStructure.UART_BaudRate                = 115200;
N    UART_InitStructure.UART_WordLength              = UART_WordLength8b;
X    UART_InitStructure.UART_WordLength              = ((uint16_t)0x0060);
N    UART_InitStructure.UART_StopBits                = UART_StopBits1;
X    UART_InitStructure.UART_StopBits                = ((uint16_t)0x0000);
N    UART_InitStructure.UART_Parity                  = UART_Parity_No;
X    UART_InitStructure.UART_Parity                  = ((uint16_t)0x0000);
N    UART_InitStructure.UART_FIFOMode                = UART_FIFO_OFF;
X    UART_InitStructure.UART_FIFOMode                = ((uint16_t)0x0000);
N    UART_InitStructure.UART_HardwareFlowControl     = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
X    UART_InitStructure.UART_HardwareFlowControl     = ((uint16_t)0x0200) | ((uint16_t)0x0100);
N
N    /* Configure UART2 parameters*/
N    UART_Init (MDR_UART2,&UART_InitStructure);
X    UART_Init (((MDR_UART_TypeDef *) (0x40038000)),&UART_InitStructure);
N      /* Enable Receiver interrupt */
N //   UART_ITConfig (MDR_UART2, UART_IT_RX, ENABLE);
N    /* Enables UART2 peripheral */
N    UART_Cmd(MDR_UART2,ENABLE); 
X    UART_Cmd(((MDR_UART_TypeDef *) (0x40038000)),ENABLE); 
N
N      /* Enable transmitter interrupt (UARTTXINTR) */
N // UART_ITConfig (MDR_UART2, UART_IT_TX, ENABLE);
N
N   /* Enable Receiver interrupt */
N    UART_ITConfig (MDR_UART2, UART_IT_RX, ENABLE);
X    UART_ITConfig (((MDR_UART_TypeDef *) (0x40038000)), ((uint32_t)0x00000010), ENABLE);
N
N}
N
Nvoid Uart1Setup(void)
N{
N	unsigned int temp;
N 
N    UART_InitStructure.UART_BaudRate                = 115200;
N    UART_InitStructure.UART_WordLength              = UART_WordLength8b;
X    UART_InitStructure.UART_WordLength              = ((uint16_t)0x0060);
N    UART_InitStructure.UART_StopBits                = UART_StopBits1;
X    UART_InitStructure.UART_StopBits                = ((uint16_t)0x0000);
N    UART_InitStructure.UART_Parity                  = UART_Parity_No;
X    UART_InitStructure.UART_Parity                  = ((uint16_t)0x0000);
N    UART_InitStructure.UART_FIFOMode                = UART_FIFO_OFF;
X    UART_InitStructure.UART_FIFOMode                = ((uint16_t)0x0000);
N    UART_InitStructure.UART_HardwareFlowControl     = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
X    UART_InitStructure.UART_HardwareFlowControl     = ((uint16_t)0x0200) | ((uint16_t)0x0100);
N
N    /* Configure UART1 parameters*/
N    UART_Init (MDR_UART1,&UART_InitStructure);
X    UART_Init (((MDR_UART_TypeDef *) (0x40030000)),&UART_InitStructure);
N      /* Enable Receiver interrupt */
N //   UART_ITConfig (MDR_UART1, UART_IT_RX, ENABLE);
N    /* Enables UART1 peripheral */
N    UART_Cmd(MDR_UART1,ENABLE); 
X    UART_Cmd(((MDR_UART_TypeDef *) (0x40030000)),ENABLE); 
N
N         /* Enable transmitter interrupt (UARTTXINTR) */
N // UART_ITConfig (MDR_UART1, UART_IT_TX, ENABLE);
N
N   /* Enable Receiver interrupt */
N  UART_ITConfig (MDR_UART1, UART_IT_RX, ENABLE);
X  UART_ITConfig (((MDR_UART_TypeDef *) (0x40030000)), ((uint32_t)0x00000010), ENABLE);
N
N}
N
Nvoid SPI_init(void)
N
N{
N	/* Configure SSP2 pins: FSS, CLK, RXD, TXD */
N  /* Configure PORTD pins  3   */ 
N  PortInit.PORT_Pin   = (PORT_Pin_3);
X  PortInit.PORT_Pin   = (0x0008U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_FAST;
N  PortInit.PORT_PD    = PORT_PD_DRIVER;
N  PORT_Init(MDR_PORTD, &PortInit);	
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400C0000)), &PortInit);	
N
N  /* Configure PORTD pins   5, 6 */
N  PortInit.PORT_Pin   = (PORT_Pin_6 |  PORT_Pin_5);
X  PortInit.PORT_Pin   = (0x0040U |  0x0020U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_ALTER;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_FAST;
N  PortInit.PORT_PD    = PORT_PD_DRIVER;
N  PORT_Init(MDR_PORTD, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400C0000)), &PortInit);
N
N  /* Configure SSP1 pins: FSS, CLK, RXD, TXD */
N
N  /* Configure PORTF pins 0, 1,  3 */
N  PortInit.PORT_Pin   = (PORT_Pin_0 | PORT_Pin_1);
X  PortInit.PORT_Pin   = (0x0001U | 0x0002U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PORT_Init(MDR_PORTF, &PortInit);
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400E8000)), &PortInit);
N
N    /* Configure PORTF pins  2 ,     */
N
N  PortInit.PORT_Pin   = (PORT_Pin_2);
X  PortInit.PORT_Pin   = (0x0004U);
N  PortInit.PORT_OE    = PORT_OE_OUT;
N  PortInit.PORT_FUNC  = PORT_FUNC_PORT;
N  PortInit.PORT_MODE  = PORT_MODE_DIGITAL;
N  PortInit.PORT_SPEED = PORT_SPEED_FAST;
N  PortInit.PORT_PD    = PORT_PD_DRIVER;
N  PORT_Init(MDR_PORTF, &PortInit);	
X  PORT_Init(((MDR_PORT_TypeDef *) (0x400E8000)), &PortInit);	
N
N  SSP_BRGInit(MDR_SSP1,SSP_HCLKdiv16);
X  SSP_BRGInit(((MDR_SSP_TypeDef *) (0x40040000)),((uint32_t)0x00000004));
N  SSP_BRGInit(MDR_SSP2,SSP_HCLKdiv16);
X  SSP_BRGInit(((MDR_SSP_TypeDef *) (0x400A0000)),((uint32_t)0x00000004));
N
N  /* SSP1 MASTER configuration ------------------------------------------------*/
N  SSP_StructInit (&sSSP);
N
N  sSSP.SSP_SCR  = 0xff; /*!< This member configures the SSP communication speed.
N                                                This parameter is number from 0 to 255.
N                                                The information rate is computed using the following formula:
N                                                F_SSPCLK / ( CPSDVR * (1 + SCR) ) */
N  sSSP.SSP_CPSDVSR = 16;/*!< This member configures the SSP clock divider.
N                                                This parameter is an even number from 2 to 254 */
N  sSSP.SSP_Mode = SSP_ModeMaster;
X  sSSP.SSP_Mode = ((uint32_t)0x0000);
N  sSSP.SSP_WordLength = SSP_WordLength16b;
X  sSSP.SSP_WordLength = ((uint16_t)0x000F);
N  sSSP.SSP_SPH = SSP_SPH_2Edge;
X  sSSP.SSP_SPH = ((uint16_t)0x0080);
N  sSSP.SSP_SPO = SSP_SPO_High;
X  sSSP.SSP_SPO = ((uint16_t)0x0040);
N  sSSP.SSP_FRF = SSP_FRF_SPI_Motorola;
X  sSSP.SSP_FRF = ((uint16_t)0x0000);
N  sSSP.SSP_HardwareFlowControl = SSP_HardwareFlowControl_None;
X  sSSP.SSP_HardwareFlowControl = ((uint16_t)0x0000);
N  SSP_Init (MDR_SSP1,&sSSP);
X  SSP_Init (((MDR_SSP_TypeDef *) (0x40040000)),&sSSP);
N
N  /* SSP2 MASTER configuration ------------------------------------------------*/
N  
N  sSSP.SSP_SCR  = 0xff;
N  sSSP.SSP_CPSDVSR = 16;
N  sSSP.SSP_Mode = SSP_ModeMaster;
X  sSSP.SSP_Mode = ((uint32_t)0x0000);
N  sSSP.SSP_WordLength = SSP_WordLength16b;
X  sSSP.SSP_WordLength = ((uint16_t)0x000F);
N  sSSP.SSP_SPH = SSP_SPH_2Edge;
X  sSSP.SSP_SPH = ((uint16_t)0x0080);
N  sSSP.SSP_SPO = SSP_SPO_High;
X  sSSP.SSP_SPO = ((uint16_t)0x0040);
N  sSSP.SSP_FRF = SSP_FRF_SPI_Motorola;
X  sSSP.SSP_FRF = ((uint16_t)0x0000);
N  sSSP.SSP_HardwareFlowControl = SSP_HardwareFlowControl_None;
X  sSSP.SSP_HardwareFlowControl = ((uint16_t)0x0000);
N  SSP_Init (MDR_SSP2,&sSSP);
X  SSP_Init (((MDR_SSP_TypeDef *) (0x400A0000)),&sSSP);
N
N  /* Enable SSP1 */
N  SSP_Cmd(MDR_SSP1, ENABLE);
X  SSP_Cmd(((MDR_SSP_TypeDef *) (0x40040000)), ENABLE);
N  /* Enable SSP2 */
N  SSP_Cmd(MDR_SSP2, ENABLE);
X  SSP_Cmd(((MDR_SSP_TypeDef *) (0x400A0000)), ENABLE);
N
N}
N
N
N//===============================================================
Nvoid delay(int inc)
N{
N//---------------------------------------------------------------
N   inc <<= 3;
N   while(inc !=0) inc--;
N//---------------------------------------------------------------
N}
N
N
N
Nvoid CS_SPI1 (char a)
N{
N   while (SSP_GetFlagStatus(MDR_SSP1, SSP_FLAG_BSY) == SET) {};
X   while (SSP_GetFlagStatus(((MDR_SSP_TypeDef *) (0x40040000)), ((uint16_t)0x0010)) == SET) {};
N
N  if (a==1)
N  {
N    delay(300);
N    PORT_SetBits  (MDR_PORTF, PORT_Pin_2);
X    PORT_SetBits  (((MDR_PORT_TypeDef *) (0x400E8000)), 0x0004U);
N    delay(300);
N  }
N
N  if (a==0)
N  {
N    delay(300);
N    PORT_ResetBits (MDR_PORTF, PORT_Pin_2);
X    PORT_ResetBits (((MDR_PORT_TypeDef *) (0x400E8000)), 0x0004U);
N    delay(300);
N  }
N
N}     
N
Nvoid CS_SPI2 (char a)
N{
N
N  while (SSP_GetFlagStatus(MDR_SSP2, SSP_FLAG_BSY) == SET) {};
X  while (SSP_GetFlagStatus(((MDR_SSP_TypeDef *) (0x400A0000)), ((uint16_t)0x0010)) == SET) {};
N
N  if (a==1)
N  {
N    delay(300);
N    PORT_SetBits  (MDR_PORTD, PORT_Pin_3);
X    PORT_SetBits  (((MDR_PORT_TypeDef *) (0x400C0000)), 0x0008U);
N    delay(300);
N  }
N
N  if (a==0)
N  {
N    delay(300);
N    PORT_ResetBits (MDR_PORTD, PORT_Pin_3);
X    PORT_ResetBits (((MDR_PORT_TypeDef *) (0x400C0000)), 0x0008U);
N    delay(300);
N  }
N
N}                 
N
Nvoid SPI1_send(u16 a)
Xvoid SPI1_send(unsigned short a)
N{
N	/* Wait for SPI1 Tx buffer empty */
N    while (SSP_GetFlagStatus(MDR_SSP1, SSP_FLAG_TFE) == RESET)
X    while (SSP_GetFlagStatus(((MDR_SSP_TypeDef *) (0x40040000)), ((uint16_t)0x0001)) == RESET)
N    {
N    }
N    /* Send SPI1 data */
N    SSP_SendData(MDR_SSP1,a);
X    SSP_SendData(((MDR_SSP_TypeDef *) (0x40040000)),a);
N}
N
Nvoid SPI2_send(u16 a)
Xvoid SPI2_send(unsigned short a)
N{
N	/* Wait for SPI2 Tx buffer empty */
N    while (SSP_GetFlagStatus(MDR_SSP2, SSP_FLAG_TFE) == RESET)
X    while (SSP_GetFlagStatus(((MDR_SSP_TypeDef *) (0x400A0000)), ((uint16_t)0x0001)) == RESET)
N    {
N    }
N    /* Send SPI2 data */
N    SSP_SendData(MDR_SSP2,a);
X    SSP_SendData(((MDR_SSP_TypeDef *) (0x400A0000)),a);
N}
N
Nu16 SPI1_read(void)
Xunsigned short SPI1_read(void)
N{
N	u16 a;
X	unsigned short a;
N	/* Wait for SPI1 data reception */
N    while (SSP_GetFlagStatus(MDR_SSP1, SSP_FLAG_RNE) == RESET)
X    while (SSP_GetFlagStatus(((MDR_SSP_TypeDef *) (0x40040000)), ((uint16_t)0x0004)) == RESET)
N    {
N    }
N    /* Read SPI1 received data */
N    a = SSP_ReceiveData(MDR_SSP1);
X    a = SSP_ReceiveData(((MDR_SSP_TypeDef *) (0x40040000)));
N    return a;
N}
N
Nu16 SPI2_read(void)
Xunsigned short SPI2_read(void)
N{
N	u16 a;
X	unsigned short a;
N	/* Wait for SPI2 data reception */
N    while (SSP_GetFlagStatus(MDR_SSP2, SSP_FLAG_RNE) == RESET)
X    while (SSP_GetFlagStatus(((MDR_SSP_TypeDef *) (0x400A0000)), ((uint16_t)0x0004)) == RESET)
N    {
N    }
N    /* Read SPI2 received data */
N    a = SSP_ReceiveData(MDR_SSP2);
X    a = SSP_ReceiveData(((MDR_SSP_TypeDef *) (0x400A0000)));
N    return a;
N}
N
N
N//===============================================================
N
Nvoid RegisterInits () 
N{ 
N  /* Set RST_CLK to default */
N //   RST_CLK_DeInit();
N   
N RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP,ENABLE);
X RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400D8000)) >> 15) & 0x1F))),ENABLE);
N
N// 3. CPU_CLK = 7*HSE/2 clock 
N   
N    //Enable HSE clock source 
N     RST_CLK_HSEconfig(RST_CLK_HSE_ON);
X     RST_CLK_HSEconfig(((uint32_t)0x00000001));
N
N     while (RST_CLK_HSEstatus() != SUCCESS)  {}; // Good HSE clock 
N
N     // Select HSE clock as CPU_PLL input clock source
N     // Set PLL multiplier to 7                       
N     RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv1, 5);
X     RST_CLK_CPU_PLLconfig(((uint32_t)0x00000002), 5);
N
N      // Enable CPU_PLL 
N     RST_CLK_CPU_PLLcmd(ENABLE);
N
N     while (RST_CLK_HSEstatus() != SUCCESS)    {}; //Good CPU PLL 
N
N       // Set CPU_C3_prescaler to 2 
N        RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV2);
X        RST_CLK_CPUclkPrescaler(((uint32_t)0x00000008));
N        // Set CPU_C2_SEL to CPU_PLL output instead of CPU_C1 clock 
N        RST_CLK_CPU_PLLuse(ENABLE);
N        // Select CPU_C3 clock on the CPU clock MUX 
N        RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
X        RST_CLK_CPUclkSelection(((uint32_t)0x00000100));
N
N     RST_CLK_PCLKcmd(RST_CLK_PCLK_RST_CLK,ENABLE);
X     RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x40020000)) >> 15) & 0x1F))),ENABLE);
N	 RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTA,ENABLE);
X	 RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400A8000)) >> 15) & 0x1F))),ENABLE);
N	 RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTB,ENABLE);
X	 RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400B0000)) >> 15) & 0x1F))),ENABLE);
N	 RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC,ENABLE);
X	 RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400B8000)) >> 15) & 0x1F))),ENABLE);
N	 RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTD,ENABLE); 
X	 RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400C0000)) >> 15) & 0x1F))),ENABLE); 
N	 RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTE,ENABLE);
X	 RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400C8000)) >> 15) & 0x1F))),ENABLE);
N     RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTF,ENABLE);
X     RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400E8000)) >> 15) & 0x1F))),ENABLE);
N
N//Enables SPI
N	RST_CLK_PCLKcmd(RST_CLK_PCLK_SSP1,ENABLE);
X	RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x40040000)) >> 15) & 0x1F))),ENABLE);
N	RST_CLK_PCLKcmd(RST_CLK_PCLK_SSP2,ENABLE);
X	RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x400A0000)) >> 15) & 0x1F))),ENABLE);
N
N /* Enables the CPU_CLK clock on UART1,UART2 */
N     RST_CLK_PCLKcmd(RST_CLK_PCLK_UART1, ENABLE);
X     RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x40030000)) >> 15) & 0x1F))), ENABLE);
N     RST_CLK_PCLKcmd(RST_CLK_PCLK_UART2, ENABLE);
X     RST_CLK_PCLKcmd(((uint32_t)(1 << ((((uint32_t)(0x40038000)) >> 15) & 0x1F))), ENABLE);
N
N// Set the HCLK division factor = 1 for UART1,UART2 
N    UART_BRGInit(MDR_UART1, UART_HCLKdiv1);
X    UART_BRGInit(((MDR_UART_TypeDef *) (0x40030000)), ((uint32_t)0x00000000));
N    UART_BRGInit(MDR_UART2, UART_HCLKdiv1);
X    UART_BRGInit(((MDR_UART_TypeDef *) (0x40038000)), ((uint32_t)0x00000000));
N
N  NVIC_EnableIRQ(UART1_IRQn);
N  NVIC_EnableIRQ(UART2_IRQn);
N
N
N}
N
N void TX_485 (void)
N{
N	RE_485_1;
X	PORT_SetBits (((MDR_PORT_TypeDef *) (0x400A8000)), 0x0004U);
N	DE_485_1;
X	PORT_SetBits (((MDR_PORT_TypeDef *) (0x400B8000)), 0x0001U);
N}
N
Nvoid RX_485 (void)
N{
N	RE_485_0;
X	PORT_ResetBits(((MDR_PORT_TypeDef *) (0x400A8000)), 0x0004U);
N	DE_485_0;
X	PORT_ResetBits(((MDR_PORT_TypeDef *) (0x400B8000)), 0x0001U);
N}
N
N
Nvoid zputc ( uint8_t c) 
N{
N  uint8_t DataByte;
N
N  DataByte=c;
N
N    /* Check TXFE flag */
N    while (UART_GetFlagStatus (MDR_UART1, UART_FLAG_TXFE)!= SET)   {};
X    while (UART_GetFlagStatus (((MDR_UART_TypeDef *) (0x40030000)), ((uint32_t)0x00000080))!= SET)   {};
N   /* Send Data from UART1 */
N    UART_SendData (MDR_UART1,DataByte);
X    UART_SendData (((MDR_UART_TypeDef *) (0x40030000)),DataByte);
N
N}
N
N
Nvoid zputc2 ( uint8_t c) 
N{
N  uint8_t DataByte;
N
N  DataByte=c;
N
N    /* Check TXFE flag */
N    while (UART_GetFlagStatus (MDR_UART2, UART_FLAG_TXFE)!= SET)   {};
X    while (UART_GetFlagStatus (((MDR_UART_TypeDef *) (0x40038000)), ((uint32_t)0x00000080))!= SET)   {};
N   /* Send Data from UART2 */
N    UART_SendData (MDR_UART2,DataByte);
X    UART_SendData (((MDR_UART_TypeDef *) (0x40038000)),DataByte);
N
N}
N
N
N void zputs( char s[], unsigned char l)
N{
N    unsigned char i=0;
N         char c[64];
N	
N      for (i=0;i<l;i++) 
N        {
N            c[i]=s[i];
N         zputc (c[i]);
N        }
N
N}
N
N void zputs2( char s[], unsigned char l)
N{
N      unsigned char i=0;
N               char c[64];
N
N      for (i=0;i<l;i++) 
N        {
N             c[i]=s[i];
N         zputc2 (c[i]);
N        }
N }
N
Nunsigned int leng ( char s[])
N
N  {
N    unsigned  char i=0;
N     while ((s[i]!='\0')&&(i<120)) { i++;}
N    return i;
N  }
N
Nvoid sendT ( char  s[])
N
N { 
N   zputs(s,leng(s));
N }
N
Nvoid sendT2 ( char s[])
N
N {
N    zputs2(s,leng(s));
N
N }
N
N
N
N
N  // reverse: 
N void reverse( char s[])
N {
N     int i, j;
N     char c;
N 
N     for (i = 0, j = strlen(s)-1; i<j; i++, j--) {
N         c = s[i];
N         s[i] = s[j];
N         s[j] = c;
N     }
N }
N
N
N void itoa(int n, char s[])
N {
N     int i, sign;
N 
N     if ((sign = n) < 0)  
N         n = -n;         
N     i = 0;
N     do {       
N         s[i++] = n % 10 + '0';   
N     } while ((n /= 10) > 0);    
N     if (sign < 0)
N         s[i++] = '-';
N     s[i] = '\0';
N     reverse(s);
N }
N
N
N//----------------------------------------
N
N void Transf( char s[]) 
N   {
N         sendT(s);    //uart1
N        sendT2(s);   //uart2
N    }
N   
N
N void ZTransf( char s[],unsigned char a) 
N   {
N      zputs (s,a);
N      zputs2(s,a);
N    }
N      
N
N
Nvoid fillBuf ( char* ptrBuf, unsigned short lengthBuf, unsigned char symb )
N   { unsigned short i;
N
N     for ( i=0; i < lengthBuf; i++ )
N      {
N        *ptrBuf=symb; ptrBuf++;
N      }
N   }
N
N  void clearBuf ( char* ptrBuf, unsigned short lengthBuf )
N   {  fillBuf( ptrBuf, lengthBuf, ' ' );
N   }
N      
N
N   int getStr (  char* s, unsigned char*ps_size )
N    { unsigned char* temp;
N      temp=pRcv_Buf;
N      *ps_size=0;
N      if ( pcur_Rcv <  temp ){
N        
N   
N        //*ps_size=temp-pcur_Rcv;
N        *ps_size=1;
N        while(pcur_Rcv <  temp)
N          {*s=*pcur_Rcv; s++; pcur_Rcv++;}
N         
N        }
N       else if  ( temp < pcur_Rcv )
N              {  
N              
N                if  ( CyclEnd_flag )
N                    { while ( pcur_Rcv != temp )
N                        {*s = *pcur_Rcv; s++;
N                         *ps_size++;
N                         if ( pcur_Rcv == (RcvBuf+ buf_size-1) )
X                         if ( pcur_Rcv == (RcvBuf+ 256-1) )
N                           { pcur_Rcv= RcvBuf;
N                             CyclEnd_flag=0;  
N                           }
N                          else
N                            pcur_Rcv++;
N                        }
N                    }
N                  else
N                   {; 
N                    return 1;
N                   }
N              }
N  
N       else  
N                            return 1;       
N   
N      return 0;
N    }
N
N
N//--------------------------------
N
N
N//--- Terminal configuration ---
Nvoid Menu()
N
N{
N
N}
N
N
Nvoid Menu1()
N 
N {
N//***************************************************************************
N
N    int i;
N	
N 
N    for (i=0; i< 3; i++) Transf("\r");    //  
N	for (i=0; i<15; i++) Transf ("*");  //  
N	
N	Transf("\r");
N	Transf("\r");
N	Transf("\r");
N	Transf("\r");
N	Transf("......Terminal -1 -12....\r");
N	Transf("\r");
N	Transf("\r");
N	Transf("\r");
N	Transf("MENU :\r");
N	Transf("-------\r");
N	Transf("~ -  \r");
N	Transf("1 -  \r");
N	Transf("start_TCP -  \r");
N	Transf("=30000000 -  \r");
N	Transf(";-   \r");
N	Transf(".............. \r");
N	Transf(": \r");
N	Transf("1 - 1-6xx   ,  : \r");
N	Transf("2 - 1-6xx-1 ,  \r");
N	Transf("3 - 1-6xx ,     \r");
N	Transf("4 - 1-6xx ,     \r");
N	Transf("6 - 1-6xx ,   \r");
N	Transf("+++++++++++++++++++\r");
N	Transf("~1 watch_reg_1;\r");
N	Transf("~1 watch_reg_2;\r");
N	/*
N	sendT("~1 id_dds;\r\n");
N	sendT("~1 wrn_dds_1;\r\n");
N	sendT("~1 wrn_dds_0;\r\n");
N	sendT("~1 init_dds;\r\n");
N	sendT("~1 rd_dds;\r\n");
N	sendT("~1 wr_dds=1;\r\n");
N	sendT("~1 rd_tst;\r\n");
N	sendT("~1 wr_tst=1;\r\n");
N	*/
N  
N	Transf("~1 1_Kdiv1();\r");
N	Transf("~1 2_Kdiv1();\r");
N
N	Transf("~1 1_Kdiv2();\r");
N	Transf("~1 2_Kdiv2();\r");
N
N	Transf("~1 help;\r");
N	Transf("~1 SPI_send():0x55;\r");
N	
N	/*
N	sendT("~1 config_Ethernet;\r\n");
N	sendT("~1 ;\r\n");
N	sendT("~1 ;\r\n");
N	sendT("~1 ;\r\n");
N	sendT("~1 UDP_TCP_test;\r\n");
N	sendT("~1 ;\r\n");
N	sendT("~1 PPI__612;\r\n");
N	sendT("~1 PPI__613;\r\n");
N	*/
N	
N	Transf("~1 1_init;\r");
N	Transf("~1 2_init;\r");
N	Transf("~1 _;\r");
N
N	Transf("~1 __;\r");
N	/*
N	sendT("~1 __UP;\r\n");
N	sendT("~1 __DOWN;\r\n");
N	*/
N	Transf("~1 _=0;\r");
N	/*
N	sendT("~1 _F0=60000000;\r\n");
N	sendT("~1 _;\r\n");
N	sendT("~1 __F=100;\r\n");
N	sendT("~1 __T=100;\r\n");
N	sendT("~1 __F_low=430000000;\r\n");
N	sendT("~1 __F_high=440000000;\r\n");
N	*/
N	/*
N	sendT("~3 __=100000;\r\n");
N	sendT("~3 __=100000;\r\n");
N	sendT("~3 __;\r\n");
N	sendT("~3 __;\r\n");
N	sendT("~3 __;\r\n");
N	sendT("~3 __;\r\n");
N	sendT("~1 __ON;\r\n");
N	sendT("~1 __OFF;\r\n");
N	sendT("~1 SPORT_data;\r\n");
N	sendT("~3 _;\r\n");
N    sendT("~3 _;\r\n");
N */
N /*
N    sendT("~6 F64(on);\r\n");
N    sendT("~6 F64(off);\r\n");
N    sendT("~6 F160(on);\r\n");
N    sendT("~6 F160(off);\r\n"); 
N    sendT("~6 F360(on);\r\n");
N    sendT("~6 F360(off);\r\n");
N    sendT("~6 F400(on);\r\n");
N    sendT("~6 F400(off);\r\n");   
N  */
N  
N    Transf("~1 ADC=1;   ADC \r");
N  /*sendT("~6 _;\r\n");  
N    sendT("~6 _;\r\n");
N    sendT("~6 _;\r\n");
N	sendT("~6 init_K611;\r\n");
N	sendT("~1 K611;\r\n");
N	sendT("~5 INPORT:xxxxxx;\r\n");
N	sendT("~5 OUTPORT:xxxxxx;\r\n");
N	*/
N	Transf("\r");
N	Transf("\r");
N	Transf("++++++++++++++++++++\r\n");
N	Transf("\r");
N	Transf("\r");
N	//for (i=0; i<64; i++) zputs ("*",1);  //  
N	//for (i=0;i<10;i++) puts("\r",1);  //  
N	sendT("\r");
N	//*******************************************************************************
N	
N	}
N
Nvoid reg_FAPCH_watch (reg_1508pl10 a)
N{
N  Transf ("   :");
N
N  if (a.Name[4]=='1') Transf ("1\r");
N  if (a.Name[4]=='2') Transf ("2\r");
N  Transf("\r");
N
N}
N
Nvoid Kdiv1(unsigned int dFo1,reg_1508pl10 *a)
N{
N
N   Transf("\r");
N   Transf ("..  Kdiv1:");
N   sprintf(strng,"%d",dFo1);
N   Transf(strng);
N   Transf("\r");
N
N  if (a->Name[4]=='1') Transf ("1\r");
N  if (a->Name[4]=='2') Transf ("2\r");
N  Transf("\r");
N
N       if (dFo1==10)  {
N                        a->KREF4=0;
N                        a->KREF3=0;
N                      } else
N                                
N       if (dFo1==80)  {
N                        a->KREF4=0;
N                        a->KREF3=1;
N                      } else
N       if (dFo1==100) {
N                        a->KREF4=1;
N                        a->KREF3=0;
N                      } else
N       if (dFo1==125) {
N                        a->KREF4=1;
N                        a->KREF3=1;
N                      } else Transf ("..Kdiv1 -   !!!...\r");
N                                           
N Transf("\r");
N
N}
N
Nvoid Kdiv2(unsigned int dFo1,reg_1508pl10 *a)
N{
N   Transf("\r");
N   Transf ("..  Kdiv2:");
N   sprintf(strng,"%d",dFo1);
N   Transf(strng);
N   Transf("\r");
N   
N  if (a->Name[4]=='1') Transf ("1\r");
N  if (a->Name[4]=='2') Transf ("2\r");
N  Transf("\r");
N
N
N       if (dFo1==160)  {
N                        a->KREF2=0;
N                        a->KREF1=0;
N                        a->KREF0=0;
N                                           } else
N                                
N       if (dFo1== 80)  {
N                        a->KREF2=0;
N                        a->KREF1=0;
N                        a->KREF0=1;
N                                           } else
N       if (dFo1== 40) {
N                        a->KREF2=0;
N                        a->KREF1=1;
N                        a->KREF0=0;
N                                           } else
N       if (dFo1== 20) {
N                        a->KREF2=0;
N                        a->KREF1=1;
N                        a->KREF0=1;
N                                           } else
N       if (dFo1==200) {
N                        a->KREF2=1;
N                        a->KREF1=0;
N                        a->KREF0=0;
N                                           } else
N
N       if (dFo1==100) {
N                        a->KREF2=1;
N                        a->KREF1=0;
N                        a->KREF0=1;
N                                           } else
N       if (dFo1==50) {
N                        a->KREF2=1;
N                        a->KREF1=1;
N                        a->KREF0=0;
N                                           } else
N       if (dFo1==10) {
N                        a->KREF2=1;
N                        a->KREF1=1;
N                        a->KREF0=1;
N                                           } else Transf ("..Kdiv2 -   !!!...\r");
N
N        // Kdiv1(10,a); 
N//------------  dFo1>200 --------------------- 
N
N
N}
N
N
Nvoid Kdiv3(unsigned int dFo1,reg_1508pl10 *a)
N{
N   Transf("\r");
N   Transf ("..  Kdiv3:");
N   sprintf(strng,"%d",dFo1);
N   Transf(strng);
N   Transf("\r");
N   
N  if (a->Name[4]=='1') Transf ("1\r");
N  if (a->Name[4]=='2') Transf ("2\r");
N  Transf("\r");
N
N   a->Kosn00_15 =  dFo1;     // 16     
N   a->Kosn16_19 = (dFo1>>16);// 4-     
N
N}
N
N
Nchar Sys_indikate(void)
N
N{
N  char a=0;
N  unsigned char cond=0;
N
N
N}
N
Nvoid Otvet_3(void)
N{
N   otvet_flag=0;
N				 
N   TX_485();
N   Transf("\r");
N   Transf ("~1 _611:");
N   sprintf(s3,"%d",flag_status_ZAHVAT);
N   Transf(s3);
N   Transf(".");
N   sprintf(s3,"%d",flag_status_ZAHVAT);
N   Transf(s3);
N   Transf(";");
N   Transf("\r");
N   RX_485();
N 
N}
N
N
Nvoid IO ( char* sr)      //    
N 
N {
N       
N unsigned char s[6];   
N unsigned char i=0;
N unsigned char index=0;
N unsigned char dlsr=0;
N  char z;
N  char p[1];
N  unsigned char  z_k611=0;
N  char sys_char=0;
N  int l=0;
N
N  unsigned short PF1_var=0;
N  unsigned short PF2_var=0;
N  unsigned short PF3_var=0;
N  unsigned short PF4_var=0;
N  unsigned int Z_sum=0;
N  unsigned short temp_short=0;
N  
N  
N   i=leng (sr);
N     
N   sym1=sr[0];
N   
N   p[0]=sym1;
N      
Nif ((sym1==0x7e)||(time_uart>100)) 
N	{
N		time_uart=0;  //   
N		packet_flag=1; 
N		index1=0; 
N		crc=0; 
N		crc_ok=0; 
N		packet_ok=0; 
N		index_word=0; 
N		index_data_word =1;
N    index_data_word2=1;
N		data_flag =0;
N    data_flag2=0;
N		DATA_Word [0]=' ';
N    DATA_Word2[0]=' ';
N		
N	} //   
N
Nif (packet_flag==1)
N
N{ 
N
N	while (i>0)   //     
N	
N	{
N
N
N	   InOut[index1]=sr[index];
N	   sr[index]=0x0;
N	  
N	  if  (InOut[index1]==' ')  ink1=ink1+1;
N	  
N	  if  (InOut[index1]==';')  packet_ok=1;
N	  
N	  if ((InOut[index1]=='=')||(InOut[index1]==':')) data_flag=1;
N
N    if  (InOut[index1]=='.') data_flag2=1;
N
N
N        	  if ((index1>2)&&(InOut[2]==' '))  
N        		{
N        		
N                		         if  ((InOut[index1]!=' ')&&
N                                 (InOut[index1]!=';')&&
N                                 (data_flag!=1))	       Word[index_word]=InOut[index1]; //   
N                		
N                   
N                        	   if  ((data_flag==1)&&
N                                 (InOut[index1]!=' ')&&
N                                 (InOut[index1]!=';')&&
N                                 (InOut[index1]!='=')&&
N                                 (InOut[index1]!=':')&&(data_flag2==0))    	DATA_Word[index_data_word]=InOut[index1]; //    1
N                      
N                   
N                             if  ((data_flag==1)&&
N                                 (InOut[index1]!=' ')&&
N                                 (InOut[index1]!=';')&&
N                                 (InOut[index1]!='=')&&
N                                 (InOut[index1]!=':')&&(data_flag2==1))     DATA_Word2[index_data_word2]=InOut[index1]; //    2
N                		      
N                	   
N                             if ((data_flag!=1)&&
N                                 (InOut[index1]!='=')&&
N                                 (InOut[index1]!=':'))      index_word=index_word+1; 
N                            		   else 
N                                            {
N                                             
N                                             if ((data_flag==1)&&
N                                                 (InOut[index1]!='=')&&
N                                                 (InOut[index1]!=':')&&
N                                                 (InOut[index1]!='.')&&
N                                                 (data_flag2==0))      index_data_word=index_data_word+1;
N                                            
N                                             if ((data_flag==1)&&
N                                                 (InOut[index1]!='=')&&
N                                                 (InOut[index1]!=':')&&
N                                                 (InOut[index1]!='.')&&
N                                                 (data_flag2==1))      index_data_word2=index_data_word2+1;
N                                            }
N        	  	           
N        		}
N				
N        		index1=index1+1;
N        		index =index +1;
N        		i=i-1;
N	
N	   }
N	
N	i=index1;
N
N	
N	
Nif (packet_ok==1) 
N	{
N
N	
N	    if (InOut[0]==0x7e)   crc_ok=crc_ok|0x1;   //     -  
N	  	if (InOut[1]==Adress) crc_ok=crc_ok|0x2;   //     -  
N		
N	if (crc_ok==0x3)  //      
N    	{
N
N
N                    					if (strcmp(Word,"help")==0)        				      
N
N                    			          {
N                    			             Transf (" help\r"    ); 
N                    			              Menu1('t');
N                    			             flag_uart_trcv=0;
N                    			             sch_pachek_test=1;
N                    			           }
N
N   
N                              if (strcmp(Word,"watch_reg_1"  )==0)       { Transf (" watch_reg_1\r"  ); reg_FAPCH_watch (reg_FAPCH1); }//       
N					 		  if (strcmp(Word,"watch_reg_2"  )==0)       { Transf (" watch_reg_2\r"  ); reg_FAPCH_watch (reg_FAPCH2); }//       
N
N                  			  if (strcmp(Word,"ADC"      )==0) 	    //    // ADC 
N                                    				{ 	dFo1=atoi(DATA_Word);
N                  								           	Transf (" ADC:" );
N                                    					    sprintf(strng,"%x",dFo1);
N															Transf(strng);
N															Transf("\r\n");
N                  									             //ADC_test(dFo1);
N                  									
N                                    					 }
N	
N                            if (strcmp(Word,"_"      )==0) 	    //  F0 
N                        				{ 	dFo1=atoi(DATA_Word);
N      									        Transf (" _:" );
N                        				        sprintf(strng,"%x",dFo1);
N												Transf(strng);
N												Transf("\r");
N												sendT(strng);
N												Transf("\r");
N												sendT2(strng);
N                        					    Transf("\r");
N      									
N                        				}   
N
N                        		if (strcmp(Word,"SPI_send()"      )==0) 	    //  F0 
N                        				{ 	dFo1=atoi(DATA_Word);
N      								          Transf (" SPI_send():" );
N                        				      sprintf(strng,"%x",dFo1);
N                        					  Transf(strng);
N                        					  Transf("\r");
N
N                        					SPI1_send(dFo1);
N                        					SPI2_send(dFo1);
N      									
N                        				}   
N
N                             if (strcmp(Word,"1_Kdiv1()"      )==0)       //  F0 
N                                  {   dFo1=atoi(DATA_Word);
N                                      Transf (" 1_Kdiv1():" );
N                                      sprintf(strng,"%d",dFo1);
N                                      Transf(strng);
N                                      Transf("\r");
N
N                                      Kdiv1(dFo1,&reg_FAPCH1);
N                                      Write_FOCH1 (reg_FAPCH1);
N                          
N                                     } 
N                             if (strcmp(Word,"2_Kdiv1()"      )==0)       //  F0 
N                                  {   dFo1=atoi(DATA_Word);
N                                      Transf (" 2_Kdiv1():" );
N                                      sprintf(strng,"%d",dFo1);
N                                      Transf(strng);
N                                      Transf("\r");
N
N                                      Kdiv1(dFo1,&reg_FAPCH2);
N                                      Write_FOCH2 (reg_FAPCH2);
N                          
N                                     } 
N                          if (strcmp(Word,"1_Kdiv2()"      )==0)       //  F0 
N                                  {   dFo1=atoi(DATA_Word);
N                                      Transf (" 1_Kdiv2():" );
N                                      sprintf(strng,"%d",dFo1);
N                                      Transf(strng);
N                                      Transf("\r");
N
N                                      Kdiv2(dFo1,&reg_FAPCH1);
N                                      Write_FOCH1 (reg_FAPCH1);
N                          
N                                     } 
N                        if (strcmp(Word,"2_Kdiv2()"      )==0)       //  F0 
N                                  {   dFo1=atoi(DATA_Word);
N                                      Transf (" 2_Kdiv2():" );
N                                      sprintf(strng,"%d",dFo1);
N                                      Transf(strng);
N                                      Transf("\r");
N
N                                      Kdiv2(dFo1,&reg_FAPCH2);
N                                      Write_FOCH2 (reg_FAPCH2);
N                          
N                                     } 
N
N                        if (strcmp(Word,"1_Kdiv3()"      )==0)       //  F0 
N                                  {   dFo1=atoi(DATA_Word);
N                                      Transf (" 1_Kdiv3():" );
N                                      sprintf(strng,"%d",dFo1);
N                                      Transf(strng);
N                                      Transf("\r");
N
N                                      Kdiv3(dFo1,&reg_FAPCH1);
N                                      Write_FOCH1 (reg_FAPCH1);
N                          
N                                     } 
N                        if (strcmp(Word,"2_Kdiv3()"      )==0)       //  F0 
N                                  {   dFo1=atoi(DATA_Word);
N                                      Transf (" 2_Kdiv3():" );
N                                      sprintf(strng,"%d",dFo1);
N                                      Transf(strng);
N                                      Transf("\r");
N
N                                      Kdiv3(dFo1,&reg_FAPCH2);
N                                      Write_FOCH2 (reg_FAPCH2);
N                          
N                                     }  
N						if (strcmp(Word,"LD_control")==0)      
N                                    { 
N                                      Transf (" LD_control\r"   );
N
N                                      if (flag_status_ZAHVAT==0x00) Transf (" \r" );
N                                      if (flag_status_ZAHVAT==0x01) Transf (" \r" );
N                                      if (flag_status_ZAHVAT==0x02) Transf (" \r" );
N                                      if (flag_status_ZAHVAT==0x03) Transf ("  \r" );
N
N                                      Transf ("LD_control():" );
N                                      sprintf(strng,"%d",flag_status_ZAHVAT);
N                                      Transf(strng);
N                                      Transf("\r");
N									  
N									  Otvet_3();
N
N                                    }; 
N									 
N
N                  	    if (strcmp(Word,"1_init")==0)      { Transf (" 1_init\r"   ); Write_FOCH1 (reg_FAPCH1);    };	
N                  	    if (strcmp(Word,"2_init")==0)      { Transf (" 2_init\r"   ); Write_FOCH2 (reg_FAPCH2);    };
N					    if (strcmp(Word,"_init")==0)        { Transf (" _init\r"       ); FLAG_INIT_FOCH=0;  };
N						
N
N                 	    if (strcmp(Word,"__")==0)      { Transf (" __\r"   );     }		   
N                        if (strcmp(Word,"_"		     )==0)      { Transf (" _\r"        		 );     }
N             
N						
N                        if (strcmp(Word,"__1-611" )==0) 	   //    611
N                  				{ 
N                                  crc_comp =atoi(DATA_Word);
N                                  crc_input=atoi(DATA_Word2);  
N
N                             if (crc_comp==crc_input)
N                                 {
N                                        z_k611=atoi(DATA_Word);
N
N                                   //     Transf (" __1-611:" );
N                                  //      ZTransf (DATA_Word,index_data_word-1);
N                                  //      Transf("\r\n");
N
N                                        //control_zahvat_K611(z_k611);
N                                         Flag_zahvat_end_K611=1;
N                                         tick_process=0;
N                                        // Flag_K611=0;
N                                         sch_obmen=0;
N
N                                 }
N
N                          
N                  					}	
N                  					
N                  		if (strcmp(Word,"__1-611" )==0) 	   //    611
N                  				{ 
N
N                                  crc_comp =atoi(DATA_Word);
N                                  crc_input=atoi(DATA_Word2); 
N
N                             if (crc_comp==crc_input)
N                                 {
N                                       z_k611=atoi(DATA_Word);
N                            			//	   Transf (" __1-611:" );
N                            			//  	 ZTransf (DATA_Word,index_data_word-1);
N                                 //      Transf("\r\n");
N                                      // control_level_K611(z_k611);
N                            				   Flag_control_end_K611=1;
N                            				   tick_process=0;
N                            				  // Flag_K611=0;
N                            				   sch_obmen=0;
N                                  }
N                  					}
N
N                            
N                  	
N                  		if (strcmp(Word,"init_K611")==0) 
N                  		{ 
N                  	//	Transf (" init_K611  \r"  );
N                  		Flag_init_K611=1;
N                  		Flag_K611=0;
N                  		tick_process=0;
N                  		sch_obmen=0;
N                  	    tick_process_K611=0;
N                  		} //      
N                  		
N                  		if (strcmp(Word,"_1-611")==0)
N                  		{ 
N                  //		Transf (" _1-611  \r"  );
N                  		Flag_control_K611=1;
N                  		//Flag_K611=0;
N                  		tick_process=0;
N                  		sch_obmen=0;
N                  	    tick_process_K611=0;
N                  				} //       
N                  		
N                  		if (strcmp(Word,"__1-611")==0)
N                  		{ 
N                  	//	Transf (" __1-611  \r"  );
N                  		Flag_zahvat_sig_K611=1;
N                  		//Flag_K611=0;
N                  		tick_process=0;
N                  		sch_obmen=0;
N                  	    tick_process_K611=0;
N                  		} //        
N                  		
N                  		if (strcmp(Word,"__1-611")==0)
N                  		{ 
N                  	//	Transf (" __1-611  \r"  );
N                  		Flag_control_sig_K611=1;
N                  		//Flag_K611=0;
N                  		tick_process=0;
N                  		sch_obmen=0;
N                  	    tick_process_K611=0;
N                  		} //       
N                  		
N                  //--------------------------------------------------K612----------------------------------------------------------------				
N              
N                      
N		
N	    } 
N	
N	}
N	
N	if ((packet_ok==1)&&(crc_ok==0x1))     //     
N
N	{
N		
N	  if (Master_flag==0)
N
N      {/*
N    
N        	Transf("\r\n");
N        	ZTransf (InOut,index1);
N       // 	Transf("\r\n");
N       // 	Transf("\r\n");
N          //    TX_485;	
N		*/		  
N      }
N
N		
N	}
N	
N	
N	if ( packet_ok==1) 
N		
N		{
N		
N			for (i=0;i<Bufer_size;i++)        Word[i]     =0x0;
X			for (i=0;i<64;i++)        Word[i]     =0x0;
N			for (i=0;i<Bufer_size;i++)   DATA_Word[i]     =0x0;
X			for (i=0;i<64;i++)   DATA_Word[i]     =0x0;
N			for (i=0;i<Bufer_size;i++)  DATA_Word2[i]     =0x0;  
X			for (i=0;i<64;i++)  DATA_Word2[i]     =0x0;  
N			for (i=0;i<Bufer_size;i++)       InOut[i]     =0x0;
X			for (i=0;i<64;i++)       InOut[i]     =0x0;
N		
N			time_uart=0;  //   
N			packet_flag=0; 
N			index1=0; 
N			crc=0; 
N			crc_ok=0; 
N			i=0;
N			packet_ok=0; 
N			index_word=0; 
N			index_data_word=0;
N			data_flag=0;
N			index_data_word2=0;
N			data_flag2=0;
N		};
N
N	}
N         
N } 
N
N
N
Nvoid UART1_IRQHandler(void)
N{ 
N  unsigned stat;
N    unsigned t;
N  uint32_t value;
N  uint8_t ReciveByte;
N  unsigned char letter[1];
N
Nif (UART_GetITStatusMasked(MDR_UART1, UART_IT_RX) == SET)
Xif (UART_GetITStatusMasked(((MDR_UART_TypeDef *) (0x40030000)), ((uint32_t)0x00000010)) == SET)
N  {
N    UART_ClearITPendingBit(MDR_UART1, UART_IT_RX);
X    UART_ClearITPendingBit(((MDR_UART_TypeDef *) (0x40030000)), ((uint32_t)0x00000010));
N    uart1_IT_RX_flag = SET;
N  }
N
N  if (uart1_IT_RX_flag == SET)
N  {
N
N    /* Clear uart2_IT_RX_flag */
N       uart1_IT_RX_flag = RESET;
N
N     /* Recive data */
N    ReciveByte = UART_ReceiveData (MDR_UART1);
X    ReciveByte = UART_ReceiveData (((MDR_UART_TypeDef *) (0x40030000)));
N
N  letter[0]=ReciveByte;
N  
N  BufIsRead_flag=1; //  
N  
N                      //  Receive data ready.
N            { 
N                                                      //   : . . 
N             t= letter[0];
N             if ( /*t != 0*/1 ) 
N               {
N                 *pRcv_Buf=t;  
N                 if ( pRcv_Buf == pcur_Rcv )         //
N                   { if ( CyclEnd_flag )
N                       { 
N                        RcvBufOverflow_flag=1;
N                        CyclEnd_flag = 0;
N                       }
N                      //else
N                     BufIsRead_flag=1;      //  .   
N                   }
N                 if ( pRcv_Buf == (RcvBuf+buf_size-1))
X                 if ( pRcv_Buf == (RcvBuf+256-1))
N                   {
N                    pRcv_Buf = RcvBuf;
N                    CyclEnd_flag = 0x1;
N                   }
N                  else
N                   { 
N                    pRcv_Buf++;
N                   }
N                  
N               }
N            }
N  
N  }
N
N
N}
N
N
N
N
N/*******************************************************************************
N* Function Name  : UART2_IRQHandler
N* Description    : This function handles UART2 global interrupt request.
N* Input          : None
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid UART2_IRQHandler(void)
N{
N  unsigned stat;
N    unsigned t;
N  uint32_t value;
N  uint8_t ReciveByte;
N  unsigned char letter[1];
N
Nif (UART_GetITStatusMasked(MDR_UART2, UART_IT_RX) == SET)
Xif (UART_GetITStatusMasked(((MDR_UART_TypeDef *) (0x40038000)), ((uint32_t)0x00000010)) == SET)
N  {
N    UART_ClearITPendingBit(MDR_UART2, UART_IT_RX);
X    UART_ClearITPendingBit(((MDR_UART_TypeDef *) (0x40038000)), ((uint32_t)0x00000010));
N    uart2_IT_RX_flag = SET;
N  }
N
N  if (uart2_IT_RX_flag == SET)
N  {
N
N    /* Clear uart2_IT_RX_flag */
N       uart2_IT_RX_flag = RESET;
N
N     /* Recive data */
N    ReciveByte = UART_ReceiveData (MDR_UART2);
X    ReciveByte = UART_ReceiveData (((MDR_UART_TypeDef *) (0x40038000)));
N  
N
N  
N  letter[0]=ReciveByte;
N
N  BufIsRead_flag=1;   //  
N  
N                      //  Receive data ready.
N            { 
N                                                      //   : . . 
N             t= letter[0];
N             if ( /*t != 0*/1 ) 
N               {
N                 *pRcv_Buf=t;  
N                 if ( pRcv_Buf == pcur_Rcv )         //
N                   { if ( CyclEnd_flag )
N                       { 
N                        RcvBufOverflow_flag=1;
N                        CyclEnd_flag = 0;
N                       }
N                      //else
N                     BufIsRead_flag=1;      //  .   
N                   }
N                 if ( pRcv_Buf == (RcvBuf+buf_size-1))
X                 if ( pRcv_Buf == (RcvBuf+256-1))
N                   {
N                    pRcv_Buf = RcvBuf;
N                    CyclEnd_flag = 0x1;
N                   }
N                  else
N                   { 
N                    pRcv_Buf++;
N                   }
N                  
N               }
N            }
N       }  
N}
N
N//===============================================================
N
N
Nvoid UART_control (void)
N
N{
N     if ((BufIsRead_flag==1)) // 
N           
N            {            	
N               getStr(sr,&lsr);
N               BufIsRead_flag=0;
N			   //ZTransf(sr,lsr);
N               IO(sr);
N			   
N		  	   RX_485();
N                    
N            } 
N}
N
N
N
N
Nuint8_t LD_control (void) //  0 -  , 1 -  , 2 -  , 3 -   .
N{
N  uint8_t a=0;
N 
N  a =      a|PORT_ReadInputDataBit(MDR_PORTE,PORT_Pin_1); //   Lock Detect  
X  a =      a|PORT_ReadInputDataBit(((MDR_PORT_TypeDef *) (0x400C8000)),0x0002U); 
N  a = (a<<1)|PORT_ReadInputDataBit(MDR_PORTC,PORT_Pin_2); //   Lock Detect  
X  a = (a<<1)|PORT_ReadInputDataBit(((MDR_PORT_TypeDef *) (0x400B8000)),0x0004U); 
N
N  return a;
N
N}
N
Nunsigned char INIT_FOCH (unsigned char z)
N{
N  
N	//-------- -1--------------
N	if (z==5)  IO("~6 2_init;");
N
N	if (z==8)  IO("~6 2_Kdiv1()=10;");
N
N	if (z==7)  IO("~6 2_Kdiv2():20;");
N	   
N	if (z==6)  IO("~6 2_Kdiv3():3600;");
N
N	//-------- -2--------------
N	 
N	if (z==1)  IO("~6 1_init;");
N
N	if (z==4)  IO("~6 1_Kdiv1()=10;");
N
N	if (z==3)  IO("~6 1_Kdiv2():10;");
N
N	if (z==2)  IO("~6 1_Kdiv3():2000;");
N
N	//------- -----------------
N
N	 if (z==9) {IO("~6 LD_control;");FLAG_INIT_FOCH=1;z=0;}
N	 
N	 z = z+1;
N	 
N	return z;
N}
N
Nvoid Led_Zahvat (unsigned char a)
N{
N	static unsigned char l;
N	
N	  if (a==0x00) l=0;
N      if (a==0x01) l=~l;
N      if (a==0x02) l=~l;
N      if (a==0x03) l=0xff;
N	  if (l>0u) ZAHVAT_ON; else ZAHVAT_OFF;
X	  if (l>0u) PORT_ResetBits(((MDR_PORT_TypeDef *) (0x400B8000)), 0x0002U); else PORT_SetBits (((MDR_PORT_TypeDef *) (0x400B8000)), 0x0002U);
N
N}
N
N
Nunsigned char Watch_DOG (unsigned char i)
N
N{
N  if (i==1) LED2_OFF;
X  if (i==1) PORT_SetBits (((MDR_PORT_TypeDef *) (0x400A8000)), 0x0080U);
N
N  if (i==2) LED2_ON;           
X  if (i==2) PORT_ResetBits(((MDR_PORT_TypeDef *) (0x400A8000)), 0x0080U);           
N
N  if (i==3) LED1_OFF;          
X  if (i==3) PORT_SetBits (((MDR_PORT_TypeDef *) (0x400A8000)), 0x0040U);          
N
N  if (i==4) LED1_ON;
X  if (i==4) PORT_ResetBits(((MDR_PORT_TypeDef *) (0x400A8000)), 0x0040U);
N  
N  if (i==5) i=0;
N  
N  i++;
N  
N  return i;
N }
N 
N
N
N
N
N#define INIT_FOCH_delay 100000
N#define led_delay 70000
N
Nint main()
N{
N	unsigned int i=0;
N	unsigned int j=0;
N
N
N    RegisterInits();
N
N    MltPinCfg ();
N    LedPinGfg ();
N
N    Uart1PinCfg();
N    Uart1Setup();
N    
N
N    Uart2PinCfg();
N    Uart2Setup();
N
N    SPI_init();
N
N    pcur_Tr= TrBuf;
N    pTr_Buf= TrBuf;
N
N    pcur_Rcv= RcvBuf;
N    pRcv_Buf= RcvBuf;
N
N   for (i=0;i<Bufer_size;i++)       strng[i]     =0x0;
X   for (i=0;i<64;i++)       strng[i]     =0x0;
N   for (i=0;i<Bufer_size;i++)          sr[i]     =0x0;
X   for (i=0;i<64;i++)          sr[i]     =0x0;
N   for (i=0;i<Bufer_size;i++)        Word[i]     =0x0;
X   for (i=0;i<64;i++)        Word[i]     =0x0;
N   for (i=0;i<Bufer_size;i++)   DATA_Word[i]     =0x0;
X   for (i=0;i<64;i++)   DATA_Word[i]     =0x0;
N   for (i=0;i<Bufer_size;i++)  DATA_Word2[i]     =0x0;  
X   for (i=0;i<64;i++)  DATA_Word2[i]     =0x0;  
N   for (i=0;i<Bufer_size;i++)       InOut[i]     =0x0;
X   for (i=0;i<64;i++)       InOut[i]     =0x0;
N
N   	i=0;
N
N  // 	Menu1();
N
N	RX_485();
N
N    PWR_ON; //     
X    PORT_ResetBits(((MDR_PORT_TypeDef *) (0x400B0000)), 0x0100U); 
N
N
N while(1)
N {
N			if (i<INIT_FOCH_delay) i=i+1; else i=0;
X			if (i<100000) i=i+1; else i=0;
N			if (j<led_delay)       j=j+1; else j=0;
X			if (j<70000)       j=j+1; else j=0;
N
N             UART_control ();
N
N             flag_status_ZAHVAT=LD_control (); //  
N
N            if (j==led_delay)  FLAG_LED_n=Watch_DOG (FLAG_LED_n);
X            if (j==70000)  FLAG_LED_n=Watch_DOG (FLAG_LED_n);
N    
N			if (j==led_delay) Led_Zahvat (flag_status_ZAHVAT); //     
X			if (j==70000) Led_Zahvat (flag_status_ZAHVAT); 
N	
N            if ((i==INIT_FOCH_delay)&&(FLAG_INIT_FOCH==0)) {FLAG_INIT_n_FOCH=INIT_FOCH (FLAG_INIT_n_FOCH);} // 
X            if ((i==100000)&&(FLAG_INIT_FOCH==0)) {FLAG_INIT_n_FOCH=INIT_FOCH (FLAG_INIT_n_FOCH);} 
N				
N            if ((i==INIT_FOCH_delay)&&(FLAG_INIT_MENU==0)) {Menu1();FLAG_INIT_MENU=1;}
X            if ((i==100000)&&(FLAG_INIT_MENU==0)) {Menu1();FLAG_INIT_MENU=1;}
N
N      
N }
N 
N}
N
N
