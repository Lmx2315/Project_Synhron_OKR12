; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list -c --asm --interleave -o.\objects\mdr32f9qx_rst_clk.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mdr32f9qx_rst_clk.d --cpu=Cortex-M3 --apcs=interwork -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE\Device\MDR1986BE92 -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=513 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 -W --enum_is_int --signed_chars C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_rst_clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RST_CLK_PCLKcmd PROC
;;;1408     */
;;;1409   void RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState)
000000  4afe              LDR      r2,|L1.1020|
;;;1410   {
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1413     assert_param(IS_RST_CLK_PCLK(RST_CLK_PCLK));
;;;1414     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1415     {
;;;1416       MDR_RST_CLK->PER_CLOCK |= RST_CLK_PCLK;
;;;1417     }
;;;1418     else
;;;1419     {
;;;1420       MDR_RST_CLK->PER_CLOCK &= ~RST_CLK_PCLK;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;1416
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;1416
;;;1421     }
;;;1422   }
000010  4770              BX       lr
;;;1423   
                          ENDP

                  RST_CLK_CPUclkSelection PROC
;;;779      */
;;;780    void RST_CLK_CPUclkSelection(uint32_t CPU_CLK)
000012  4afa              LDR      r2,|L1.1020|
;;;781    {
;;;782      uint32_t temp;
;;;783    
;;;784      /* Check the parameters */
;;;785      assert_param(IS_RST_CPU_CLK(CPU_CLK));
;;;786    
;;;787      temp = MDR_RST_CLK->CPU_CLOCK;
000014  68d1              LDR      r1,[r2,#0xc]
;;;788      /* Clear CPU_C3_SEL bits */
;;;789      temp &= CPU_HCLK_SELclr;
000016  f4217140          BIC      r1,r1,#0x300
;;;790      /* Set the CPU_C3_SEL bits */
;;;791      temp |= CPU_CLK;
00001a  4301              ORRS     r1,r1,r0
;;;792      /* Store the new value */
;;;793      MDR_RST_CLK->CPU_CLOCK = temp;
00001c  60d1              STR      r1,[r2,#0xc]
;;;794    }
00001e  4770              BX       lr
;;;795    
                          ENDP

                  RST_CLK_GetFlagStatus PROC
;;;1650     */
;;;1651   FlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG)
000020  f3c01142          UBFX     r1,r0,#5,#3
;;;1652   {
;;;1653     uint32_t statusreg;
;;;1654     FlagStatus bitstatus;
;;;1655   
;;;1656     /* Check the parameters */
;;;1657     assert_param(IS_RST_CLK_FLAG(RST_CLK_FLAG));
;;;1658   
;;;1659     /* Get the register */
;;;1660     if ((FLAG_SFR_MASK & RST_CLK_FLAG) == (uint32_t)0x20) /* The flag to check is in CLOCK_STATUS register */
000024  2901              CMP      r1,#1
000026  d009              BEQ      |L1.60|
;;;1661     {
;;;1662       statusreg = MDR_RST_CLK->CLOCK_STATUS;
;;;1663     }
;;;1664     else                                                  /* The flag to check is in REG_0F register */
;;;1665     {
;;;1666       statusreg = MDR_BKP->REG_0F;
000028  49f5              LDR      r1,|L1.1024|
00002a  6bc9              LDR      r1,[r1,#0x3c]
                  |L1.44|
;;;1667     }
;;;1668   
;;;1669     /* Get the flag status on proper position */
;;;1670     if ((statusreg & ((uint32_t)1 << (RST_CLK_FLAG & FLAG_MASK))) != (uint32_t)0x00)
00002c  f000021f          AND      r2,r0,#0x1f
000030  2001              MOVS     r0,#1
000032  4090              LSLS     r0,r0,r2
000034  4008              ANDS     r0,r0,r1
000036  d000              BEQ      |L1.58|
;;;1671     {
;;;1672       bitstatus = SET;
000038  2001              MOVS     r0,#1
                  |L1.58|
;;;1673     }
;;;1674     else
;;;1675     {
;;;1676       bitstatus = RESET;
;;;1677     }
;;;1678   
;;;1679     /* Return the flag status */
;;;1680     return bitstatus;
;;;1681   }
00003a  4770              BX       lr
                  |L1.60|
00003c  49ef              LDR      r1,|L1.1020|
00003e  6809              LDR      r1,[r1,#0]            ;1662
000040  e7f4              B        |L1.44|
;;;1682   
                          ENDP

                  RST_CLK_HSIstatus PROC
;;;468      */
;;;469    ErrorStatus RST_CLK_HSIstatus(void)
000042  b508              PUSH     {r3,lr}
;;;470    {
;;;471      __IO uint32_t startCounter = 0;
000044  2000              MOVS     r0,#0
;;;472      ErrorStatus state;
;;;473      FlagStatus flag;
;;;474    
;;;475      /* Wait until HSI is ready or time out is occure */
;;;476      do
;;;477      {
;;;478        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY);
;;;479        startCounter++;
;;;480      } while ((startCounter < HSIonTimeOut) && (flag == RESET));
000046  f44f63c0          MOV      r3,#0x600
00004a  9000              STR      r0,[sp,#0]
                  |L1.76|
00004c  2017              MOVS     r0,#0x17              ;478
00004e  f7fffffe          BL       RST_CLK_GetFlagStatus
000052  9900              LDR      r1,[sp,#0]            ;479
000054  1c49              ADDS     r1,r1,#1              ;479
000056  9100              STR      r1,[sp,#0]
000058  4299              CMP      r1,r3
00005a  d201              BCS      |L1.96|
00005c  2800              CMP      r0,#0
00005e  d0f5              BEQ      |L1.76|
                  |L1.96|
;;;481    
;;;482      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY) != RESET)
000060  2017              MOVS     r0,#0x17
000062  f7fffffe          BL       RST_CLK_GetFlagStatus
000066  2800              CMP      r0,#0
000068  d000              BEQ      |L1.108|
;;;483      {
;;;484        state = SUCCESS;
00006a  2001              MOVS     r0,#1
                  |L1.108|
;;;485      }
;;;486      else
;;;487      {
;;;488        state = ERROR;
;;;489      }
;;;490      return state;
;;;491    }
00006c  bd08              POP      {r3,pc}
;;;492    
                          ENDP

                  RST_CLK_HSIcmd PROC
;;;414      */
;;;415    void RST_CLK_HSIcmd(FunctionalState NewState)
00006e  49e5              LDR      r1,|L1.1028|
;;;416    {
;;;417    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;418      uint32_t temp = 0;
;;;419    #endif
;;;420      /* Check the parameters */
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422    
;;;423    #if defined  (USE_MDR1986VE9x)
;;;424      *(__IO uint32_t *) HSION_BB = (uint32_t)NewState;
000070  6008              STR      r0,[r1,#0]
;;;425    #endif
;;;426    
;;;427    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;428    
;;;429        temp = MDR_BKP->REG_0F;
;;;430      /* Form new value */
;;;431      if (NewState != DISABLE){
;;;432        /* Enable HSI clk by setting the HSE_ON bit in the BKP_REG_0F register */
;;;433        temp |= BKP_REG_0F_HSI_ON;
;;;434      }
;;;435      else{
;;;436        /* Disable HSI clk by resetting the HSE_ON bit in the BKP_REG_0F register */
;;;437        temp &= ~BKP_REG_0F_HSI_ON;
;;;438      }
;;;439      /* Configure REG_0F register with new value */
;;;440      MDR_BKP->REG_0F = temp;
;;;441    #endif /* defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) */
;;;442    }
000072  4770              BX       lr
;;;443    
                          ENDP

                  RST_CLK_WarmDeInit PROC
;;;190      */
;;;191    void RST_CLK_WarmDeInit(void)
000074  49e3              LDR      r1,|L1.1028|
;;;192    {
000076  b500              PUSH     {lr}
;;;193      /* Prepare HSI clk */
;;;194      RST_CLK_HSIcmd(ENABLE);
000078  2001              MOVS     r0,#1
00007a  6008              STR      r0,[r1,#0]
;;;195      RST_CLK_HSIstatus();
00007c  f7fffffe          BL       RST_CLK_HSIstatus
;;;196      RST_CLK_CPUclkSelection(RST_CLK_CPUclkHSI);
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;197    
;;;198      /* Reset CPU_CLOCK bits */
;;;199      MDR_RST_CLK->CPU_CLOCK   &= (uint32_t)0x00000000;
000086  48dd              LDR      r0,|L1.1020|
000088  68c1              LDR      r1,[r0,#0xc]
00008a  2100              MOVS     r1,#0
00008c  60c1              STR      r1,[r0,#0xc]
;;;200    
;;;201      /* Reset PLL_CONTROL bits */
;;;202      MDR_RST_CLK->PLL_CONTROL &= (uint32_t)0x00000000;
00008e  6842              LDR      r2,[r0,#4]
000090  6041              STR      r1,[r0,#4]
;;;203    
;;;204      /* Reset HSEON and HSEBYP bits */
;;;205      MDR_RST_CLK->HS_CONTROL  &= (uint32_t)0x00000000;
000092  6882              LDR      r2,[r0,#8]
000094  6081              STR      r1,[r0,#8]
;;;206    
;;;207      /* Reset USB_CLOCK bits */
;;;208      MDR_RST_CLK->USB_CLOCK   &= (uint32_t)0x00000000;
000096  6902              LDR      r2,[r0,#0x10]
000098  6101              STR      r1,[r0,#0x10]
;;;209    
;;;210      /* Reset ADC_MCO_CLOCK bits */
;;;211      MDR_RST_CLK->ADC_MCO_CLOCK   &= (uint32_t)0x00000000;
00009a  6942              LDR      r2,[r0,#0x14]
00009c  6141              STR      r1,[r0,#0x14]
;;;212    
;;;213      /* Reset RTC_CLOCK bits */
;;;214      MDR_RST_CLK->RTC_CLOCK   &= (uint32_t)0x00000000;
00009e  6982              LDR      r2,[r0,#0x18]
0000a0  6181              STR      r1,[r0,#0x18]
;;;215    
;;;216      /* Reset all clock but RTC_CLK bit */
;;;217      MDR_RST_CLK->PER_CLOCK   = (uint32_t)PCLK_BIT(MDR_RST_CLK_BASE) | (uint32_t)PCLK_BIT(MDR_BKP_BASE);
0000a2  49d9              LDR      r1,|L1.1032|
0000a4  61c1              STR      r1,[r0,#0x1c]
;;;218    }
0000a6  bd00              POP      {pc}
;;;219    
                          ENDP

                  RST_CLK_DeInit PROC
;;;175      */
;;;176    void RST_CLK_DeInit(void)
0000a8  b500              PUSH     {lr}
;;;177    {
;;;178      RST_CLK_WarmDeInit();
0000aa  f7fffffe          BL       RST_CLK_WarmDeInit
;;;179      /* Reset REG_0F bits to zero but HSION bit */
;;;180      RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP, ENABLE);
0000ae  2101              MOVS     r1,#1
0000b0  06c8              LSLS     r0,r1,#27
0000b2  f7fffffe          BL       RST_CLK_PCLKcmd
;;;181      MDR_BKP->REG_0F |= (uint32_t)((1<<22)|(1<<15)); /* HSION & LSION */
0000b6  48d2              LDR      r0,|L1.1024|
0000b8  6bc1              LDR      r1,[r0,#0x3c]
0000ba  f4410181          ORR      r1,r1,#0x408000
0000be  63c1              STR      r1,[r0,#0x3c]
;;;182      MDR_BKP->REG_0F &= (uint32_t)((1<<22)|(1<<15));
0000c0  6bc1              LDR      r1,[r0,#0x3c]
0000c2  f4010181          AND      r1,r1,#0x408000
0000c6  63c1              STR      r1,[r0,#0x3c]
;;;183    }
0000c8  bd00              POP      {pc}
;;;184    
                          ENDP

                  RST_CLK_HSEconfig PROC
;;;227      */
;;;228    void RST_CLK_HSEconfig(uint32_t RST_CLK_HSE)
0000ca  49cc              LDR      r1,|L1.1020|
;;;229    {
;;;230      /* Check the parameters */
;;;231      assert_param(IS_RST_CLK_HSE(RST_CLK_HSE));
;;;232      /* Reset HSEON and HSEBYP bits before configuring the HSE */
;;;233      MDR_RST_CLK->HS_CONTROL &= ~((uint32_t)(RST_CLK_HSE_ON | RST_CLK_HSE_Bypass));
0000cc  688a              LDR      r2,[r1,#8]
0000ce  f0220203          BIC      r2,r2,#3
0000d2  608a              STR      r2,[r1,#8]
;;;234      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;235      switch (RST_CLK_HSE)
0000d4  2801              CMP      r0,#1
0000d6  d006              BEQ      |L1.230|
0000d8  2802              CMP      r0,#2
0000da  d103              BNE      |L1.228|
;;;236      {
;;;237        case RST_CLK_HSE_ON:
;;;238          /* Set HSEON bit */
;;;239          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON;
;;;240          break;
;;;241    
;;;242        case RST_CLK_HSE_Bypass:
;;;243          /* Set HSEBYP and HSEON bits */
;;;244          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON | RST_CLK_HSE_Bypass;
0000dc  6888              LDR      r0,[r1,#8]
0000de  f0400003          ORR      r0,r0,#3
                  |L1.226|
0000e2  6088              STR      r0,[r1,#8]
                  |L1.228|
;;;245          break;
;;;246    
;;;247        default:
;;;248          break;
;;;249      }
;;;250    }
0000e4  4770              BX       lr
                  |L1.230|
0000e6  6888              LDR      r0,[r1,#8]            ;239
0000e8  f0400001          ORR      r0,r0,#1              ;239
0000ec  e7f9              B        |L1.226|
;;;251    
                          ENDP

                  RST_CLK_HSEstatus PROC
;;;292      */
;;;293    ErrorStatus RST_CLK_HSEstatus(void)
0000ee  b508              PUSH     {r3,lr}
;;;294    {
;;;295      __IO uint32_t startCounter = 0;
0000f0  2000              MOVS     r0,#0
;;;296      ErrorStatus state;
;;;297      FlagStatus flag;
;;;298    
;;;299      /* Wait until HSE is ready or time out is occure */
;;;300      do
;;;301      {
;;;302        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY);
;;;303        startCounter++;
;;;304      } while ((startCounter < HSEonTimeOut) && (flag == RESET));
0000f2  f44f63c0          MOV      r3,#0x600
0000f6  9000              STR      r0,[sp,#0]
                  |L1.248|
0000f8  2022              MOVS     r0,#0x22              ;302
0000fa  f7fffffe          BL       RST_CLK_GetFlagStatus
0000fe  9900              LDR      r1,[sp,#0]            ;303
000100  1c49              ADDS     r1,r1,#1              ;303
000102  9100              STR      r1,[sp,#0]
000104  4299              CMP      r1,r3
000106  d201              BCS      |L1.268|
000108  2800              CMP      r0,#0
00010a  d0f5              BEQ      |L1.248|
                  |L1.268|
;;;305    
;;;306      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY) != RESET)
00010c  2022              MOVS     r0,#0x22
00010e  f7fffffe          BL       RST_CLK_GetFlagStatus
000112  2800              CMP      r0,#0
000114  d000              BEQ      |L1.280|
;;;307      {
;;;308        state = SUCCESS;
000116  2001              MOVS     r0,#1
                  |L1.280|
;;;309      }
;;;310      else
;;;311      {
;;;312        state = ERROR;
;;;313      }
;;;314      return state;
;;;315    }
000118  bd08              POP      {r3,pc}
;;;316    
                          ENDP

                  RST_CLK_LSEconfig PROC
;;;355      */
;;;356    void RST_CLK_LSEconfig(uint32_t RST_CLK_LSE)
00011a  49b9              LDR      r1,|L1.1024|
;;;357    {
;;;358      /* Check the parameters */
;;;359      assert_param(IS_RST_CLK_LSE(RST_CLK_LSE));
;;;360      /* Reset LSEON and LSEBYP bits before configuring the LSE */
;;;361      MDR_BKP->REG_0F &= ~((uint32_t)(RST_CLK_LSE_ON | RST_CLK_LSE_Bypass));
00011c  6bca              LDR      r2,[r1,#0x3c]
00011e  f0220203          BIC      r2,r2,#3
000122  63ca              STR      r2,[r1,#0x3c]
;;;362      switch (RST_CLK_LSE)
000124  2801              CMP      r0,#1
000126  d006              BEQ      |L1.310|
000128  2802              CMP      r0,#2
00012a  d103              BNE      |L1.308|
;;;363      {
;;;364        case RST_CLK_LSE_ON:
;;;365          /* Set LSEON bit */
;;;366          MDR_BKP->REG_0F |= RST_CLK_LSE_ON;
;;;367          break;
;;;368    
;;;369        case RST_CLK_LSE_Bypass:
;;;370          /* Set LSEBYP and LSEON bits */
;;;371          MDR_BKP->REG_0F |= (RST_CLK_LSE_ON | RST_CLK_LSE_Bypass);
00012c  6bc8              LDR      r0,[r1,#0x3c]
00012e  f0400003          ORR      r0,r0,#3
                  |L1.306|
000132  63c8              STR      r0,[r1,#0x3c]
                  |L1.308|
;;;372          break;
;;;373    
;;;374        default:
;;;375          break;
;;;376      }
;;;377    }
000134  4770              BX       lr
                  |L1.310|
000136  6bc8              LDR      r0,[r1,#0x3c]         ;366
000138  f0400001          ORR      r0,r0,#1              ;366
00013c  e7f9              B        |L1.306|
;;;378    
                          ENDP

                  RST_CLK_LSEstatus PROC
;;;383      */
;;;384    ErrorStatus RST_CLK_LSEstatus(void)
00013e  b508              PUSH     {r3,lr}
;;;385    {
;;;386      __IO uint32_t startCounter = 0;
000140  2000              MOVS     r0,#0
;;;387      ErrorStatus state;
;;;388      FlagStatus flag;
;;;389    
;;;390     /* Wait until LSE is ready or time out is occure */
;;;391     do
;;;392      {
;;;393        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY);
;;;394        startCounter++;
;;;395      } while ((startCounter < LSEonTimeOut) && (flag == RESET));
000142  f44f63c0          MOV      r3,#0x600
000146  9000              STR      r0,[sp,#0]
                  |L1.328|
000148  200d              MOVS     r0,#0xd               ;393
00014a  f7fffffe          BL       RST_CLK_GetFlagStatus
00014e  9900              LDR      r1,[sp,#0]            ;394
000150  1c49              ADDS     r1,r1,#1              ;394
000152  9100              STR      r1,[sp,#0]
000154  4299              CMP      r1,r3
000156  d201              BCS      |L1.348|
000158  2800              CMP      r0,#0
00015a  d0f5              BEQ      |L1.328|
                  |L1.348|
;;;396    
;;;397      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY) != RESET)
00015c  200d              MOVS     r0,#0xd
00015e  f7fffffe          BL       RST_CLK_GetFlagStatus
000162  2800              CMP      r0,#0
000164  d000              BEQ      |L1.360|
;;;398      {
;;;399        state = SUCCESS;
000166  2001              MOVS     r0,#1
                  |L1.360|
;;;400      }
;;;401      else
;;;402      {
;;;403        state = ERROR;
;;;404      }
;;;405      return state;
;;;406    }
000168  bd08              POP      {r3,pc}
;;;407    
                          ENDP

                  RST_CLK_HSIadjust PROC
;;;449      */
;;;450    void RST_CLK_HSIadjust(uint32_t HSItrimValue)
00016a  4aa5              LDR      r2,|L1.1024|
;;;451    {
;;;452      uint32_t temp;
;;;453      /* Check the parameters */
;;;454      assert_param(IS_RCC_CLK_HSI_TRIM_VALUE(HSItrimValue));
;;;455      temp = MDR_BKP->REG_0F;
00016c  6bd1              LDR      r1,[r2,#0x3c]
;;;456      /* Clear HSITRIM[5:0] bits */
;;;457      temp &= ~HSITRIM_MASK;
00016e  f021517c          BIC      r1,r1,#0x3f000000
;;;458      /* Set the HSITRIM[5:0] bits according to HSItrimValue value */
;;;459      temp |= (uint32_t)HSItrimValue << HSITRIM_OFFSET;
000172  ea416000          ORR      r0,r1,r0,LSL #24
;;;460      /* Store the new value */
;;;461      MDR_BKP->REG_0F = temp;
000176  63d0              STR      r0,[r2,#0x3c]
;;;462    }
000178  4770              BX       lr
;;;463    
                          ENDP

                  RST_CLK_LSIcmd PROC
;;;499      */
;;;500    void RST_CLK_LSIcmd(FunctionalState NewState)
00017a  49a2              LDR      r1,|L1.1028|
;;;501    {
;;;502    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;503      uint32_t temp = 0;
;;;504    #endif
;;;505      /* Check the parameters */
;;;506      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;507    
;;;508    #if defined  (USE_MDR1986VE9x)
;;;509      *(__IO uint32_t *) LSION_BB = (uint32_t) NewState;
00017c  391c              SUBS     r1,r1,#0x1c
00017e  6008              STR      r0,[r1,#0]
;;;510    #endif
;;;511    
;;;512    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;513    
;;;514      temp = MDR_BKP->REG_0F;
;;;515      /* Form new value */
;;;516      if (NewState != DISABLE) {
;;;517        /* Enable LSI clk by setting the LSE_ON bit in the BKP_REG_0F register */
;;;518        temp |= BKP_REG_0F_LSI_ON;
;;;519      }
;;;520      else {
;;;521        /* Disable LSI clk by resetting the LSE_ON bit in the BKP_REG_0F register */
;;;522        temp &= ~BKP_REG_0F_LSI_ON;
;;;523      }
;;;524      /* Configure REG_0F register with new value */
;;;525      MDR_BKP->REG_0F = temp;
;;;526    #endif
;;;527    }
000180  4770              BX       lr
;;;528    
                          ENDP

                  RST_CLK_LSIadjust PROC
;;;534      */
;;;535    void RST_CLK_LSIadjust(uint32_t LSItrimValue)
000182  4a9f              LDR      r2,|L1.1024|
;;;536    {
;;;537      uint32_t temp;
;;;538      /* Check the parameters */
;;;539      assert_param(IS_RCC_CLK_LSI_TRIM_VALUE(LSItrimValue));
;;;540      temp = MDR_BKP->REG_0F;
000184  6bd1              LDR      r1,[r2,#0x3c]
;;;541      /* Clear LSITRIM[4:0] bits */
;;;542      temp &= ~LSITRIM_MASK;
000186  f42111f8          BIC      r1,r1,#0x1f0000
;;;543      /* Set the LSITRIM[4:0] bits according to LSItrimValue value */
;;;544      temp |= (uint32_t)LSItrimValue << LSITRIM_OFFSET;
00018a  ea414000          ORR      r0,r1,r0,LSL #16
;;;545      /* Store the new value */
;;;546      MDR_BKP->REG_0F = temp;
00018e  63d0              STR      r0,[r2,#0x3c]
;;;547    }
000190  4770              BX       lr
;;;548    
                          ENDP

                  RST_CLK_LSIstatus PROC
;;;553      */
;;;554    ErrorStatus RST_CLK_LSIstatus(void)
000192  b508              PUSH     {r3,lr}
;;;555    {
;;;556      __IO uint32_t startCounter = 0;
000194  2000              MOVS     r0,#0
;;;557      ErrorStatus state;
;;;558      FlagStatus flag;
;;;559    
;;;560      /* Wait until LSI is ready or time out is occure */
;;;561      do
;;;562      {
;;;563        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY);
;;;564        startCounter++;
;;;565      } while ((startCounter < LSIonTimeOut) && (flag == RESET));
000196  f44f63c0          MOV      r3,#0x600
00019a  9000              STR      r0,[sp,#0]
                  |L1.412|
00019c  2015              MOVS     r0,#0x15              ;563
00019e  f7fffffe          BL       RST_CLK_GetFlagStatus
0001a2  9900              LDR      r1,[sp,#0]            ;564
0001a4  1c49              ADDS     r1,r1,#1              ;564
0001a6  9100              STR      r1,[sp,#0]
0001a8  4299              CMP      r1,r3
0001aa  d201              BCS      |L1.432|
0001ac  2800              CMP      r0,#0
0001ae  d0f5              BEQ      |L1.412|
                  |L1.432|
;;;566    
;;;567      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY) != RESET)
0001b0  2015              MOVS     r0,#0x15
0001b2  f7fffffe          BL       RST_CLK_GetFlagStatus
0001b6  2800              CMP      r0,#0
0001b8  d000              BEQ      |L1.444|
;;;568      {
;;;569        state = SUCCESS;
0001ba  2001              MOVS     r0,#1
                  |L1.444|
;;;570      }
;;;571      else
;;;572      {
;;;573        state = ERROR;
;;;574      }
;;;575      return (state);
;;;576    }
0001bc  bd08              POP      {r3,pc}
;;;577    
                          ENDP

                  RST_CLK_CPU_PLLconfig PROC
;;;604      */
;;;605    void RST_CLK_CPU_PLLconfig ( uint32_t RST_CLK_CPU_PLLsource,
0001be  4a8f              LDR      r2,|L1.1020|
;;;606                             uint32_t RST_CLK_CPU_PLLmul )
;;;607    {
;;;608      uint32_t temp;
;;;609    
;;;610      /* Check the parameters */
;;;611      assert_param(IS_RST_CLK_CPU_PLL_SOURCE(RST_CLK_CPU_PLLsource));
;;;612      assert_param(IS_RST_CLK_CPU_PLL_MUL(RST_CLK_CPU_PLLmul));
;;;613    
;;;614      /* Select CPUPLL source */
;;;615      temp = MDR_RST_CLK->CPU_CLOCK;
0001c0  68d3              LDR      r3,[r2,#0xc]
;;;616      /* Clear CPU_C1_SEL bits */
;;;617      temp &= CPU_C1_SELclr;
0001c2  f0230303          BIC      r3,r3,#3
;;;618      /* Set the CPU_C1_SEL bits */
;;;619      temp |= RST_CLK_CPU_PLLsource;
0001c6  4303              ORRS     r3,r3,r0
;;;620      /* Store the new value */MDR_RST_CLK->CPU_CLOCK = temp;
0001c8  60d3              STR      r3,[r2,#0xc]
;;;621    
;;;622      /* Set CPUPLL multiplier */
;;;623      temp = MDR_RST_CLK->PLL_CONTROL;
0001ca  6850              LDR      r0,[r2,#4]
;;;624      /* Clear PLLMUL[3:0] bits */
;;;625      temp &= PLLCPUmulclr;
0001cc  f4206070          BIC      r0,r0,#0xf00
;;;626      /* Set the PLLMUL[3:0] bits */
;;;627      temp |= (RST_CLK_CPU_PLLmul << PLLCPUMUL_OFFSET);
0001d0  ea402001          ORR      r0,r0,r1,LSL #8
;;;628      /* Store the new value */MDR_RST_CLK->PLL_CONTROL = temp;
0001d4  6050              STR      r0,[r2,#4]
;;;629    
;;;630    #if defined ( USE_MDR1986VE9x )/* For Cortex M3 */
;;;631      if (*(__IO uint32_t *) PLLCPUON_BB) {
0001d6  488d              LDR      r0,|L1.1036|
0001d8  f8d01088          LDR      r1,[r0,#0x88]
0001dc  2900              CMP      r1,#0                 ;607
0001de  d004              BEQ      |L1.490|
;;;632        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x01;
0001e0  2101              MOVS     r1,#1
0001e2  f8401f8c          STR      r1,[r0,#0x8c]!
;;;633        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x00;
0001e6  2100              MOVS     r1,#0
0001e8  6001              STR      r1,[r0,#0]
                  |L1.490|
;;;634      }
;;;635    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;636      if( (MDR_RST_CLK->PLL_CONTROL & RST_CLK_PLL_CONTROL_PLL_CPU_ON) == RST_CLK_PLL_CONTROL_PLL_CPU_ON ) {
;;;637        temp = MDR_RST_CLK->PLL_CONTROL;
;;;638        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;639        MDR_RST_CLK->PLL_CONTROL = temp;
;;;640        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;641        MDR_RST_CLK->PLL_CONTROL = temp;
;;;642      }
;;;643    #endif
;;;644    }
0001ea  4770              BX       lr
;;;645    
                          ENDP

                  RST_CLK_CPU_PLLuse PROC
;;;650      */
;;;651    void RST_CLK_CPU_PLLuse(FunctionalState UsePLL)
0001ec  4987              LDR      r1,|L1.1036|
;;;652    {
;;;653    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;654      uint32_t temp = 0;
;;;655    #endif
;;;656      /* Check the parameters */
;;;657      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;658    
;;;659    #if defined  (USE_MDR1986VE9x)
;;;660      *(__IO uint32_t *) CPU_C2_SEL_BB = (uint32_t) UsePLL;
0001ee  f8c10188          STR      r0,[r1,#0x188]
;;;661    #endif
;;;662    
;;;663    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;664    
;;;665      temp = MDR_RST_CLK->CPU_CLOCK;
;;;666      /* Form new value */
;;;667      if (UsePLL != DISABLE){
;;;668        /* Use the CPU PLL output as input for CPU_C3_SEL
;;;669         * by setting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;670        temp |= (1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;671      }
;;;672      else{
;;;673        /* Use the CPU_C1 output as input for CPU_C3_SEL
;;;674         * by resetting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;675        temp &= ~(1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;676      }
;;;677      /* Configure CPU_CLOCK register with new value */
;;;678      MDR_RST_CLK->CPU_CLOCK = temp;
;;;679    #endif
;;;680    }
0001f2  4770              BX       lr
;;;681    
                          ENDP

                  RST_CLK_CPU_PLLcmd PROC
;;;686      */
;;;687    void RST_CLK_CPU_PLLcmd ( FunctionalState NewState )
0001f4  4985              LDR      r1,|L1.1036|
;;;688    {
;;;689    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;690      uint32_t temp;
;;;691    #endif
;;;692      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;693    
;;;694    #if defined  (USE_MDR1986VE9x)
;;;695      *(__IO uint32_t *) PLLCPUON_BB = (uint32_t) NewState;
0001f6  f8c10088          STR      r0,[r1,#0x88]
;;;696    #endif
;;;697    
;;;698    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;699      temp = MDR_RST_CLK->PLL_CONTROL;
;;;700    
;;;701      if(NewState == ENABLE){
;;;702        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;703      }
;;;704      else{
;;;705        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;706      }
;;;707      MDR_RST_CLK->PLL_CONTROL = temp;
;;;708    
;;;709    #endif
;;;710    }
0001fa  4770              BX       lr
;;;711    
                          ENDP

                  RST_CLK_CPU_PLLstatus PROC
;;;716      */
;;;717    ErrorStatus RST_CLK_CPU_PLLstatus(void)
0001fc  b508              PUSH     {r3,lr}
;;;718    {
;;;719      __IO uint32_t startCounter = 0;
0001fe  2000              MOVS     r0,#0
;;;720      ErrorStatus state;
;;;721      FlagStatus flag;
;;;722    
;;;723      /* Wait until CPUPLL is ready or time out is occure */
;;;724      do
;;;725      {
;;;726        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY);
;;;727        startCounter++;
;;;728      } while ((startCounter < PLLCPUonTimeOut) && (flag == RESET));
000200  f44f63c0          MOV      r3,#0x600
000204  9000              STR      r0,[sp,#0]
                  |L1.518|
000206  2021              MOVS     r0,#0x21              ;726
000208  f7fffffe          BL       RST_CLK_GetFlagStatus
00020c  9900              LDR      r1,[sp,#0]            ;727
00020e  1c49              ADDS     r1,r1,#1              ;727
000210  9100              STR      r1,[sp,#0]
000212  4299              CMP      r1,r3
000214  d201              BCS      |L1.538|
000216  2800              CMP      r0,#0
000218  d0f5              BEQ      |L1.518|
                  |L1.538|
;;;729    
;;;730      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY) != RESET)
00021a  2021              MOVS     r0,#0x21
00021c  f7fffffe          BL       RST_CLK_GetFlagStatus
000220  2800              CMP      r0,#0
000222  d000              BEQ      |L1.550|
;;;731      {
;;;732        state = SUCCESS;
000224  2001              MOVS     r0,#1
                  |L1.550|
;;;733      }
;;;734      else
;;;735      {
;;;736        state = ERROR;
;;;737      }
;;;738      return state;
;;;739    }
000226  bd08              POP      {r3,pc}
;;;740    
                          ENDP

                  RST_CLK_CPUclkPrescaler PROC
;;;754      */
;;;755    void RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue)
000228  4a74              LDR      r2,|L1.1020|
;;;756    {
;;;757      uint32_t temp;
;;;758    
;;;759      /* Check the parameters */
;;;760      assert_param(IS_RST_CLK_CPUclkDIV(CPUclkDivValue));
;;;761    
;;;762      temp = MDR_RST_CLK->CPU_CLOCK;
00022a  68d1              LDR      r1,[r2,#0xc]
;;;763      /* Clear CPU_C3_SEL bits */
;;;764      temp &= CPU_C3_SELclr;
00022c  f02101f0          BIC      r1,r1,#0xf0
;;;765      /* Set the CPU_C3_SEL bits */
;;;766      temp |= (CPUclkDivValue << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos);
000230  ea411000          ORR      r0,r1,r0,LSL #4
;;;767      /* Store the new value */
;;;768      MDR_RST_CLK->CPU_CLOCK = temp;
000234  60d0              STR      r0,[r2,#0xc]
;;;769    }
000236  4770              BX       lr
;;;770    
                          ENDP

                  RST_CLK_USB_PLLconfig PROC
;;;822      */
;;;823    void RST_CLK_USB_PLLconfig ( uint32_t RST_CLK_USB_PLLsource,
000238  4a70              LDR      r2,|L1.1020|
;;;824                             uint32_t RST_CLK_USB_PLLmul )
;;;825    {
;;;826      uint32_t temp;
;;;827    
;;;828      /* Check the parameters */
;;;829      assert_param(IS_RST_CLK_USB_PLL_SOURCE(RST_CLK_USB_PLLsource));
;;;830      assert_param(IS_RST_CLK_USB_PLL_MUL(RST_CLK_USB_PLLmul));
;;;831    
;;;832      /* Select USBPLL source */
;;;833      temp = MDR_RST_CLK->USB_CLOCK;
00023a  6913              LDR      r3,[r2,#0x10]
;;;834      /* Clear USB_C1_SEL bits */
;;;835      temp &= USB_C1_SELclr;
00023c  f0230303          BIC      r3,r3,#3
;;;836      /* Set the USB_C1_SEL bits */
;;;837      temp |= RST_CLK_USB_PLLsource;
000240  4303              ORRS     r3,r3,r0
;;;838      /* Store the new value */MDR_RST_CLK->USB_CLOCK = temp;
000242  6113              STR      r3,[r2,#0x10]
;;;839    
;;;840      /* Set USBPLL multiplier */
;;;841      temp = MDR_RST_CLK->PLL_CONTROL;
000244  6850              LDR      r0,[r2,#4]
;;;842      /* Clear PLLMUL[3:0] bits */
;;;843      temp &= PLLUSBmulclr;
000246  f02000f0          BIC      r0,r0,#0xf0
;;;844      /* Set the PLLMUL[3:0] bits */
;;;845      temp |= (RST_CLK_USB_PLLmul << PLLUSBMUL_OFFSET);
00024a  ea401001          ORR      r0,r0,r1,LSL #4
;;;846      /* Store the new value */MDR_RST_CLK->PLL_CONTROL = temp;
00024e  6050              STR      r0,[r2,#4]
;;;847    
;;;848    #if defined  (USE_MDR1986VE9x)
;;;849      if (*(__IO uint32_t *) PLLUSBON_BB) {
000250  486e              LDR      r0,|L1.1036|
000252  f8d01080          LDR      r1,[r0,#0x80]
000256  2900              CMP      r1,#0                 ;825
000258  d004              BEQ      |L1.612|
;;;850        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x01;
00025a  2101              MOVS     r1,#1
00025c  f8401f84          STR      r1,[r0,#0x84]!
;;;851        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x00;
000260  2100              MOVS     r1,#0
000262  6001              STR      r1,[r0,#0]
                  |L1.612|
;;;852      }
;;;853    #endif
;;;854    
;;;855    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;856      if( MDR_RST_CLK->PLL_CONTROL & (RST_CLK_PLL_CONTROL_PLL_USB_ON) ) {
;;;857        temp = MDR_RST_CLK->PLL_CONTROL;
;;;858        temp |= RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;859        MDR_RST_CLK->PLL_CONTROL = temp;
;;;860        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;861        MDR_RST_CLK->PLL_CONTROL = temp;
;;;862      }
;;;863    #endif
;;;864    }
000264  4770              BX       lr
;;;865    
                          ENDP

                  RST_CLK_USB_PLLuse PROC
;;;870      */
;;;871    void RST_CLK_USB_PLLuse ( FunctionalState UsePLL )
000266  4969              LDR      r1,|L1.1036|
;;;872    {
;;;873    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;874      uint32_t temp = 0;
;;;875    #endif
;;;876      /* Check the parameters */
;;;877      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;878    
;;;879    #ifdef USE_MDR1986VE9x /* for Cortex M3 series */
;;;880      *(__IO uint32_t *) USB_C2_SEL_BB = (uint32_t) UsePLL;
000268  f8c10208          STR      r0,[r1,#0x208]
;;;881    #endif // #ifdef USE_MDR1986VE9x /* for Cortex M3 series */
;;;882    
;;;883    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;884    
;;;885      temp = MDR_RST_CLK->USB_CLOCK;
;;;886      /* Form new value */
;;;887      if (UsePLL != DISABLE){
;;;888        /* Use the USB PLL output as input for USB_C3_SEL
;;;889         * by setting the USB_C2_SEL bit in the USB_CLOCK register */
;;;890        temp |= (1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;891      }
;;;892      else{
;;;893        /* Use the USB_C1 output as input for USB_C3_SEL
;;;894         * by resetting the USB_C2_SEL bit in the USB_CLOCK register */
;;;895        temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;896      }
;;;897      /* Configure USB_CLOCK register with new value */
;;;898      MDR_RST_CLK->USB_CLOCK = temp;
;;;899    #endif
;;;900    }
00026c  4770              BX       lr
;;;901    
                          ENDP

                  RST_CLK_USB_PLLcmd PROC
;;;906      */
;;;907    void RST_CLK_USB_PLLcmd ( FunctionalState NewState )
00026e  4967              LDR      r1,|L1.1036|
;;;908    {
;;;909    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;910      uint32_t temp = 0;
;;;911    #endif
;;;912      /* Check the parameters */
;;;913      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;914    #if defined  (USE_MDR1986VE9x)
;;;915      *(__IO uint32_t *) PLLUSBON_BB = (uint32_t) NewState;
000270  f8c10080          STR      r0,[r1,#0x80]
;;;916    #endif
;;;917    
;;;918    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;919    
;;;920      temp = MDR_RST_CLK->PLL_CONTROL;
;;;921      /* Form a new value */
;;;922      if( NewState != DISABLE ) {
;;;923        temp |= RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;924      }
;;;925      else {
;;;926        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;927      }
;;;928      MDR_RST_CLK->PLL_CONTROL = temp;
;;;929    #endif
;;;930    
;;;931    }
000274  4770              BX       lr
;;;932    
                          ENDP

                  RST_CLK_USB_PLLstatus PROC
;;;937      */
;;;938    ErrorStatus RST_CLK_USB_PLLstatus(void)
000276  b508              PUSH     {r3,lr}
;;;939    {
;;;940      __IO uint32_t startCounter = 0;
000278  2000              MOVS     r0,#0
;;;941      ErrorStatus state;
;;;942      FlagStatus flag;
;;;943    
;;;944      /* Wait until USBPLL is ready or time out is occure */
;;;945      do
;;;946      {
;;;947        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY);
;;;948        startCounter++;
;;;949      } while ((startCounter < PLLUSBonTimeOut) && (flag == RESET));
00027a  f44f63c0          MOV      r3,#0x600
00027e  9000              STR      r0,[sp,#0]
                  |L1.640|
000280  2020              MOVS     r0,#0x20              ;947
000282  f7fffffe          BL       RST_CLK_GetFlagStatus
000286  9900              LDR      r1,[sp,#0]            ;948
000288  1c49              ADDS     r1,r1,#1              ;948
00028a  9100              STR      r1,[sp,#0]
00028c  4299              CMP      r1,r3
00028e  d201              BCS      |L1.660|
000290  2800              CMP      r0,#0
000292  d0f5              BEQ      |L1.640|
                  |L1.660|
;;;950    
;;;951      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY) != RESET)
000294  2020              MOVS     r0,#0x20
000296  f7fffffe          BL       RST_CLK_GetFlagStatus
00029a  2800              CMP      r0,#0
00029c  d000              BEQ      |L1.672|
;;;952      {
;;;953        state = SUCCESS;
00029e  2001              MOVS     r0,#1
                  |L1.672|
;;;954      }
;;;955      else
;;;956      {
;;;957        state = ERROR;
;;;958      }
;;;959      return state;
;;;960    }
0002a0  bd08              POP      {r3,pc}
;;;961    
                          ENDP

                  RST_CLK_USBclkPrescaler PROC
;;;968      */
;;;969    void RST_CLK_USBclkPrescaler(FunctionalState NewState)
0002a2  495a              LDR      r1,|L1.1036|
;;;970    {
;;;971    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;972      uint32_t temp = 0;
;;;973    #endif
;;;974      /* Check the parameters */
;;;975      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;976    
;;;977    #if defined  (USE_MDR1986VE9x)
;;;978       *(__IO uint32_t *) USB_C3_SEL_BB = (uint32_t)NewState;
0002a4  f8c10210          STR      r0,[r1,#0x210]
;;;979    #endif
;;;980    
;;;981    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;982    
;;;983      temp = MDR_RST_CLK->USB_CLOCK;
;;;984    
;;;985      /* Form new value */
;;;986      if (NewState != DISABLE){
;;;987        /* Enable the USB prescaler by setting the USB_C3_SEL bit in the USB_CLOCK register */
;;;988        temp |= (1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;989      }
;;;990      else{
;;;991        /* Disable the USB prescaler by resetting the USB_C3_SEL bit in the USB_CLOCK register */
;;;992        temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;993      }
;;;994      /* Configure USB_CLOCK register with new value */
;;;995      MDR_RST_CLK->USB_CLOCK = temp;
;;;996    #endif
;;;997    
;;;998    }
0002a8  4770              BX       lr
;;;999    
                          ENDP

                  RST_CLK_USBclkEnable PROC
;;;1006     */
;;;1007   void RST_CLK_USBclkEnable ( FunctionalState NewState )
0002aa  4958              LDR      r1,|L1.1036|
;;;1008   {
;;;1009   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1010     uint32_t temp = 0;
;;;1011   #endif
;;;1012     /* Check the parameters */
;;;1013     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1014   
;;;1015   #if defined  (USE_MDR1986VE9x)
;;;1016     *(__IO uint32_t *) USB_CLK_EN_BB = (uint32_t) NewState;
0002ac  f8c10220          STR      r0,[r1,#0x220]
;;;1017   #endif
;;;1018   
;;;1019   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1020   
;;;1021     temp = MDR_RST_CLK->USB_CLOCK;
;;;1022   
;;;1023     /* Form new value */
;;;1024     if (NewState != DISABLE){
;;;1025       /* Enable the USB clk by setting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1026       temp |= (1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1027     }
;;;1028     else{
;;;1029       /* Disable the USB clk by resetting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1030       temp &= ~(1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1031     }
;;;1032     /* Configure USB_CLOCK register with new value */
;;;1033     MDR_RST_CLK->USB_CLOCK = temp;
;;;1034   #endif
;;;1035   }
0002b0  4770              BX       lr
;;;1036   
                          ENDP

                  RST_CLK_ADCclkSelection PROC
;;;1048     */
;;;1049   void RST_CLK_ADCclkSelection(uint32_t ADC_CLK)
0002b2  4a52              LDR      r2,|L1.1020|
;;;1050   {
;;;1051     uint32_t temp;
;;;1052   
;;;1053     /* Check the parameters */
;;;1054     assert_param(IS_RST_CLK_ADCclk(ADC_CLK));
;;;1055   
;;;1056     /* Select ADC_CLK source */
;;;1057     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
0002b4  6951              LDR      r1,[r2,#0x14]
;;;1058     /* Clear ADC_C1,C2 SEL bits */
;;;1059     temp &= ADC_C12_SELclr;
0002b6  f0210133          BIC      r1,r1,#0x33
;;;1060     /* Set the ADC_C1,C2 SEL bits */
;;;1061     temp |= ADC_CLK;
0002ba  4301              ORRS     r1,r1,r0
;;;1062     /* Store the new value */
;;;1063     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
0002bc  6151              STR      r1,[r2,#0x14]
;;;1064   }
0002be  4770              BX       lr
;;;1065   
                          ENDP

                  RST_CLK_ADCclkPrescaler PROC
;;;1080     */
;;;1081   void RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue)
0002c0  4a4e              LDR      r2,|L1.1020|
;;;1082   {
;;;1083     uint32_t temp;
;;;1084   
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_RST_CLK_ADCclkDivValue(ADCclkDivValue));
;;;1087   
;;;1088     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
0002c2  6951              LDR      r1,[r2,#0x14]
;;;1089     /* Clear ADC_C3_SEL bits */
;;;1090     temp &= ADC_C3_SELclr;
0002c4  f4216170          BIC      r1,r1,#0xf00
;;;1091     /* Set the ADC_C3_SEL bits */
;;;1092     temp |= ADCclkDivValue<<ADC_C3_SEL_OFFSET;
0002c8  ea412000          ORR      r0,r1,r0,LSL #8
;;;1093     /* Store the new value */
;;;1094     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
0002cc  6150              STR      r0,[r2,#0x14]
;;;1095   }
0002ce  4770              BX       lr
;;;1096   
                          ENDP

                  RST_CLK_ADCclkEnable PROC
;;;1103     */
;;;1104   void RST_CLK_ADCclkEnable ( FunctionalState NewState )
0002d0  494e              LDR      r1,|L1.1036|
;;;1105   {
;;;1106   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1107     uint32_t temp = 0;
;;;1108   #endif
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1111   
;;;1112   #if defined  (USE_MDR1986VE9x)
;;;1113     *(__IO uint32_t *) ADC_CLK_EN_BB = (uint32_t) NewState;
0002d2  f8c102b4          STR      r0,[r1,#0x2b4]
;;;1114   #endif
;;;1115   
;;;1116   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1117   
;;;1118     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
;;;1119     /* Form new value */
;;;1120     if (NewState != DISABLE){
;;;1121       /* Enable the ADC CLK by setting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1122       temp |= RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1123     }
;;;1124     else{
;;;1125       /* Disable the ADC CLK by resetting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1126       temp &= ~RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1127     }
;;;1128     /* Configure CPU_CLOCK register with new value */
;;;1129     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
;;;1130   #endif
;;;1131   
;;;1132   }
0002d6  4770              BX       lr
;;;1133   
                          ENDP

                  RST_CLK_HSIclkPrescaler PROC
;;;1252     */
;;;1253   void RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue)
0002d8  4a48              LDR      r2,|L1.1020|
;;;1254   {
;;;1255     uint32_t temp;
;;;1256   
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_RST_CLK_HSIclkDivValue(HSIclkDivValue));
;;;1259   
;;;1260     temp = MDR_RST_CLK->RTC_CLOCK;
0002da  6991              LDR      r1,[r2,#0x18]
;;;1261     /* Clear HSI_SEL bits */
;;;1262     temp &= HSI_SELclr;
0002dc  f02101f0          BIC      r1,r1,#0xf0
;;;1263     /* Set the HSI_SEL bits */
;;;1264     temp |= HSIclkDivValue<<HSI_SEL_OFFSET;
0002e0  ea411000          ORR      r0,r1,r0,LSL #4
;;;1265     /* Store the new value */
;;;1266     MDR_RST_CLK->RTC_CLOCK = temp;
0002e4  6190              STR      r0,[r2,#0x18]
;;;1267   }
0002e6  4770              BX       lr
;;;1268   
                          ENDP

                  RST_CLK_RTC_HSIclkEnable PROC
;;;1275     */
;;;1276   void RST_CLK_RTC_HSIclkEnable ( FunctionalState NewState )
0002e8  4948              LDR      r1,|L1.1036|
;;;1277   {
;;;1278   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1279     uint32_t temp = 0;
;;;1280   #endif
;;;1281     /* Check the parameters */
;;;1282     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1283   
;;;1284   #if defined  (USE_MDR1986VE9x)
;;;1285     *(__IO uint32_t *) HSI_RTC_EN_BB = (uint32_t) NewState;
0002ea  f8c10324          STR      r0,[r1,#0x324]
;;;1286   #endif
;;;1287   
;;;1288   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1289   
;;;1290       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1291     /* Form new value */
;;;1292     if (NewState != DISABLE){
;;;1293       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1294       temp |= RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1295     }
;;;1296     else{
;;;1297       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1298       temp &= ~RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1299     }
;;;1300     /* Configure RTC_CLOCK register with new value */
;;;1301     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1302   
;;;1303   #endif
;;;1304   }
0002ee  4770              BX       lr
;;;1305   
                          ENDP

                  RST_CLK_HSEclkPrescaler PROC
;;;1320     */
;;;1321   void RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue)
0002f0  4a42              LDR      r2,|L1.1020|
;;;1322   {
;;;1323     uint32_t temp;
;;;1324   
;;;1325     /* Check the parameters */
;;;1326     assert_param(IS_RST_CLK_HSEclkDivValue(HSEclkDivValue));
;;;1327   
;;;1328     temp = MDR_RST_CLK->RTC_CLOCK;
0002f2  6991              LDR      r1,[r2,#0x18]
;;;1329     /* Clear HSE_SEL bits */
;;;1330     temp &= HSE_SELclr;
0002f4  f021010f          BIC      r1,r1,#0xf
;;;1331     /* Set the HSE_SEL bits */
;;;1332     temp |= HSEclkDivValue<<HSE_SEL_OFFSET;
0002f8  4301              ORRS     r1,r1,r0
;;;1333     /* Store the new value */
;;;1334     MDR_RST_CLK->RTC_CLOCK = temp;
0002fa  6191              STR      r1,[r2,#0x18]
;;;1335   }
0002fc  4770              BX       lr
;;;1336   
                          ENDP

                  RST_CLK_RTC_HSEclkEnable PROC
;;;1343     */
;;;1344   void RST_CLK_RTC_HSEclkEnable(FunctionalState NewState)
0002fe  4943              LDR      r1,|L1.1036|
;;;1345   {
;;;1346   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1347     uint32_t temp = 0;
;;;1348   #endif
;;;1349     /* Check the parameters */
;;;1350     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1351   
;;;1352   #if defined  (USE_MDR1986VE9x)
;;;1353     *(__IO uint32_t *) HSE_RTC_EN_BB = (uint32_t)NewState;
000300  f8c10320          STR      r0,[r1,#0x320]
;;;1354   #endif
;;;1355   
;;;1356   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1357   
;;;1358       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1359     /* Form new value */
;;;1360     if (NewState != DISABLE){
;;;1361       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1362       temp |= RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1363     }
;;;1364     else{
;;;1365       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1366       temp &= ~RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1367     }
;;;1368     /* Configure RTC_CLOCK register with new value */
;;;1369     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1370   
;;;1371   #endif
;;;1372   }
000304  4770              BX       lr
;;;1373   
                          ENDP

                  RST_CLK_GetClocksFreq PROC
;;;1458     */
;;;1459   void RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks)
000306  e92d4ff0          PUSH     {r4-r11,lr}
;;;1460   {
;;;1461     uint32_t cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
;;;1462     uint32_t usb_c1_freq, usb_c2_freq, usb_c3_freq;
;;;1463     uint32_t adc_c1_freq, adc_c2_freq, adc_c3_freq;
;;;1464     uint32_t hsi_c1_freq, hse_c1_freq;
;;;1465     uint32_t pll_mul;
;;;1466     uint32_t temp;
;;;1467   
;;;1468     /* Check the parameter */
;;;1469     assert_param(RST_CLK_Clocks != 0);
;;;1470   
;;;1471     /* Compute CPU_CLK, USB_CLK, ADC_CLK, RTCHSI, RTCHSE clocks frequencies */
;;;1472   
;;;1473     /* Compute CPU_CLK frequency */
;;;1474   
;;;1475     /* Determine CPU_C1 frequency */
;;;1476     if( MDR_RST_CLK->CPU_CLOCK & (2 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
00030a  f8dfc0f0          LDR      r12,|L1.1020|
00030e  f8dc100c          LDR      r1,[r12,#0xc]
;;;1477       cpu_c1_freq = HSE_Value;
000312  4f3f              LDR      r7,|L1.1040|
000314  0789              LSLS     r1,r1,#30             ;1476
;;;1478     }
;;;1479     else {
;;;1480       cpu_c1_freq = HSI_Value;
000316  ea4f0567          ASR      r5,r7,#1
00031a  d501              BPL      |L1.800|
00031c  4639              MOV      r1,r7                 ;1477
00031e  e000              B        |L1.802|
                  |L1.800|
000320  4629              MOV      r1,r5
                  |L1.802|
;;;1481     }
;;;1482     if( MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
000322  f8dc200c          LDR      r2,[r12,#0xc]
000326  07d2              LSLS     r2,r2,#31
000328  d000              BEQ      |L1.812|
;;;1483       cpu_c1_freq /= 2;
00032a  0849              LSRS     r1,r1,#1
                  |L1.812|
;;;1484     }
;;;1485   
;;;1486     /* Determine CPU_C2 frequency */
;;;1487     cpu_c2_freq = cpu_c1_freq;
;;;1488   
;;;1489     if (MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos)) {
00032c  f8dc200c          LDR      r2,[r12,#0xc]
000330  460b              MOV      r3,r1                 ;1487
000332  0752              LSLS     r2,r2,#29
000334  d506              BPL      |L1.836|
;;;1490       /* Determine CPU PLL output frequency */
;;;1491       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
000336  f8dc2004          LDR      r2,[r12,#4]
00033a  f3c22203          UBFX     r2,r2,#8,#4
00033e  1c52              ADDS     r2,r2,#1
;;;1492           >> RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1493       cpu_c2_freq *= pll_mul;
000340  fb01f302          MUL      r3,r1,r2
                  |L1.836|
;;;1494     }
;;;1495   
;;;1496     /*Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases */
;;;1497     switch ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_HCLK_SEL_Pos)
000344  f8dc200c          LDR      r2,[r12,#0xc]
;;;1498         & (uint32_t) 0x03) {
;;;1499       case 0:
;;;1500         /* HSI */
;;;1501         RST_CLK_Clocks->CPU_CLK_Frequency = HSI_Value;
;;;1502         break;
;;;1503       case 1:
;;;1504         /* CPU_C3 */
;;;1505         /* Determine CPU_C3 frequency */
;;;1506         if ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
;;;1507             & (uint32_t) 0x08) == 0x00) {
;;;1508           cpu_c3_freq = cpu_c2_freq;
;;;1509         }
;;;1510         else {
;;;1511           cpu_c3_freq = cpu_c2_freq
;;;1512               / (1
;;;1513                   << ((MDR_RST_CLK->CPU_CLOCK
;;;1514                       >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
;;;1515                       & (uint32_t) 0x07) + 1));
;;;1516         }
;;;1517         RST_CLK_Clocks->CPU_CLK_Frequency = cpu_c3_freq;
;;;1518         break;
;;;1519       case 2:
;;;1520         /* LSE */
;;;1521         RST_CLK_Clocks->CPU_CLK_Frequency = LSE_Value;
000348  f44f4a00          MOV      r10,#0x8000
00034c  f3c22201          UBFX     r2,r2,#8,#2           ;1497
;;;1522         break;
;;;1523       default: /* case 3 */
;;;1524         /* LSI */
;;;1525         RST_CLK_Clocks->CPU_CLK_Frequency = LSI_Value;
000350  f6494b40          MOV      r11,#0x9c40
000354  2601              MOVS     r6,#1                 ;1511
000356  b15a              CBZ      r2,|L1.880|
000358  2a01              CMP      r2,#1                 ;1497
00035a  d00b              BEQ      |L1.884|
00035c  2a02              CMP      r2,#2                 ;1497
00035e  d01b              BEQ      |L1.920|
000360  f8c0b000          STR      r11,[r0,#0]
                  |L1.868|
;;;1526         break;
;;;1527     }
;;;1528   
;;;1529     /* Compute USB_CLK frequency */
;;;1530   
;;;1531     /* Determine USB_C1 frequency */
;;;1532     if( MDR_RST_CLK->USB_CLOCK & (2 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
000364  f8dc2010          LDR      r2,[r12,#0x10]
000368  0792              LSLS     r2,r2,#30
00036a  d518              BPL      |L1.926|
;;;1533       usb_c1_freq = HSE_Value;
00036c  463a              MOV      r2,r7
00036e  e017              B        |L1.928|
                  |L1.880|
000370  6005              STR      r5,[r0,#0]            ;1502
000372  e7f7              B        |L1.868|
                  |L1.884|
000374  f8dc200c          LDR      r2,[r12,#0xc]         ;1506
000378  0912              LSRS     r2,r2,#4              ;1506
00037a  0712              LSLS     r2,r2,#28             ;1506
00037c  d401              BMI      |L1.898|
00037e  461a              MOV      r2,r3                 ;1508
000380  e008              B        |L1.916|
                  |L1.898|
000382  f8dc200c          LDR      r2,[r12,#0xc]         ;1511
000386  f3c21202          UBFX     r2,r2,#4,#3           ;1511
00038a  1c52              ADDS     r2,r2,#1              ;1511
00038c  fa06f202          LSL      r2,r6,r2              ;1511
000390  fbb3f2f2          UDIV     r2,r3,r2              ;1511
                  |L1.916|
000394  6002              STR      r2,[r0,#0]            ;1518
000396  e7e5              B        |L1.868|
                  |L1.920|
000398  f8c0a000          STR      r10,[r0,#0]           ;1522
00039c  e7e2              B        |L1.868|
                  |L1.926|
;;;1534     }
;;;1535     else {
;;;1536       usb_c1_freq = HSI_Value;
00039e  462a              MOV      r2,r5
                  |L1.928|
;;;1537     }
;;;1538   
;;;1539     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
0003a0  f8dc4010          LDR      r4,[r12,#0x10]
0003a4  07e4              LSLS     r4,r4,#31
0003a6  d000              BEQ      |L1.938|
;;;1540       usb_c1_freq /= 2;
0003a8  0852              LSRS     r2,r2,#1
                  |L1.938|
;;;1541     }
;;;1542   
;;;1543     /* Determine USB_C2 frequency */
;;;1544     usb_c2_freq = usb_c1_freq;
;;;1545   
;;;1546     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C2_SEL_Pos) ){
0003aa  f8dc8010          LDR      r8,[r12,#0x10]
0003ae  4614              MOV      r4,r2                 ;1544
0003b0  ea5f7848          LSLS     r8,r8,#29
0003b4  d507              BPL      |L1.966|
;;;1547       /* Determine USB PLL output frequency */
;;;1548       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
0003b6  f8dc8004          LDR      r8,[r12,#4]
0003ba  f3c81803          UBFX     r8,r8,#4,#4
0003be  f1080801          ADD      r8,r8,#1
;;;1549           >> RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1550       usb_c2_freq *= pll_mul;
0003c2  fb02f408          MUL      r4,r2,r8
                  |L1.966|
;;;1551     }
;;;1552   
;;;1553     /* Determine USB_C3 frequency */
;;;1554     usb_c3_freq = usb_c2_freq;
;;;1555     if(MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C3_SEL_Pos)){
0003c6  46e1              MOV      r9,r12
0003c8  f8dcc010          LDR      r12,[r12,#0x10]
0003cc  46a0              MOV      r8,r4                 ;1554
0003ce  ea5f6ccc          LSLS     r12,r12,#27
0003d2  d501              BPL      |L1.984|
;;;1556       usb_c3_freq /= 2;
0003d4  ea4f0854          LSR      r8,r4,#1
                  |L1.984|
;;;1557     }
;;;1558   
;;;1559     RST_CLK_Clocks->USB_CLK_Frequency = usb_c3_freq;
;;;1560   
;;;1561     /* Compute RTCHSI_CLK frequency */
;;;1562     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSI_SEL_Pos;
0003d8  f8c08004          STR      r8,[r0,#4]
0003dc  f8d9c018          LDR      r12,[r9,#0x18]
0003e0  ea4f1c1c          LSR      r12,r12,#4
;;;1563     if ((temp & 0x08U) == 0) {
0003e4  ea5f780c          LSLS     r8,r12,#28
0003e8  d507              BPL      |L1.1018|
;;;1564       hsi_c1_freq = HSI_Value;
;;;1565     }
;;;1566     else {
;;;1567       temp = 1 << ((temp & 0x07U) + 1);
0003ea  f00c0807          AND      r8,r12,#7
0003ee  f1080801          ADD      r8,r8,#1
0003f2  fa06fc08          LSL      r12,r6,r8
;;;1568       hsi_c1_freq = HSI_Value / temp;
0003f6  fbb5f5fc          UDIV     r5,r5,r12
                  |L1.1018|
;;;1569     }
;;;1570     RST_CLK_Clocks->RTCHSI_Frequency = hsi_c1_freq;
;;;1571   
;;;1572     /* Compute RTCHSE_CLK frequency */
;;;1573     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSE_SEL_Pos;
0003fa  e00b              B        |L1.1044|
                  |L1.1020|
                          DCD      0x40020000
                  |L1.1024|
                          DCD      0x400d8000
                  |L1.1028|
                          DCD      0x43b007d8
                  |L1.1032|
                          DCD      0x08000010
                  |L1.1036|
                          DCD      0x42400000
                  |L1.1040|
                          DCD      0x00f42400
                  |L1.1044|
000414  60c5              STR      r5,[r0,#0xc]
000416  f8d9c018          LDR      r12,[r9,#0x18]
;;;1574     if ((temp & 0x08U) == 0) {
00041a  ea5f780c          LSLS     r8,r12,#28
00041e  d507              BPL      |L1.1072|
;;;1575       hse_c1_freq = HSE_Value;
;;;1576     }
;;;1577     else {
;;;1578       temp = 1 << ((temp & 0x07U) + 1);
000420  f00c0807          AND      r8,r12,#7
000424  f1080801          ADD      r8,r8,#1
000428  fa06fc08          LSL      r12,r6,r8
;;;1579       hse_c1_freq = HSE_Value / temp;
00042c  fbb7f7fc          UDIV     r7,r7,r12
                  |L1.1072|
;;;1580     }
;;;1581     RST_CLK_Clocks->RTCHSE_Frequency = hse_c1_freq;
;;;1582   
;;;1583     /* Compute ADC_CLK frequency */
;;;1584   
;;;1585     /* Select ADC_C1 from CPU_C1, LSI, USB_C1, CPU_C2, USB_C2 cases */
;;;1586     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos)
000430  6107              STR      r7,[r0,#0x10]
000432  f8d9c014          LDR      r12,[r9,#0x14]
000436  464f              MOV      r7,r9
000438  f01c0c03          ANDS     r12,r12,#3
00043c  d006              BEQ      |L1.1100|
00043e  f1bc0f01          CMP      r12,#1
000442  d019              BEQ      |L1.1144|
000444  f1bc0f02          CMP      r12,#2
000448  d018              BEQ      |L1.1148|
;;;1587         & (uint32_t) 0x03) {
;;;1588       case 0:
;;;1589         /* CPU_C1 */
;;;1590         adc_c1_freq = cpu_c1_freq;
;;;1591         break;
;;;1592       case 1:
;;;1593         /* USB_C1 */
;;;1594         adc_c1_freq = usb_c1_freq;
;;;1595         break;
;;;1596       case 2:
;;;1597         /* CPU_C2 */
;;;1598         adc_c1_freq = cpu_c2_freq;
;;;1599         break;
;;;1600       default: /* case 3 */
;;;1601         /* USB_C2 */
;;;1602         adc_c1_freq = usb_c2_freq;
00044a  4621              MOV      r1,r4
                  |L1.1100|
;;;1603         break;
;;;1604     }
;;;1605   
;;;1606     /* Select ADC_C2 from LSE, LSI, ADC_C1, HSI_C1 cases */
;;;1607     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos)
00044c  697a              LDR      r2,[r7,#0x14]
00044e  f3c21201          UBFX     r2,r2,#4,#2
000452  b1aa              CBZ      r2,|L1.1152|
000454  2a01              CMP      r2,#1
000456  d015              BEQ      |L1.1156|
000458  2a02              CMP      r2,#2
00045a  d000              BEQ      |L1.1118|
;;;1608         & (uint32_t) 0x03) {
;;;1609       case 0:
;;;1610         /* LSE */
;;;1611         adc_c2_freq = LSE_Value;
;;;1612         break;
;;;1613       case 1:
;;;1614         /* LSI */
;;;1615         adc_c2_freq = LSI_Value;
;;;1616         break;
;;;1617       case 2:
;;;1618         /* ADC_C1 */
;;;1619         adc_c2_freq = adc_c1_freq;
;;;1620         break;
;;;1621       default: /* case 3 */
;;;1622         /* HSI_C1 */
;;;1623         adc_c2_freq = hsi_c1_freq;
00045c  4629              MOV      r1,r5
                  |L1.1118|
;;;1624         break;
;;;1625     }
;;;1626   
;;;1627     temp = MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos;
00045e  697a              LDR      r2,[r7,#0x14]
000460  0a12              LSRS     r2,r2,#8
;;;1628     if ((temp & 0x08U) == 0) {
000462  0713              LSLS     r3,r2,#28
000464  d505              BPL      |L1.1138|
;;;1629       adc_c3_freq = adc_c2_freq;
;;;1630     }
;;;1631     else {
;;;1632       temp = 1 << ((temp & 0x07U) + 1);
000466  f0020207          AND      r2,r2,#7
00046a  1c52              ADDS     r2,r2,#1
00046c  4096              LSLS     r6,r6,r2
;;;1633       adc_c3_freq = adc_c2_freq / temp;
00046e  fbb1f1f6          UDIV     r1,r1,r6
                  |L1.1138|
;;;1634     }
;;;1635   
;;;1636     RST_CLK_Clocks->ADC_CLK_Frequency = adc_c3_freq;
000472  6081              STR      r1,[r0,#8]
;;;1637   }
000474  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1144|
000478  4611              MOV      r1,r2                 ;1594
00047a  e7e7              B        |L1.1100|
                  |L1.1148|
00047c  4619              MOV      r1,r3                 ;1598
00047e  e7e5              B        |L1.1100|
                  |L1.1152|
000480  4651              MOV      r1,r10                ;1611
000482  e7ec              B        |L1.1118|
                  |L1.1156|
000484  4659              MOV      r1,r11                ;1615
000486  e7ea              B        |L1.1118|
;;;1638   
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_rst_clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH|
#line 144
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
