; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list -c --asm --interleave -o.\objects\mdr32f9qx_ssp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mdr32f9qx_ssp.d --cpu=Cortex-M3 --apcs=interwork -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE\Device\MDR1986BE92 -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=513 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 -W --enum_is_int --signed_chars C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_ssp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SSP_DeInit PROC
;;;56       */
;;;57     void SSP_DeInit(MDR_SSP_TypeDef* SSPx)
000000  2100              MOVS     r1,#0
;;;58     {
;;;59       /* Check the parameters */
;;;60       assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;61     
;;;62       SSPx->CR0   = 0;
000002  6001              STR      r1,[r0,#0]
;;;63       SSPx->CR1   = 0;
000004  6041              STR      r1,[r0,#4]
;;;64       SSPx->CPSR  = 0;
000006  6101              STR      r1,[r0,#0x10]
;;;65       SSPx->IMSC  = 0;
000008  6141              STR      r1,[r0,#0x14]
;;;66       SSPx->DMACR = 0;
00000a  6241              STR      r1,[r0,#0x24]
;;;67     
;;;68       /* Clear SSP ICR[RTIC] and SSP ICR[RORIC] bits */
;;;69       SSPx->ICR = SSP_IT_RT | SSP_IT_ROR;
00000c  2103              MOVS     r1,#3
00000e  6201              STR      r1,[r0,#0x20]
;;;70     
;;;71     }
000010  4770              BX       lr
;;;72     
                          ENDP

                  SSP_Init PROC
;;;82       */
;;;83     void SSP_Init(MDR_SSP_TypeDef* SSPx, const SSP_InitTypeDef* SSP_InitStruct)
000012  b510              PUSH     {r4,lr}
;;;84     {
;;;85       uint32_t tmpreg;
;;;86     
;;;87       /* Check the parameters */
;;;88       assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;89       assert_param(IS_SSP_SPEED_FACTOR(SSP_InitStruct->SSP_SCR));
;;;90       assert_param(IS_SSP_SPEED_DIVIDER(SSP_InitStruct->SSP_CPSDVSR));
;;;91       assert_param(IS_SSP_MODE(SSP_InitStruct->SSP_Mode));
;;;92       assert_param(IS_SSP_WORD_LENGTH(SSP_InitStruct->SSP_WordLength));
;;;93       assert_param(IS_SSP_SPH(SSP_InitStruct->SSP_SPH));
;;;94       assert_param(IS_SSP_SPO(SSP_InitStruct->SSP_SPO));
;;;95       assert_param(IS_SSP_FRF(SSP_InitStruct->SSP_FRF));
;;;96       assert_param(IS_SSP_HARDWARE_FLOW_CONTROL(SSP_InitStruct->SSP_HardwareFlowControl));
;;;97     
;;;98       /* SSPx CPSR Configuration */
;;;99       SSPx->CPSR = SSP_InitStruct->SSP_CPSDVSR;
000014  884a              LDRH     r2,[r1,#2]
000016  6102              STR      r2,[r0,#0x10]
;;;100    
;;;101      /* SSPx CR0 Configuration */
;;;102      tmpreg = (SSP_InitStruct->SSP_SCR << SSP_CR0_SCR_Pos)
000018  890a              LDRH     r2,[r1,#8]
00001a  894b              LDRH     r3,[r1,#0xa]
00001c  880c              LDRH     r4,[r1,#0]
00001e  441a              ADD      r2,r2,r3
000020  898b              LDRH     r3,[r1,#0xc]
000022  eb032304          ADD      r3,r3,r4,LSL #8
000026  441a              ADD      r2,r2,r3
000028  88cb              LDRH     r3,[r1,#6]
00002a  441a              ADD      r2,r2,r3
;;;103             + SSP_InitStruct->SSP_SPH
;;;104             + SSP_InitStruct->SSP_SPO
;;;105             + SSP_InitStruct->SSP_FRF
;;;106             + SSP_InitStruct->SSP_WordLength;
;;;107      SSPx->CR0 = tmpreg;
00002c  6002              STR      r2,[r0,#0]
;;;108    
;;;109      /* SSPx CR1 Configuration */
;;;110      tmpreg = SSP_InitStruct->SSP_HardwareFlowControl + SSP_InitStruct->SSP_Mode;
00002e  89ca              LDRH     r2,[r1,#0xe]
000030  8889              LDRH     r1,[r1,#4]
000032  4411              ADD      r1,r1,r2
;;;111      SSPx->CR1 = tmpreg;
000034  6041              STR      r1,[r0,#4]
;;;112    }
000036  bd10              POP      {r4,pc}
;;;113    
                          ENDP

                  SSP_StructInit PROC
;;;119      */
;;;120    void SSP_StructInit(SSP_InitTypeDef* SSP_InitStruct)
000038  2100              MOVS     r1,#0
;;;121    {
;;;122      /* SSP_InitStruct members default value */
;;;123      /* Initialize the SPI_Mode member */
;;;124      SSP_InitStruct->SSP_Mode = SSP_ModeMaster;
00003a  8081              STRH     r1,[r0,#4]
;;;125      /* initialize the SSP_WordLength member */
;;;126      SSP_InitStruct->SSP_WordLength = SSP_WordLength8b;
00003c  2207              MOVS     r2,#7
00003e  80c2              STRH     r2,[r0,#6]
;;;127      /* Initialize the SSP_SPO member */
;;;128      SSP_InitStruct->SSP_SPO = SSP_SPO_Low;
000040  8141              STRH     r1,[r0,#0xa]
;;;129      /* Initialize the SSP_SPH member */
;;;130      SSP_InitStruct->SSP_SPH = SSP_SPH_1Edge;
000042  8101              STRH     r1,[r0,#8]
;;;131      /* Initialize the SSP_FRF member */
;;;132      SSP_InitStruct->SSP_FRF = SSP_FRF_SPI_Motorola;
000044  8181              STRH     r1,[r0,#0xc]
;;;133      /* Initialize the SSP max speed */
;;;134      SSP_InitStruct->SSP_CPSDVSR = 2;
000046  2202              MOVS     r2,#2
000048  8042              STRH     r2,[r0,#2]
;;;135      SSP_InitStruct->SSP_SCR = 0;
00004a  8001              STRH     r1,[r0,#0]
;;;136    
;;;137    }
00004c  4770              BX       lr
;;;138    
                          ENDP

                  SSP_Cmd PROC
;;;147      */
;;;148    void SSP_Cmd(MDR_SSP_TypeDef* SSPx, FunctionalState NewState)
00004e  2900              CMP      r1,#0
;;;149    {
;;;150      /* Check the parameters */
;;;151      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;152      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;153    
;;;154      if (NewState != DISABLE)
;;;155      {
;;;156        /* Enable the selected SSP by setting the SSE bit in the CR1 register */
;;;157        SSPx->CR1 |= CR1_EN_Set;
;;;158      }
;;;159      else
;;;160      {
;;;161        /* Disable the selected SSP by clearing the SSE bit in the CR1 register */
;;;162        SSPx->CR1 &= CR1_EN_Reset;
000050  6841              LDR      r1,[r0,#4]
000052  d002              BEQ      |L1.90|
000054  f0410102          ORR      r1,r1,#2              ;157
000058  e002              B        |L1.96|
                  |L1.90|
00005a  f64f72fd          MOV      r2,#0xfffd
00005e  4011              ANDS     r1,r1,r2
                  |L1.96|
000060  6041              STR      r1,[r0,#4]            ;157
;;;163      }
;;;164    }
000062  4770              BX       lr
;;;165    
                          ENDP

                  SSP_ITConfig PROC
;;;180      */
;;;181    void SSP_ITConfig(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT, FunctionalState NewState)
000064  2a00              CMP      r2,#0
;;;182    {
;;;183      /* Check the parameters */
;;;184      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;185      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;186      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;187    
;;;188      if (NewState != DISABLE)
;;;189      {
;;;190        SSPx->IMSC |= SSP_IT;
;;;191      }
;;;192      else
;;;193      {
;;;194        SSPx->IMSC &= ~SSP_IT;
000066  6942              LDR      r2,[r0,#0x14]
000068  d001              BEQ      |L1.110|
00006a  430a              ORRS     r2,r2,r1              ;190
00006c  e000              B        |L1.112|
                  |L1.110|
00006e  438a              BICS     r2,r2,r1
                  |L1.112|
000070  6142              STR      r2,[r0,#0x14]         ;190
;;;195      }
;;;196    }
000072  4770              BX       lr
;;;197    
                          ENDP

                  SSP_GetITStatus PROC
;;;210      */
;;;211    ITStatus SSP_GetITStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000074  6980              LDR      r0,[r0,#0x18]
;;;212    {
;;;213      ITStatus bitstatus;
;;;214    
;;;215      /* Check the parameters */
;;;216      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;217      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;218    
;;;219      if ((SSPx->RIS & SSP_IT) == SSP_IT)
000076  4381              BICS     r1,r1,r0
000078  d001              BEQ      |L1.126|
;;;220      {
;;;221        bitstatus = SET;
;;;222      }
;;;223      else
;;;224      {
;;;225        bitstatus = RESET;
00007a  2000              MOVS     r0,#0
;;;226      }
;;;227    
;;;228      return (bitstatus);
;;;229    }
00007c  4770              BX       lr
                  |L1.126|
00007e  2001              MOVS     r0,#1                 ;221
000080  4770              BX       lr
;;;230    
                          ENDP

                  SSP_GetITStatusMasked PROC
;;;243      */
;;;244    ITStatus SSP_GetITStatusMasked(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000082  69c0              LDR      r0,[r0,#0x1c]
;;;245    {
;;;246      ITStatus bitstatus;
;;;247    
;;;248      /* Check the parameters */
;;;249      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;250      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;251    
;;;252      if (SSPx->MIS & SSP_IT)
000084  4008              ANDS     r0,r0,r1
000086  d000              BEQ      |L1.138|
;;;253      {
;;;254        bitstatus = SET;
000088  2001              MOVS     r0,#1
                  |L1.138|
;;;255      }
;;;256      else
;;;257      {
;;;258        bitstatus = RESET;
;;;259      }
;;;260    
;;;261      return (bitstatus);
;;;262    }
00008a  4770              BX       lr
;;;263    
                          ENDP

                  SSP_ClearITPendingBit PROC
;;;274      */
;;;275    void SSP_ClearITPendingBit(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
00008c  6a02              LDR      r2,[r0,#0x20]
;;;276    {
;;;277      /* Check the parameters */
;;;278      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;279      assert_param(IS_SSP_RESET_IT(SSP_IT));
;;;280    
;;;281      SSPx->ICR |= SSP_IT;
00008e  430a              ORRS     r2,r2,r1
000090  6202              STR      r2,[r0,#0x20]
;;;282    }
000092  4770              BX       lr
;;;283    
                          ENDP

                  SSP_DMACmd PROC
;;;297      */
;;;298    void SSP_DMACmd(MDR_SSP_TypeDef* SSPx, uint32_t SSP_DMAReq, FunctionalState NewState)
000094  2a00              CMP      r2,#0
;;;299    {
;;;300      /* Check the parameters */
;;;301      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;302      assert_param(IS_SSP_DMAREQ(SSP_DMAReq));
;;;303      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;304    
;;;305      if (NewState != DISABLE)
;;;306      {
;;;307        /* Enable the DMA transfer for selected requests in the SSP DMACR register */
;;;308        SSPx->DMACR |= SSP_DMAReq;
;;;309      }
;;;310      else
;;;311      {
;;;312        /* Disable the DMA transfer for selected requests in the SSP DMACR register */
;;;313        SSPx->DMACR &= (uint16_t)~SSP_DMAReq;
000096  6a42              LDR      r2,[r0,#0x24]
000098  d001              BEQ      |L1.158|
00009a  430a              ORRS     r2,r2,r1              ;308
00009c  e002              B        |L1.164|
                  |L1.158|
00009e  43c9              MVNS     r1,r1
0000a0  b289              UXTH     r1,r1
0000a2  400a              ANDS     r2,r2,r1
                  |L1.164|
0000a4  6242              STR      r2,[r0,#0x24]         ;308
;;;314      }
;;;315    }
0000a6  4770              BX       lr
;;;316    
                          ENDP

                  SSP_SendData PROC
;;;324      */
;;;325    void SSP_SendData(MDR_SSP_TypeDef* SSPx, uint16_t Data)
0000a8  6081              STR      r1,[r0,#8]
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;329    
;;;330      /* Transmit Data */
;;;331      SSPx->DR = Data;
;;;332    
;;;333    }
0000aa  4770              BX       lr
;;;334    
                          ENDP

                  SSP_ReceiveData PROC
;;;341      */
;;;342    uint16_t SSP_ReceiveData(MDR_SSP_TypeDef* SSPx)
0000ac  6880              LDR      r0,[r0,#8]
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;346    
;;;347      /* Receive Data */
;;;348      return ((uint16_t)(SSPx->DR));
0000ae  b280              UXTH     r0,r0
;;;349    }
0000b0  4770              BX       lr
;;;350    
                          ENDP

                  SSP_GetFlagStatus PROC
;;;363      */
;;;364    FlagStatus SSP_GetFlagStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_FLAG)
0000b2  68c0              LDR      r0,[r0,#0xc]
;;;365    {
;;;366      FlagStatus bitstatus;
;;;367    
;;;368      /* Check the parameters */
;;;369      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;370      assert_param(IS_SSP_FLAG(SSP_FLAG));
;;;371    
;;;372      if (SSPx->SR & SSP_FLAG)
0000b4  4008              ANDS     r0,r0,r1
0000b6  d000              BEQ      |L1.186|
;;;373      {
;;;374        bitstatus = SET;
0000b8  2001              MOVS     r0,#1
                  |L1.186|
;;;375      }
;;;376      else
;;;377      {
;;;378        bitstatus = RESET;
;;;379      }
;;;380    
;;;381      return (bitstatus);
;;;382    }
0000ba  4770              BX       lr
;;;383    
                          ENDP

                  SSP_BRGInit PROC
;;;401      */
;;;402    void SSP_BRGInit ( MDR_SSP_TypeDef* SSPx, uint32_t SSP_BRG ) {
0000bc  4b0b              LDR      r3,|L1.236|
0000be  b510              PUSH     {r4,lr}
;;;403    	uint32_t tmpreg;
;;;404    
;;;405    	/* Check the parameters */
;;;406    	assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;407    	assert_param(IS_SSP_CLOCK_BRG(SSP_BRG));
;;;408    
;;;409    #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;410    	if ( (SSPx != MDR_SSP1) && (SSPx != MDR_SSP2) && (SSPx != MDR_SSP3)) {
;;;411    		tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;412    	}
;;;413    	else
;;;414    #endif	// #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;415    		tmpreg = MDR_RST_CLK->SSP_CLOCK;
0000c0  6ada              LDR      r2,[r3,#0x2c]
;;;416    
;;;417    
;;;418    
;;;419    	if (SSPx == MDR_SSP1) {
0000c2  4c0b              LDR      r4,|L1.240|
0000c4  42a0              CMP      r0,r4
0000c6  d105              BNE      |L1.212|
;;;420    		tmpreg |= RST_CLK_SSP_CLOCK_SSP1_CLK_EN;
0000c8  f02200ff          BIC      r0,r2,#0xff
;;;421    		tmpreg &= ~RST_CLK_SSP_CLOCK_SSP1_BRG_Msk;
0000cc  f0407280          ORR      r2,r0,#0x1000000
;;;422    		tmpreg |= SSP_BRG;
0000d0  430a              ORRS     r2,r2,r1
0000d2  e008              B        |L1.230|
                  |L1.212|
;;;423    	}
;;;424    	else{
;;;425    		if (SSPx == MDR_SSP2) {
0000d4  4c07              LDR      r4,|L1.244|
0000d6  42a0              CMP      r0,r4
0000d8  d105              BNE      |L1.230|
;;;426    			tmpreg |= RST_CLK_SSP_CLOCK_SSP2_CLK_EN;
0000da  f422407f          BIC      r0,r2,#0xff00
;;;427    			tmpreg &= ~RST_CLK_SSP_CLOCK_SSP2_BRG_Msk;
0000de  f0407000          ORR      r0,r0,#0x2000000
;;;428    			tmpreg |= (SSP_BRG << 8);
0000e2  ea402201          ORR      r2,r0,r1,LSL #8
                  |L1.230|
;;;429    		}
;;;430    #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;431    		else{
;;;432    			if(SSPx == MDR_SSP3) {
;;;433    				tmpreg |= RST_CLK_SSP_CLOCK_SSP3_CLK_EN;
;;;434    				tmpreg &= ~RST_CLK_SSP_CLOCK_SSP3_BRG_Msk;
;;;435    				tmpreg |= (SSP_BRG << 16);
;;;436    			}
;;;437    
;;;438    			else{
;;;439    				if(SSPx == MDR_SSP4) {
;;;440    					tmpreg |= RST_CLK_UART_SSP_CLOCK_SSP4_CLK_EN;
;;;441    					tmpreg &= ~RST_CLK_UART_SSP_CLOCK_SSP4_BRG_Msk;
;;;442    					tmpreg |= (SSP_BRG << 16);
;;;443    				}
;;;444    			}
;;;445    		}
;;;446    #endif // #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;447    	}
;;;448    #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;449    	if( (SSPx != MDR_SSP1) && (SSPx != MDR_SSP2) && (SSPx != MDR_SSP3) ){
;;;450    		MDR_RST_CLK->UART_SSP_CLOCK = tmpreg;
;;;451    	}
;;;452    	else
;;;453    #endif // #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;454    		MDR_RST_CLK->SSP_CLOCK = tmpreg;
0000e6  62da              STR      r2,[r3,#0x2c]
;;;455    
;;;456    }
0000e8  bd10              POP      {r4,pc}
;;;457    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L1.236|
                          DCD      0x40020000
                  |L1.240|
                          DCD      0x40040000
                  |L1.244|
                          DCD      0x400a0000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_ssp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____REVSH|
#line 144
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
