; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list -c --asm --interleave -o.\objects\mdr32f9qx_timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mdr32f9qx_timer.d --cpu=Cortex-M3 --apcs=interwork -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE\Device\MDR1986BE92 -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=513 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 -W --enum_is_int --signed_chars C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIMER_DeInit PROC
;;;45       */
;;;46     void TIMER_DeInit ( MDR_TIMER_TypeDef* TIMERx ) {
000000  2100              MOVS     r1,#0
;;;47     	/* Check the parameters */
;;;48     	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;49     
;;;50     	TIMERx->CNTRL = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;51     	TIMERx->CNT = 0;
000004  6001              STR      r1,[r0,#0]
;;;52     	TIMERx->PSG = 0;
000006  6041              STR      r1,[r0,#4]
;;;53     	TIMERx->ARR = 0;
000008  6081              STR      r1,[r0,#8]
;;;54     
;;;55     	TIMERx->CH1_CNTRL = 0;
00000a  6201              STR      r1,[r0,#0x20]
;;;56     	TIMERx->CH2_CNTRL = 0;
00000c  6241              STR      r1,[r0,#0x24]
;;;57     	TIMERx->CH3_CNTRL = 0;
00000e  6281              STR      r1,[r0,#0x28]
;;;58     	TIMERx->CH4_CNTRL = 0;
000010  62c1              STR      r1,[r0,#0x2c]
;;;59     	TIMERx->CH1_CNTRL1 = 0;
000012  6301              STR      r1,[r0,#0x30]
;;;60     	TIMERx->CH2_CNTRL1 = 0;
000014  6341              STR      r1,[r0,#0x34]
;;;61     	TIMERx->CH3_CNTRL1 = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;62     	TIMERx->CH4_CNTRL1 = 0;
000018  63c1              STR      r1,[r0,#0x3c]
;;;63     	TIMERx->CH1_CNTRL2 = 0;
00001a  6601              STR      r1,[r0,#0x60]
;;;64     	TIMERx->CH2_CNTRL2 = 0;
00001c  6641              STR      r1,[r0,#0x64]
;;;65     	TIMERx->CH3_CNTRL2 = 0;
00001e  6681              STR      r1,[r0,#0x68]
;;;66     	TIMERx->CH4_CNTRL2 = 0;
000020  66c1              STR      r1,[r0,#0x6c]
;;;67     
;;;68     	TIMERx->CCR1 = 0;
000022  6101              STR      r1,[r0,#0x10]
;;;69     	TIMERx->CCR2 = 0;
000024  6141              STR      r1,[r0,#0x14]
;;;70     	TIMERx->CCR3 = 0;
000026  6181              STR      r1,[r0,#0x18]
;;;71     	TIMERx->CCR4 = 0;
000028  61c1              STR      r1,[r0,#0x1c]
;;;72     	TIMERx->CCR11 = 0;
00002a  6701              STR      r1,[r0,#0x70]
;;;73     	TIMERx->CCR21 = 0;
00002c  6741              STR      r1,[r0,#0x74]
;;;74     	TIMERx->CCR31 = 0;
00002e  6781              STR      r1,[r0,#0x78]
;;;75     	TIMERx->CCR41 = 0;
000030  67c1              STR      r1,[r0,#0x7c]
;;;76     	TIMERx->CH1_DTG = 0;
000032  6401              STR      r1,[r0,#0x40]
;;;77     	TIMERx->CH2_DTG = 0;
000034  6441              STR      r1,[r0,#0x44]
;;;78     	TIMERx->CH3_DTG = 0;
000036  6481              STR      r1,[r0,#0x48]
;;;79     	TIMERx->CH4_DTG = 0;
000038  64c1              STR      r1,[r0,#0x4c]
;;;80     	TIMERx->BRKETR_CNTRL = 0;
00003a  6501              STR      r1,[r0,#0x50]
;;;81     	TIMERx->STATUS = 0;
00003c  6541              STR      r1,[r0,#0x54]
;;;82     	TIMERx->IE = 0;
00003e  6581              STR      r1,[r0,#0x58]
;;;83     	TIMERx->DMA_RE = 0;
000040  65c1              STR      r1,[r0,#0x5c]
;;;84     #if defined(USE_MDR1986VE3) || defined (USE_MDR1986VE1T) /* For Cortex M1 */
;;;85     	TIMERx->DMA_REChx[0] = TIMERx->DMA_REChx[1] =
;;;86     			TIMERx->DMA_REChx[2] = TIMERx->DMA_REChx[3] = 0;
;;;87     #endif
;;;88     }
000042  4770              BX       lr
;;;89     
                          ENDP

                  TIMER_CntInit PROC
;;;98       */
;;;99     void TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000044  b510              PUSH     {r4,lr}
;;;100    {
;;;101      uint32_t tmpreg_CNTRL;
;;;102      uint32_t tmpreg_BRKETR_CNTRL;
;;;103    
;;;104      /* Check the parameters */
;;;105      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;106      assert_param(IS_TIMER_COUNTER_MODE(TIMER_CntInitStruct->TIMER_CounterMode));
;;;107      assert_param(IS_TIMER_COUNTER_DIR(TIMER_CntInitStruct->TIMER_CounterDirection));
;;;108      assert_param(IS_TIMER_EVENT_SOURCE(TIMER_CntInitStruct->TIMER_EventSource));
;;;109      assert_param(IS_TIMER_FILTER_SAMPLING(TIMER_CntInitStruct->TIMER_FilterSampling));
;;;110      assert_param(IS_TIMER_ARR_UPDATE_MODE(TIMER_CntInitStruct->TIMER_ARR_UpdateMode));
;;;111      assert_param(IS_TIMER_FILTER_CONF(TIMER_CntInitStruct->TIMER_ETR_FilterConf));
;;;112      assert_param(IS_TIMER_ETR_PRESCALER(TIMER_CntInitStruct->TIMER_ETR_Prescaler));
;;;113      assert_param(IS_TIMER_ETR_POLARITY(TIMER_CntInitStruct->TIMER_ETR_Polarity));
;;;114      assert_param(IS_TIMER_BRK_POLARITY(TIMER_CntInitStruct->TIMER_BRK_Polarity));
;;;115    
;;;116      TIMERx->CNT = TIMER_CntInitStruct->TIMER_IniCounter;
000046  880a              LDRH     r2,[r1,#0]
000048  6002              STR      r2,[r0,#0]
;;;117      TIMERx->PSG = TIMER_CntInitStruct->TIMER_Prescaler;
00004a  884a              LDRH     r2,[r1,#2]
00004c  6042              STR      r2,[r0,#4]
;;;118      TIMERx->ARR = TIMER_CntInitStruct->TIMER_Period;
00004e  888a              LDRH     r2,[r1,#4]
000050  6082              STR      r2,[r0,#8]
;;;119    
;;;120      /* Form new value for the TIMERx_CNTRL register */
;;;121      tmpreg_CNTRL = TIMER_CntInitStruct->TIMER_CounterMode
000052  88ca              LDRH     r2,[r1,#6]
000054  890b              LDRH     r3,[r1,#8]
000056  898c              LDRH     r4,[r1,#0xc]
000058  441a              ADD      r2,r2,r3
00005a  894b              LDRH     r3,[r1,#0xa]
00005c  4423              ADD      r3,r3,r4
00005e  441a              ADD      r2,r2,r3
000060  89cb              LDRH     r3,[r1,#0xe]
000062  441a              ADD      r2,r2,r3
;;;122                   + TIMER_CntInitStruct->TIMER_CounterDirection
;;;123                   + TIMER_CntInitStruct->TIMER_EventSource
;;;124                   + TIMER_CntInitStruct->TIMER_FilterSampling
;;;125                   + TIMER_CntInitStruct->TIMER_ARR_UpdateMode;
;;;126    
;;;127      /* Configure TIMERx_CNTRL register with new value */
;;;128      TIMERx->CNTRL = tmpreg_CNTRL;
000064  60c2              STR      r2,[r0,#0xc]
;;;129    
;;;130      /* Form new value for the TIMERx_BRKETR_CNTRL register */
;;;131      tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos)
000066  8a4a              LDRH     r2,[r1,#0x12]
000068  8a8b              LDRH     r3,[r1,#0x14]
00006a  441a              ADD      r2,r2,r3
00006c  8acb              LDRH     r3,[r1,#0x16]
00006e  8a09              LDRH     r1,[r1,#0x10]
000070  eb031101          ADD      r1,r3,r1,LSL #4
000074  4411              ADD      r1,r1,r2
;;;132                          + TIMER_CntInitStruct->TIMER_ETR_Prescaler
;;;133                          + TIMER_CntInitStruct->TIMER_ETR_Polarity
;;;134                          + TIMER_CntInitStruct->TIMER_BRK_Polarity;
;;;135    
;;;136      /* Configure TIMERx_BRKETR_CNTRL register with new value */
;;;137      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000076  6501              STR      r1,[r0,#0x50]
;;;138    }
000078  bd10              POP      {r4,pc}
;;;139    
                          ENDP

                  TIMER_CntStructInit PROC
;;;145      */
;;;146    void TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct)
00007a  2100              MOVS     r1,#0
;;;147    {
;;;148      TIMER_CntInitStruct->TIMER_IniCounter = 0;
00007c  8001              STRH     r1,[r0,#0]
;;;149      TIMER_CntInitStruct->TIMER_Prescaler  = 0;
00007e  8041              STRH     r1,[r0,#2]
;;;150      TIMER_CntInitStruct->TIMER_Period     = 0;
000080  8081              STRH     r1,[r0,#4]
;;;151      TIMER_CntInitStruct->TIMER_CounterMode      = TIMER_CntMode_ClkFixedDir;
000082  80c1              STRH     r1,[r0,#6]
;;;152      TIMER_CntInitStruct->TIMER_CounterDirection = TIMER_CntDir_Up;
000084  8101              STRH     r1,[r0,#8]
;;;153      TIMER_CntInitStruct->TIMER_EventSource      = TIMER_EvSrc_None;
000086  8141              STRH     r1,[r0,#0xa]
;;;154      TIMER_CntInitStruct->TIMER_FilterSampling   = TIMER_FDTS_TIMER_CLK_div_1;
000088  8181              STRH     r1,[r0,#0xc]
;;;155      TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = TIMER_ARR_Update_Immediately;
00008a  81c1              STRH     r1,[r0,#0xe]
;;;156      TIMER_CntInitStruct->TIMER_ETR_FilterConf   = TIMER_Filter_1FF_at_TIMER_CLK;
00008c  8201              STRH     r1,[r0,#0x10]
;;;157      TIMER_CntInitStruct->TIMER_ETR_Prescaler    = TIMER_ETR_Prescaler_None;
00008e  8241              STRH     r1,[r0,#0x12]
;;;158      TIMER_CntInitStruct->TIMER_ETR_Polarity     = TIMER_ETRPolarity_NonInverted;
000090  8281              STRH     r1,[r0,#0x14]
;;;159      TIMER_CntInitStruct->TIMER_BRK_Polarity     = TIMER_BRKPolarity_NonInverted;
000092  82c1              STRH     r1,[r0,#0x16]
;;;160    }
000094  4770              BX       lr
;;;161    
                          ENDP

                  TIMER_Cmd PROC
;;;168      */
;;;169    void TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)
000096  68c2              LDR      r2,[r0,#0xc]
;;;170    {
000098  b111              CBZ      r1,|L1.160|
;;;171      uint32_t tmpreg_CNTRL;
;;;172    
;;;173      /* Check the parameters */
;;;174      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;175      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;176    
;;;177      tmpreg_CNTRL = TIMERx->CNTRL;
;;;178    
;;;179      /* Form new value */
;;;180      if (NewState != DISABLE)
;;;181      {
;;;182        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;183        tmpreg_CNTRL |= TIMER_CNTRL_CNT_EN;
00009a  f0420101          ORR      r1,r2,#1
00009e  e001              B        |L1.164|
                  |L1.160|
;;;184      }
;;;185      else
;;;186      {
;;;187        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;188        tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_EN;
0000a0  f0220101          BIC      r1,r2,#1
                  |L1.164|
;;;189      }
;;;190    
;;;191      /* Configure CNTRL register with new value */
;;;192      TIMERx->CNTRL = tmpreg_CNTRL;
0000a4  60c1              STR      r1,[r0,#0xc]
;;;193    }
0000a6  4770              BX       lr
;;;194    
                          ENDP

                  TIMER_SetCounter PROC
;;;203    #elif defined (USE_MDR1986VE9x)
;;;204    void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter)
0000a8  6001              STR      r1,[r0,#0]
;;;205    #endif
;;;206    {
;;;207      /* Check the parameters */
;;;208      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;209    
;;;210      TIMERx->CNT = Counter;
;;;211    }
0000aa  4770              BX       lr
;;;212    
                          ENDP

                  TIMER_SetCntPrescaler PROC
;;;218      */
;;;219    void TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler)
0000ac  6041              STR      r1,[r0,#4]
;;;220    {
;;;221      /* Check the parameters */
;;;222      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;223    
;;;224      TIMERx->PSG = Prescaler;
;;;225    }
0000ae  4770              BX       lr
;;;226    
                          ENDP

                  TIMER_SetCntAutoreload PROC
;;;235    #elif defined (USE_MDR1986VE9x)
;;;236    void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload)
0000b0  6081              STR      r1,[r0,#8]
;;;237    #endif
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;241    
;;;242      TIMERx->ARR = Autoreload;
;;;243    }
0000b2  4770              BX       lr
;;;244    
                          ENDP

                  TIMER_CntAutoreloadConfig PROC
;;;257    #elif defined (USE_MDR1986VE9x)
;;;258    void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode)
0000b4  68c3              LDR      r3,[r0,#0xc]
;;;259    #endif
;;;260    {
;;;261      uint32_t tmpreg_CNTRL;
;;;262    
;;;263      /* Check the parameters */
;;;264      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;265      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;266    
;;;267      tmpreg_CNTRL = TIMERx->CNTRL;
;;;268      tmpreg_CNTRL &= ~TIMER_CNTRL_ARRB_EN;
0000b6  f0230302          BIC      r3,r3,#2
;;;269      tmpreg_CNTRL += UpdateMode;
0000ba  441a              ADD      r2,r2,r3
;;;270      TIMERx->CNTRL = tmpreg_CNTRL;
0000bc  60c2              STR      r2,[r0,#0xc]
;;;271    
;;;272      TIMERx->ARR = Autoreload;
0000be  6081              STR      r1,[r0,#8]
;;;273    }
0000c0  4770              BX       lr
;;;274    
                          ENDP

                  TIMER_GetCounter PROC
;;;282    #elif defined (USE_MDR1986VE9x)
;;;283    uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
0000c2  6800              LDR      r0,[r0,#0]
;;;284    #endif
;;;285    {
;;;286      /* Check the parameters */
;;;287      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;288    
;;;289      return TIMERx->CNT;
0000c4  b280              UXTH     r0,r0
;;;290    }
0000c6  4770              BX       lr
;;;291    
                          ENDP

                  TIMER_CntEventSourceConfig PROC
;;;307      */
;;;308    void TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource)
0000c8  68c2              LDR      r2,[r0,#0xc]
;;;309    {
;;;310      uint32_t tmpreg_CNTRL;
;;;311    
;;;312      /* Check the parameters */
;;;313      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;314      assert_param(IS_TIMER_EVENT_SOURCE(EventSource));
;;;315    
;;;316      tmpreg_CNTRL = TIMERx->CNTRL;
;;;317      tmpreg_CNTRL &= ~TIMER_CNTRL_EVENT_SEL_Msk;
0000ca  f4226270          BIC      r2,r2,#0xf00
;;;318      tmpreg_CNTRL += EventSource;
0000ce  4411              ADD      r1,r1,r2
;;;319      TIMERx->CNTRL = tmpreg_CNTRL;
0000d0  60c1              STR      r1,[r0,#0xc]
;;;320    }
0000d2  4770              BX       lr
;;;321    
                          ENDP

                  TIMER_FilterSamplingConfig PROC
;;;332      */
;;;333    void TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
0000d4  68c2              LDR      r2,[r0,#0xc]
;;;334    {
;;;335      uint32_t tmpreg_CNTRL;
;;;336    
;;;337      /* Check the parameters */
;;;338      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;339      assert_param(IS_TIMER_FILTER_SAMPLING(Prescaler));
;;;340    
;;;341      tmpreg_CNTRL = TIMERx->CNTRL;
;;;342      tmpreg_CNTRL &= ~TIMER_CNTRL_FDTS_Msk;
0000d6  f0220230          BIC      r2,r2,#0x30
;;;343      tmpreg_CNTRL += Prescaler;
0000da  4411              ADD      r1,r1,r2
;;;344      TIMERx->CNTRL = tmpreg_CNTRL;
0000dc  60c1              STR      r1,[r0,#0xc]
;;;345    }
0000de  4770              BX       lr
;;;346    
                          ENDP

                  TIMER_CounterModeConfig PROC
;;;357      */
;;;358    void TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode)
0000e0  68c2              LDR      r2,[r0,#0xc]
;;;359    {
;;;360      uint32_t tmpreg_CNTRL;
;;;361    
;;;362      /* Check the parameters */
;;;363      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;364      assert_param(IS_TIMER_COUNTER_MODE(Mode));
;;;365    
;;;366      tmpreg_CNTRL = TIMERx->CNTRL;
;;;367      tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_MODE_Msk;
0000e2  f02202c0          BIC      r2,r2,#0xc0
;;;368      tmpreg_CNTRL += Mode;
0000e6  4411              ADD      r1,r1,r2
;;;369      TIMERx->CNTRL = tmpreg_CNTRL;
0000e8  60c1              STR      r1,[r0,#0xc]
;;;370    }
0000ea  4770              BX       lr
;;;371    
                          ENDP

                  TIMER_SetCounterDirection PROC
;;;380      */
;;;381    void TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction)
0000ec  68c2              LDR      r2,[r0,#0xc]
;;;382    {
;;;383      uint32_t tmpreg_CNTRL;
;;;384    
;;;385      /* Check the parameters */
;;;386      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;387      assert_param(IS_TIMER_COUNTER_DIR(Direction));
;;;388    
;;;389      tmpreg_CNTRL = TIMERx->CNTRL;
;;;390      tmpreg_CNTRL &= ~TIMER_CNTRL_DIR;
0000ee  f0220208          BIC      r2,r2,#8
;;;391      tmpreg_CNTRL += Direction;
0000f2  4411              ADD      r1,r1,r2
;;;392      TIMERx->CNTRL = tmpreg_CNTRL;
0000f4  60c1              STR      r1,[r0,#0xc]
;;;393    }
0000f6  4770              BX       lr
;;;394    
                          ENDP

                  TIMER_ETRInputConfig PROC
;;;427      */
;;;428    void TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter)
0000f8  b510              PUSH     {r4,lr}
;;;429    {
;;;430      uint32_t tmpreg_BRKETR_CNTRL;
;;;431    
;;;432      /* Check the parameters */
;;;433      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;434      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;435      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;436      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;437    
;;;438      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
0000fa  6d04              LDR      r4,[r0,#0x50]
;;;439      tmpreg_BRKETR_CNTRL &= ~(TIMER_BRKETR_CNTRL_ETR_PSC_Msk + TIMER_BRKETR_CNTRL_ETR_INV + TIMER_BRKETR_CNTRL_ETR_FILTER_Msk);
;;;440      tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos);
0000fc  4411              ADD      r1,r1,r2
0000fe  f02404fe          BIC      r4,r4,#0xfe           ;439
000102  eb011103          ADD      r1,r1,r3,LSL #4
000106  4421              ADD      r1,r1,r4
;;;441      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000108  6501              STR      r1,[r0,#0x50]
;;;442    }
00010a  bd10              POP      {r4,pc}
;;;443    
                          ENDP

                  TIMER_ETRFilterConfig PROC
;;;466      */
;;;467    void TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter)
00010c  6d02              LDR      r2,[r0,#0x50]
;;;468    {
;;;469      uint32_t tmpreg_BRKETR_CNTRL;
;;;470    
;;;471      /* Check the parameters */
;;;472      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;473      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;474    
;;;475      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;476      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_FILTER_Msk;
00010e  f02202f0          BIC      r2,r2,#0xf0
;;;477      tmpreg_BRKETR_CNTRL += Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos;
000112  eb021101          ADD      r1,r2,r1,LSL #4
;;;478      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000116  6501              STR      r1,[r0,#0x50]
;;;479    }
000118  4770              BX       lr
;;;480    
                          ENDP

                  TIMER_ETRPrescalerConfig PROC
;;;491      */
;;;492    void TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
00011a  6d02              LDR      r2,[r0,#0x50]
;;;493    {
;;;494      uint32_t tmpreg_BRKETR_CNTRL;
;;;495    
;;;496      /* Check the parameters */
;;;497      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;498      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;499    
;;;500      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;501      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_PSC_Msk;
00011c  f022020c          BIC      r2,r2,#0xc
;;;502      tmpreg_BRKETR_CNTRL += Prescaler;
000120  4411              ADD      r1,r1,r2
;;;503      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000122  6501              STR      r1,[r0,#0x50]
;;;504    }
000124  4770              BX       lr
;;;505    
                          ENDP

                  TIMER_ETRPolarityConfig PROC
;;;514      */
;;;515    void TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000126  6d02              LDR      r2,[r0,#0x50]
;;;516    {
;;;517      uint32_t tmpreg_BRKETR_CNTRL;
;;;518    
;;;519      /* Check the parameters */
;;;520      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;521      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;522    
;;;523      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;524      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_INV;
000128  f0220202          BIC      r2,r2,#2
;;;525      tmpreg_BRKETR_CNTRL += Polarity;
00012c  4411              ADD      r1,r1,r2
;;;526      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00012e  6501              STR      r1,[r0,#0x50]
;;;527    }
000130  4770              BX       lr
;;;528    
                          ENDP

                  TIMER_BRKPolarityConfig PROC
;;;537      */
;;;538    void TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000132  6d02              LDR      r2,[r0,#0x50]
;;;539    {
;;;540      uint32_t tmpreg_BRKETR_CNTRL;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;544      assert_param(IS_TIMER_BRK_POLARITY(Polarity));
;;;545    
;;;546      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;547      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_BRK_INV;
000134  f0220201          BIC      r2,r2,#1
;;;548      tmpreg_BRKETR_CNTRL += Polarity;
000138  4411              ADD      r1,r1,r2
;;;549      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00013a  6501              STR      r1,[r0,#0x50]
;;;550    }
00013c  4770              BX       lr
;;;551    
                          ENDP

                  TIMER_GetCounterDirection PROC
;;;556      */
;;;557    uint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx)
00013e  68c0              LDR      r0,[r0,#0xc]
;;;558    {
;;;559      uint32_t bitstatus;
;;;560    
;;;561      /* Check the parameters */
;;;562      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;563    
;;;564      if ((TIMERx->CNTRL & TIMER_CNTRL_DIR) == 0)
000140  0700              LSLS     r0,r0,#28
000142  d401              BMI      |L1.328|
;;;565      {
;;;566        bitstatus = TIMER_CntDir_Up;
000144  2000              MOVS     r0,#0
;;;567      }
;;;568      else
;;;569      {
;;;570        bitstatus = TIMER_CntDir_Dn;
;;;571      }
;;;572    
;;;573      return bitstatus;
;;;574    }
000146  4770              BX       lr
                  |L1.328|
000148  2008              MOVS     r0,#8                 ;570
00014a  4770              BX       lr
;;;575    
                          ENDP

                  TIMER_GetCntWriteComplete PROC
;;;580      */
;;;581    FlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx)
00014c  68c0              LDR      r0,[r0,#0xc]
;;;582    {
;;;583      FlagStatus bitstatus;
;;;584    
;;;585      /* Check the parameters */
;;;586      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;587    
;;;588      if ((TIMERx->CNTRL & TIMER_CNTRL_WR_CMPL) == 0)
00014e  0740              LSLS     r0,r0,#29
000150  d401              BMI      |L1.342|
;;;589      {
;;;590        bitstatus = RESET;
000152  2000              MOVS     r0,#0
;;;591      }
;;;592      else
;;;593      {
;;;594        bitstatus = SET;
;;;595      }
;;;596    
;;;597      return bitstatus;
;;;598    }
000154  4770              BX       lr
                  |L1.342|
000156  2001              MOVS     r0,#1                 ;594
000158  4770              BX       lr
;;;599    
                          ENDP

                  TIMER_ChnInit PROC
;;;608      */
;;;609    void TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
00015a  b510              PUSH     {r4,lr}
;;;610    {
;;;611      uint32_t tmpreg_CH_Number;
;;;612      uint32_t tmpreg_CH_CNTRL;
;;;613      uint32_t tmpreg_CH_CNTRL2;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;617      assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnInitStruct->TIMER_CH_Number));
;;;618      assert_param(IS_TIMER_CHANNEL_MODE(TIMER_ChnInitStruct->TIMER_CH_Mode));
;;;619      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_ETR_Ena));
;;;620      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_ETR_Reset));
;;;621      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_BRK_Reset));
;;;622      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(TIMER_ChnInitStruct->TIMER_CH_REF_Format));
;;;623      assert_param(IS_TIMER_CHANNEL_PRESCALER(TIMER_ChnInitStruct->TIMER_CH_Prescaler));
;;;624      assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_EventSource));
;;;625      assert_param(IS_TIMER_FILTER_CONF(TIMER_ChnInitStruct->TIMER_CH_FilterConf));
;;;626      assert_param(IS_TIMER_CHANNEL_CCR_UPDATE_MODE(TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode));
;;;627      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena));
;;;628      assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource));
;;;629    
;;;630      tmpreg_CH_CNTRL = TIMER_ChnInitStruct->TIMER_CH_Mode
00015c  884a              LDRH     r2,[r1,#2]
00015e  88cb              LDRH     r3,[r1,#6]
000160  894c              LDRH     r4,[r1,#0xa]
000162  441a              ADD      r2,r2,r3
000164  890b              LDRH     r3,[r1,#8]
000166  4423              ADD      r3,r3,r4
000168  441a              ADD      r2,r2,r3
00016a  898b              LDRH     r3,[r1,#0xc]
00016c  eb021283          ADD      r2,r2,r3,LSL #6
000170  89cb              LDRH     r3,[r1,#0xe]
000172  441a              ADD      r2,r2,r3
000174  8a0b              LDRH     r3,[r1,#0x10]
000176  441a              ADD      r2,r2,r3
;;;631                      + TIMER_ChnInitStruct->TIMER_CH_ETR_Reset
;;;632                      + TIMER_ChnInitStruct->TIMER_CH_BRK_Reset
;;;633                      + TIMER_ChnInitStruct->TIMER_CH_REF_Format
;;;634                      + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << TIMER_CH_CNTRL_CHPSC_Pos)
;;;635                      + TIMER_ChnInitStruct->TIMER_CH_EventSource
;;;636                      + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << TIMER_CH_CNTRL_CHFLTR_Pos);
;;;637    
;;;638      if (TIMER_ChnInitStruct->TIMER_CH_ETR_Ena != DISABLE)
000178  888b              LDRH     r3,[r1,#4]
00017a  b10b              CBZ      r3,|L1.384|
00017c  f5025200          ADD      r2,r2,#0x2000         ;610
                  |L1.384|
;;;639      {
;;;640        tmpreg_CH_CNTRL += TIMER_CH_CNTRL_ETREN;
;;;641      }
;;;642    
;;;643      tmpreg_CH_Number = TIMER_ChnInitStruct->TIMER_CH_Number;
000180  880b              LDRH     r3,[r1,#0]
;;;644    
;;;645      *(&TIMERx->CH1_CNTRL + tmpreg_CH_Number) = tmpreg_CH_CNTRL;
000182  eb000383          ADD      r3,r0,r3,LSL #2
000186  621a              STR      r2,[r3,#0x20]
;;;646    
;;;647      tmpreg_CH_CNTRL2 = TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode
000188  8a48              LDRH     r0,[r1,#0x12]
00018a  8aca              LDRH     r2,[r1,#0x16]
;;;648                       + TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource;
;;;649    
;;;650      if (TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena != DISABLE)
00018c  8a89              LDRH     r1,[r1,#0x14]
00018e  4410              ADD      r0,r0,r2              ;647
000190  b101              CBZ      r1,|L1.404|
000192  1d00              ADDS     r0,r0,#4
                  |L1.404|
;;;651      {
;;;652        tmpreg_CH_CNTRL2 += TIMER_CH_CNTRL2_CCR1_EN;
;;;653      }
;;;654    
;;;655      *(&TIMERx->CH1_CNTRL2 + tmpreg_CH_Number) = tmpreg_CH_CNTRL2;
000194  6618              STR      r0,[r3,#0x60]
;;;656    }
000196  bd10              POP      {r4,pc}
;;;657    
                          ENDP

                  TIMER_ChnStructInit PROC
;;;663      */
;;;664    void TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
000198  2100              MOVS     r1,#0
;;;665    {
;;;666      TIMER_ChnInitStruct->TIMER_CH_Number           = TIMER_CHANNEL1;
00019a  8001              STRH     r1,[r0,#0]
;;;667      TIMER_ChnInitStruct->TIMER_CH_Mode             = TIMER_CH_MODE_PWM;
00019c  8041              STRH     r1,[r0,#2]
;;;668      TIMER_ChnInitStruct->TIMER_CH_ETR_Ena          = DISABLE;
00019e  8081              STRH     r1,[r0,#4]
;;;669      TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = TIMER_CH_ETR_RESET_Disable;
0001a0  80c1              STRH     r1,[r0,#6]
;;;670      TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = TIMER_CH_BRK_RESET_Disable;
0001a2  8101              STRH     r1,[r0,#8]
;;;671      TIMER_ChnInitStruct->TIMER_CH_REF_Format       = TIMER_CH_REF_Format0;
0001a4  8141              STRH     r1,[r0,#0xa]
;;;672      TIMER_ChnInitStruct->TIMER_CH_Prescaler        = TIMER_CH_Prescaler_None;
0001a6  8181              STRH     r1,[r0,#0xc]
;;;673      TIMER_ChnInitStruct->TIMER_CH_EventSource      = TIMER_CH_EvSrc_PE;
0001a8  81c1              STRH     r1,[r0,#0xe]
;;;674      TIMER_ChnInitStruct->TIMER_CH_FilterConf       = TIMER_Filter_1FF_at_TIMER_CLK;
0001aa  8201              STRH     r1,[r0,#0x10]
;;;675      TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = TIMER_CH_CCR_Update_Immediately;
0001ac  8241              STRH     r1,[r0,#0x12]
;;;676      TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena         = DISABLE;
0001ae  8281              STRH     r1,[r0,#0x14]
;;;677      TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE;
0001b0  82c1              STRH     r1,[r0,#0x16]
;;;678    }
0001b2  4770              BX       lr
;;;679    
                          ENDP

                  TIMER_SetChnCompare PROC
;;;694    #elif defined (USE_MDR1986VE9x)
;;;695    void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001b4  eb000081          ADD      r0,r0,r1,LSL #2
;;;696    #endif
;;;697    {
;;;698      __IO uint32_t *tmpreg_CCRx;
;;;699    
;;;700      /* Check the parameters */
;;;701      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;702      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;703    
;;;704      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
;;;705      *tmpreg_CCRx = Compare;
0001b8  6102              STR      r2,[r0,#0x10]
;;;706    }
0001ba  4770              BX       lr
;;;707    
                          ENDP

                  TIMER_SetChnCompare1 PROC
;;;722    #elif defined (USE_MDR1986VE9x)
;;;723    void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001bc  eb000081          ADD      r0,r0,r1,LSL #2
;;;724    #endif
;;;725    {
;;;726      __IO uint32_t *tmpreg_CCR1x;
;;;727    
;;;728      /* Check the parameters */
;;;729      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;730      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;731    
;;;732      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
;;;733      *tmpreg_CCR1x = Compare;
0001c0  6702              STR      r2,[r0,#0x70]
;;;734    }
0001c2  4770              BX       lr
;;;735    
                          ENDP

                  TIMER_ChnCompareConfig PROC
;;;754    #elif defined (USE_MDR1986VE9x)
;;;755    void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
0001c4  b510              PUSH     {r4,lr}
;;;756    #endif
;;;757    {
;;;758      __IO uint32_t *tmpreg_CNTRL2x;
;;;759      __IO uint32_t *tmpreg_CCRx;
;;;760      uint32_t tmpreg_CNTRL2;
;;;761    
;;;762      /* Check the parameters */
;;;763      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;764      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;765      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;766    
;;;767      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
0001c6  eb000181          ADD      r1,r0,r1,LSL #2
;;;768    
;;;769      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
0001ca  6e0c              LDR      r4,[r1,#0x60]
;;;770      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
0001cc  f0240408          BIC      r4,r4,#8
;;;771      tmpreg_CNTRL2 += UpdateMode;
0001d0  4423              ADD      r3,r3,r4
;;;772      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
0001d2  660b              STR      r3,[r1,#0x60]
;;;773    
;;;774      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
;;;775    
;;;776      *tmpreg_CCRx = Compare;
0001d4  610a              STR      r2,[r1,#0x10]
;;;777    }
0001d6  bd10              POP      {r4,pc}
;;;778    
                          ENDP

                  TIMER_ChnCompare1Config PROC
;;;797    #elif defined (USE_MDR1986VE9x)
;;;798    void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
0001d8  b510              PUSH     {r4,lr}
;;;799    #endif
;;;800    {
;;;801      __IO uint32_t *tmpreg_CNTRL2x;
;;;802      __IO uint32_t *tmpreg_CCR1x;
;;;803      uint32_t tmpreg_CNTRL2;
;;;804    
;;;805      /* Check the parameters */
;;;806      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;807      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;808      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;809    
;;;810      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
0001da  eb000181          ADD      r1,r0,r1,LSL #2
;;;811    
;;;812      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
0001de  6e0c              LDR      r4,[r1,#0x60]
;;;813      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
0001e0  f0240408          BIC      r4,r4,#8
;;;814      tmpreg_CNTRL2 += UpdateMode;
0001e4  4423              ADD      r3,r3,r4
;;;815      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
0001e6  660b              STR      r3,[r1,#0x60]
;;;816    
;;;817      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
;;;818    
;;;819      *tmpreg_CCR1x = Compare;
0001e8  670a              STR      r2,[r1,#0x70]
;;;820    }
0001ea  bd10              POP      {r4,pc}
;;;821    
                          ENDP

                  TIMER_GetChnCapture PROC
;;;835    #elif defined (USE_MDR1986VE9x)
;;;836    uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
0001ec  eb000081          ADD      r0,r0,r1,LSL #2
;;;837    #endif
;;;838    {
;;;839      __IO uint32_t *tmpreg_CCRx;
;;;840      uint32_t tmpreg;
;;;841    
;;;842      /* Check the parameters */
;;;843      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;844      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;845    
;;;846      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
;;;847      tmpreg = *tmpreg_CCRx;
0001f0  6900              LDR      r0,[r0,#0x10]
;;;848    
;;;849      return tmpreg;
0001f2  b280              UXTH     r0,r0
;;;850    }
0001f4  4770              BX       lr
;;;851    
                          ENDP

                  TIMER_GetChnCapture1 PROC
;;;865    #elif defined (USE_MDR1986VE9x)
;;;866    uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
0001f6  eb000081          ADD      r0,r0,r1,LSL #2
;;;867    #endif
;;;868    {
;;;869      __IO uint32_t *tmpreg_CCR1x;
;;;870      uint32_t tmpreg;
;;;871    
;;;872      /* Check the parameters */
;;;873      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;874      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;875    
;;;876      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
;;;877      tmpreg = *tmpreg_CCR1x;
0001fa  6f00              LDR      r0,[r0,#0x70]
;;;878    
;;;879      return tmpreg;
0001fc  b280              UXTH     r0,r0
;;;880    }
0001fe  4770              BX       lr
;;;881    
                          ENDP

                  TIMER_ChnETR_Cmd PROC
;;;894      */
;;;895    void TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000200  eb000081          ADD      r0,r0,r1,LSL #2
;;;896    {
;;;897      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;898      uint32_t tmpreg_CH_CNTRL;
;;;899    
;;;900      /* Check the parameters */
;;;901      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;902      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;903      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;904    
;;;905      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;906    
;;;907      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000204  f8501f20          LDR      r1,[r0,#0x20]!
000208  b112              CBZ      r2,|L1.528|
;;;908    
;;;909      /* Form new value */
;;;910      if (NewState != DISABLE)
;;;911      {
;;;912        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;913        tmpreg_CH_CNTRL |= TIMER_CH_CNTRL_OCCE;
00020a  f4417180          ORR      r1,r1,#0x100
00020e  e001              B        |L1.532|
                  |L1.528|
;;;914      }
;;;915      else
;;;916      {
;;;917        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;918        tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCE;
000210  f4217180          BIC      r1,r1,#0x100
                  |L1.532|
;;;919      }
;;;920    
;;;921      /* Configure CNTRL register with new value */
;;;922      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000214  6001              STR      r1,[r0,#0]
;;;923    }
000216  4770              BX       lr
;;;924    
                          ENDP

                  TIMER_ChnETRResetConfig PROC
;;;939      */
;;;940    void TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000218  eb000081          ADD      r0,r0,r1,LSL #2
;;;941    {
;;;942      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;943      uint32_t tmpreg_CH_CNTRL;
;;;944    
;;;945      /* Check the parameters */
;;;946      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;947      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;948      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(NewState));
;;;949    
;;;950      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;951    
;;;952      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00021c  6a01              LDR      r1,[r0,#0x20]
;;;953      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_ETREN;
00021e  f4215100          BIC      r1,r1,#0x2000
;;;954      tmpreg_CH_CNTRL += NewState;
000222  4411              ADD      r1,r1,r2
;;;955      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000224  6201              STR      r1,[r0,#0x20]
;;;956    }
000226  4770              BX       lr
;;;957    
                          ENDP

                  TIMER_ChnBRKResetConfig PROC
;;;972      */
;;;973    void TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000228  eb000081          ADD      r0,r0,r1,LSL #2
;;;974    {
;;;975      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;976      uint32_t tmpreg_CH_CNTRL;
;;;977    
;;;978      /* Check the parameters */
;;;979      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;980      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;981      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(NewState));
;;;982    
;;;983      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;984    
;;;985      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00022c  6a01              LDR      r1,[r0,#0x20]
;;;986      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_BRKEN;
00022e  f4215180          BIC      r1,r1,#0x1000
;;;987      tmpreg_CH_CNTRL += NewState;
000232  4411              ADD      r1,r1,r2
;;;988      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000234  6201              STR      r1,[r0,#0x20]
;;;989    }
000236  4770              BX       lr
;;;990    
                          ENDP

                  TIMER_ChnREFFormatConfig PROC
;;;1003     */
;;;1004   void TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format)
000238  eb000081          ADD      r0,r0,r1,LSL #2
;;;1005   {
;;;1006     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1007     uint32_t tmpreg_CH_CNTRL;
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1011     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1012     assert_param(IS_TIMER_CHANNEL_REF_FORMAT(Format));
;;;1013   
;;;1014     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1015   
;;;1016     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00023c  6a01              LDR      r1,[r0,#0x20]
;;;1017     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCM_Msk;
00023e  f4216160          BIC      r1,r1,#0xe00
;;;1018     tmpreg_CH_CNTRL += Format;
000242  4411              ADD      r1,r1,r2
;;;1019     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000244  6201              STR      r1,[r0,#0x20]
;;;1020   }
000246  4770              BX       lr
;;;1021   
                          ENDP

                  TIMER_ChnCapturePrescalerConfig PROC
;;;1038     */
;;;1039   void TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler)
000248  eb000081          ADD      r0,r0,r1,LSL #2
;;;1040   {
;;;1041     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1042     uint32_t tmpreg_CH_CNTRL;
;;;1043   
;;;1044     /* Check the parameters */
;;;1045     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1046     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1047     assert_param(IS_TIMER_CHANNEL_PRESCALER(Prescaler));
;;;1048   
;;;1049     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1050   
;;;1051     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00024c  6a01              LDR      r1,[r0,#0x20]
;;;1052     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHPSC_Msk;
00024e  f02101c0          BIC      r1,r1,#0xc0
;;;1053     tmpreg_CH_CNTRL += Prescaler << TIMER_CH_CNTRL_CHPSC_Pos;
000252  eb011182          ADD      r1,r1,r2,LSL #6
;;;1054     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000256  6201              STR      r1,[r0,#0x20]
;;;1055   }
000258  4770              BX       lr
;;;1056   
                          ENDP

                  TIMER_ChnEventSourceConfig PROC
;;;1073     */
;;;1074   void TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
00025a  eb000081          ADD      r0,r0,r1,LSL #2
;;;1075   {
;;;1076     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1077     uint32_t tmpreg_CH_CNTRL;
;;;1078   
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1081     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1082     assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(EventSource));
;;;1083   
;;;1084     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1085   
;;;1086     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00025e  6a01              LDR      r1,[r0,#0x20]
;;;1087     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHSEL_Msk;
000260  f0210130          BIC      r1,r1,#0x30
;;;1088     tmpreg_CH_CNTRL += EventSource;
000264  4411              ADD      r1,r1,r2
;;;1089     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000266  6201              STR      r1,[r0,#0x20]
;;;1090   }
000268  4770              BX       lr
;;;1091   
                          ENDP

                  TIMER_ChnFilterConfig PROC
;;;1120     */
;;;1121   void TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter)
00026a  eb000081          ADD      r0,r0,r1,LSL #2
;;;1122   {
;;;1123     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1124     uint32_t tmpreg_CH_CNTRL;
;;;1125   
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1128     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1129     assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;1130   
;;;1131     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1132   
;;;1133     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00026e  6a01              LDR      r1,[r0,#0x20]
;;;1134     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHFLTR_Msk;
000270  f021010f          BIC      r1,r1,#0xf
;;;1135     tmpreg_CH_CNTRL += Filter << TIMER_CH_CNTRL_CHFLTR_Pos;
000274  4411              ADD      r1,r1,r2
;;;1136     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000276  6201              STR      r1,[r0,#0x20]
;;;1137   }
000278  4770              BX       lr
;;;1138   
                          ENDP

                  TIMER_GetChnWriteComplete PROC
;;;1149     */
;;;1150   FlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
00027a  eb000081          ADD      r0,r0,r1,LSL #2
;;;1151   {
;;;1152     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1153     FlagStatus bitstatus;
;;;1154   
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1157     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1158   
;;;1159     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1160   
;;;1161     if ((*tmpreg_CH_CNTRLx & TIMER_CH_CNTRL_WR_CMPL) == 0)
00027e  6a00              LDR      r0,[r0,#0x20]
000280  0440              LSLS     r0,r0,#17
000282  d401              BMI      |L1.648|
;;;1162     {
;;;1163       bitstatus = RESET;
000284  2000              MOVS     r0,#0
;;;1164     }
;;;1165     else
;;;1166     {
;;;1167       bitstatus = SET;
;;;1168     }
;;;1169   
;;;1170     return bitstatus;
;;;1171   }
000286  4770              BX       lr
                  |L1.648|
000288  2001              MOVS     r0,#1                 ;1167
00028a  4770              BX       lr
;;;1172   
                          ENDP

                  TIMER_ChnCCR1_EventSourceConfig PROC
;;;1189     */
;;;1190   void TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
00028c  eb000081          ADD      r0,r0,r1,LSL #2
;;;1191   {
;;;1192     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1193     uint32_t tmpreg_CH_CNTRL2;
;;;1194   
;;;1195     /* Check the parameters */
;;;1196     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1197     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1198     assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(EventSource));
;;;1199   
;;;1200     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
;;;1201   
;;;1202     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
000290  6e01              LDR      r1,[r0,#0x60]
;;;1203     tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CHSEL1_Msk;
000292  f0210103          BIC      r1,r1,#3
;;;1204     tmpreg_CH_CNTRL2 += EventSource;
000296  4411              ADD      r1,r1,r2
;;;1205     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
000298  6601              STR      r1,[r0,#0x60]
;;;1206   }
00029a  4770              BX       lr
;;;1207   
                          ENDP

                  TIMER_ChnCCR1_Cmd PROC
;;;1220     */
;;;1221   void TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
00029c  eb000081          ADD      r0,r0,r1,LSL #2
;;;1222   {
;;;1223     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1224     uint32_t tmpreg_CH_CNTRL2;
;;;1225   
;;;1226     /* Check the parameters */
;;;1227     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1228     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1229     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1230   
;;;1231     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
;;;1232   
;;;1233     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
0002a0  f8501f60          LDR      r1,[r0,#0x60]!
0002a4  b112              CBZ      r2,|L1.684|
;;;1234   
;;;1235     /* Form new value */
;;;1236     if (NewState != DISABLE)
;;;1237     {
;;;1238       /* Enable TIMERx by setting the CCR1_EN bit in the CNTRL2 register */
;;;1239       tmpreg_CH_CNTRL2 |= TIMER_CH_CNTRL2_CCR1_EN;
0002a6  f0410104          ORR      r1,r1,#4
0002aa  e001              B        |L1.688|
                  |L1.684|
;;;1240     }
;;;1241     else
;;;1242     {
;;;1243       /* Disable TIMERx by resetting the CCR1_EN bit in the CNTRL2 register */
;;;1244       tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CCR1_EN;
0002ac  f0210104          BIC      r1,r1,#4
                  |L1.688|
;;;1245     }
;;;1246   
;;;1247     /* Configure CNTRL register with new value */
;;;1248     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
0002b0  6001              STR      r1,[r0,#0]
;;;1249   }
0002b2  4770              BX       lr
;;;1250   
                          ENDP

                  TIMER_ChnOutInit PROC
;;;1259     */
;;;1260   void TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
0002b4  b510              PUSH     {r4,lr}
;;;1261   {
;;;1262     uint32_t tmpreg_CH_Number;
;;;1263     uint32_t tmpreg_CH_CNTRL1;
;;;1264     uint32_t tmpreg_CH_DTG;
;;;1265   
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1268     assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnOutInitStruct->TIMER_CH_Number));
;;;1269     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity));
;;;1270     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source));
;;;1271     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode));
;;;1272     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity));
;;;1273     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source));
;;;1274     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode));
;;;1275     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler));
;;;1276     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler));
;;;1277     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource));
;;;1278   
;;;1279     tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << TIMER_CH_CNTRL1_INV_Pos)
0002b6  88ca              LDRH     r2,[r1,#6]
0002b8  884b              LDRH     r3,[r1,#2]
0002ba  890c              LDRH     r4,[r1,#8]
0002bc  eb021203          ADD      r2,r2,r3,LSL #4
0002c0  888b              LDRH     r3,[r1,#4]
0002c2  009b              LSLS     r3,r3,#2
0002c4  eb033304          ADD      r3,r3,r4,LSL #12
0002c8  441a              ADD      r2,r2,r3
0002ca  894b              LDRH     r3,[r1,#0xa]
0002cc  eb022283          ADD      r2,r2,r3,LSL #10
0002d0  898b              LDRH     r3,[r1,#0xc]
0002d2  eb022203          ADD      r2,r2,r3,LSL #8
;;;1280                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << TIMER_CH_CNTRL1_SELO_Pos)
;;;1281                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << TIMER_CH_CNTRL1_SELOE_Pos)
;;;1282                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << TIMER_CH_CNTRL1_NINV_Pos)
;;;1283                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1284                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1285   
;;;1286     tmpreg_CH_Number = TIMER_ChnOutInitStruct->TIMER_CH_Number;
0002d6  880b              LDRH     r3,[r1,#0]
;;;1287   
;;;1288     *(&TIMERx->CH1_CNTRL1 + tmpreg_CH_Number) = tmpreg_CH_CNTRL1;
0002d8  eb000083          ADD      r0,r0,r3,LSL #2
0002dc  6302              STR      r2,[r0,#0x30]
;;;1289   
;;;1290     tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << TIMER_CH_DTG_Pos)
0002de  8a0a              LDRH     r2,[r1,#0x10]
0002e0  8a4b              LDRH     r3,[r1,#0x12]
0002e2  89c9              LDRH     r1,[r1,#0xe]
0002e4  441a              ADD      r2,r2,r3
0002e6  eb022101          ADD      r1,r2,r1,LSL #8
;;;1291                   + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1292                   + TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource;
;;;1293   
;;;1294     *(&TIMERx->CH1_DTG + tmpreg_CH_Number) = tmpreg_CH_DTG;
0002ea  6401              STR      r1,[r0,#0x40]
;;;1295   }
0002ec  bd10              POP      {r4,pc}
;;;1296   
                          ENDP

                  TIMER_ChnOutStructInit PROC
;;;1302     */
;;;1303   void TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
0002ee  2100              MOVS     r1,#0
;;;1304   {
;;;1305     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0002f0  8041              STRH     r1,[r0,#2]
;;;1306     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = TIMER_CH_OutSrc_Only_0;
0002f2  8081              STRH     r1,[r0,#4]
;;;1307     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = TIMER_CH_OutMode_Input;
0002f4  80c1              STRH     r1,[r0,#6]
;;;1308     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0002f6  8101              STRH     r1,[r0,#8]
;;;1309     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = TIMER_CH_OutSrc_Only_0;
0002f8  8141              STRH     r1,[r0,#0xa]
;;;1310     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = TIMER_CH_OutMode_Input;
0002fa  8181              STRH     r1,[r0,#0xc]
;;;1311     TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler = 0;
0002fc  81c1              STRH     r1,[r0,#0xe]
;;;1312     TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  = 0;
0002fe  8201              STRH     r1,[r0,#0x10]
;;;1313     TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = TIMER_CH_DTG_ClkSrc_TIMER_CLK;
000300  8241              STRH     r1,[r0,#0x12]
;;;1314   }
000302  4770              BX       lr
;;;1315   
                          ENDP

                  TIMER_ChnOutConfig PROC
;;;1342     */
;;;1343   void TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000304  b510              PUSH     {r4,lr}
;;;1344   {
;;;1345     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1346     uint32_t tmpreg_CH_CNTRL1;
;;;1347   
;;;1348     /* Check the parameters */
;;;1349     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1350     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1351     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1352     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1353     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1354   
;;;1355     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000306  eb000081          ADD      r0,r0,r1,LSL #2
;;;1356   
;;;1357     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00030a  9c02              LDR      r4,[sp,#8]
00030c  6b01              LDR      r1,[r0,#0x30]
;;;1358     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_INV + TIMER_CH_CNTRL1_SELO_Msk + TIMER_CH_CNTRL1_SELOE_Msk);
;;;1359     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_INV_Pos)
00030e  0124              LSLS     r4,r4,#4
000310  eb040282          ADD      r2,r4,r2,LSL #2
000314  f021011f          BIC      r1,r1,#0x1f           ;1358
000318  441a              ADD      r2,r2,r3
00031a  4411              ADD      r1,r1,r2
;;;1360                       + (OutSource << TIMER_CH_CNTRL1_SELO_Pos)
;;;1361                       + (Mode      << TIMER_CH_CNTRL1_SELOE_Pos);
;;;1362     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00031c  6301              STR      r1,[r0,#0x30]
;;;1363   }
00031e  bd10              POP      {r4,pc}
;;;1364   
                          ENDP

                  TIMER_ChnOutSourceConfig PROC
;;;1381     */
;;;1382   void TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
000320  eb000081          ADD      r0,r0,r1,LSL #2
;;;1383   {
;;;1384     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1385     uint32_t tmpreg_CH_CNTRL1;
;;;1386   
;;;1387     /* Check the parameters */
;;;1388     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1389     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1390     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1391   
;;;1392     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1393   
;;;1394     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000324  6b01              LDR      r1,[r0,#0x30]
;;;1395     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELO_Msk;
000326  f021010c          BIC      r1,r1,#0xc
;;;1396     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_SELO_Pos;
00032a  eb010182          ADD      r1,r1,r2,LSL #2
;;;1397     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00032e  6301              STR      r1,[r0,#0x30]
;;;1398   }
000330  4770              BX       lr
;;;1399   
                          ENDP

                  TIMER_ChnOutModeConfig PROC
;;;1416     */
;;;1417   void TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000332  eb000081          ADD      r0,r0,r1,LSL #2
;;;1418   {
;;;1419     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1420     uint32_t tmpreg_CH_CNTRL1;
;;;1421   
;;;1422     /* Check the parameters */
;;;1423     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1424     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1425     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1426   
;;;1427     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1428   
;;;1429     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000336  6b01              LDR      r1,[r0,#0x30]
;;;1430     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELOE_Msk;
000338  f0210103          BIC      r1,r1,#3
;;;1431     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_SELOE_Pos;
00033c  4411              ADD      r1,r1,r2
;;;1432     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00033e  6301              STR      r1,[r0,#0x30]
;;;1433   }
000340  4770              BX       lr
;;;1434   
                          ENDP

                  TIMER_ChnOutPolarityConfig PROC
;;;1449     */
;;;1450   void TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
000342  eb000081          ADD      r0,r0,r1,LSL #2
;;;1451   {
;;;1452     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1453     uint32_t tmpreg_CH_CNTRL1;
;;;1454   
;;;1455     /* Check the parameters */
;;;1456     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1457     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1458     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1459   
;;;1460     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1461   
;;;1462     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000346  6b01              LDR      r1,[r0,#0x30]
;;;1463     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_INV;
000348  f0210110          BIC      r1,r1,#0x10
;;;1464     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_INV_Pos;
00034c  eb011102          ADD      r1,r1,r2,LSL #4
;;;1465     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000350  6301              STR      r1,[r0,#0x30]
;;;1466   }
000352  4770              BX       lr
;;;1467   
                          ENDP

                  TIMER_ChnNOutConfig PROC
;;;1494     */
;;;1495   void TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000354  b510              PUSH     {r4,lr}
;;;1496   {
;;;1497     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1498     uint32_t tmpreg_CH_CNTRL1;
;;;1499   
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1502     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1503     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1504     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1505     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1506   
;;;1507     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000356  eb000081          ADD      r0,r0,r1,LSL #2
;;;1508   
;;;1509     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00035a  9c02              LDR      r4,[sp,#8]
00035c  6b01              LDR      r1,[r0,#0x30]
;;;1510     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_NINV + TIMER_CH_CNTRL1_NSELO_Msk + TIMER_CH_CNTRL1_NSELOE_Msk);
;;;1511     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_NINV_Pos)
00035e  0324              LSLS     r4,r4,#12
000360  eb042282          ADD      r2,r4,r2,LSL #10
000364  f42151f8          BIC      r1,r1,#0x1f00         ;1510
000368  eb022203          ADD      r2,r2,r3,LSL #8
00036c  4411              ADD      r1,r1,r2
;;;1512                       + (OutSource << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1513                       + (Mode      << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1514     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00036e  6301              STR      r1,[r0,#0x30]
;;;1515   }
000370  bd10              POP      {r4,pc}
;;;1516   
                          ENDP

                  TIMER_ChnNOutSourceConfig PROC
;;;1533     */
;;;1534   void TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
000372  eb000081          ADD      r0,r0,r1,LSL #2
;;;1535   {
;;;1536     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1537     uint32_t tmpreg_CH_CNTRL1;
;;;1538   
;;;1539     /* Check the parameters */
;;;1540     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1541     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1542     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1543   
;;;1544     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1545   
;;;1546     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000376  6b01              LDR      r1,[r0,#0x30]
;;;1547     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELO_Msk;
000378  f4216140          BIC      r1,r1,#0xc00
;;;1548     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_NSELO_Pos;
00037c  eb012182          ADD      r1,r1,r2,LSL #10
;;;1549     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000380  6301              STR      r1,[r0,#0x30]
;;;1550   }
000382  4770              BX       lr
;;;1551   
                          ENDP

                  TIMER_ChnNOutModeConfig PROC
;;;1568     */
;;;1569   void TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000384  eb000081          ADD      r0,r0,r1,LSL #2
;;;1570   {
;;;1571     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1572     uint32_t tmpreg_CH_CNTRL1;
;;;1573   
;;;1574     /* Check the parameters */
;;;1575     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1576     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1577     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1578   
;;;1579     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1580   
;;;1581     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000388  6b01              LDR      r1,[r0,#0x30]
;;;1582     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELOE_Msk;
00038a  f4217140          BIC      r1,r1,#0x300
;;;1583     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_NSELOE_Pos;
00038e  eb012102          ADD      r1,r1,r2,LSL #8
;;;1584     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000392  6301              STR      r1,[r0,#0x30]
;;;1585   }
000394  4770              BX       lr
;;;1586   
                          ENDP

                  TIMER_ChnNOutPolarityConfig PROC
;;;1601     */
;;;1602   void TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
000396  eb000081          ADD      r0,r0,r1,LSL #2
;;;1603   {
;;;1604     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1605     uint32_t tmpreg_CH_CNTRL1;
;;;1606   
;;;1607     /* Check the parameters */
;;;1608     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1609     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1610     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1611   
;;;1612     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1613   
;;;1614     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00039a  6b01              LDR      r1,[r0,#0x30]
;;;1615     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NINV;
00039c  f4215180          BIC      r1,r1,#0x1000
;;;1616     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_NINV_Pos;
0003a0  eb013102          ADD      r1,r1,r2,LSL #12
;;;1617     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
0003a4  6301              STR      r1,[r0,#0x30]
;;;1618   }
0003a6  4770              BX       lr
;;;1619   
                          ENDP

                  TIMER_ChnOutDTGConfig PROC
;;;1638     */
;;;1639   void TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
0003a8  b510              PUSH     {r4,lr}
;;;1640                            uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource)
;;;1641   {
;;;1642     uint32_t tmpreg_CH_DTG;
;;;1643   
;;;1644     /* Check the parameters */
;;;1645     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1646     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1647     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(MainPrescaler));
;;;1648     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(AuxPrescaler));
;;;1649     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(ClockSource));
;;;1650   
;;;1651     tmpreg_CH_DTG = (MainPrescaler << TIMER_CH_DTG_Pos)
0003aa  eb032202          ADD      r2,r3,r2,LSL #8
0003ae  9c02              LDR      r4,[sp,#8]
;;;1652                   + (AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1653                   + ClockSource;
;;;1654   
;;;1655     *(&TIMERx->CH1_DTG + Channel) = tmpreg_CH_DTG;
0003b0  eb000081          ADD      r0,r0,r1,LSL #2
0003b4  4422              ADD      r2,r2,r4              ;1651
0003b6  6402              STR      r2,[r0,#0x40]
;;;1656   }
0003b8  bd10              POP      {r4,pc}
;;;1657   
                          ENDP

                  TIMER_GetStatus PROC
;;;1662     */
;;;1663   uint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx)
0003ba  6d40              LDR      r0,[r0,#0x54]
;;;1664   {
;;;1665     /* Check the parameters */
;;;1666     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1667   
;;;1668     return (TIMERx->STATUS);
;;;1669   }
0003bc  4770              BX       lr
;;;1670   
                          ENDP

                  TIMER_GetFlagStatus PROC
;;;1694     */
;;;1695   FlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag)
0003be  6d40              LDR      r0,[r0,#0x54]
;;;1696   {
;;;1697     FlagStatus bitstatus;
;;;1698   
;;;1699     /* Check the parameters */
;;;1700     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1701     assert_param(IS_TIMER_STATUS_FLAG(Flag));
;;;1702   
;;;1703     if ((TIMERx->STATUS & Flag) == 0)
0003c0  4008              ANDS     r0,r0,r1
0003c2  d000              BEQ      |L1.966|
;;;1704     {
;;;1705       bitstatus = RESET;
;;;1706     }
;;;1707     else
;;;1708     {
;;;1709       bitstatus = SET;
0003c4  2001              MOVS     r0,#1
                  |L1.966|
;;;1710     }
;;;1711   
;;;1712     return bitstatus;
;;;1713   }
0003c6  4770              BX       lr
;;;1714   
                          ENDP

                  TIMER_ClearFlag PROC
;;;1738     */
;;;1739   void TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags)
0003c8  6d42              LDR      r2,[r0,#0x54]
;;;1740   {
;;;1741     /* Check the parameters */
;;;1742     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1743     assert_param(IS_TIMER_STATUS(Flags));
;;;1744   
;;;1745     TIMERx->STATUS &= ~Flags;
0003ca  438a              BICS     r2,r2,r1
0003cc  6542              STR      r2,[r0,#0x54]
;;;1746   }
0003ce  4770              BX       lr
;;;1747   
                          ENDP

                  TIMER_DMACmd PROC
;;;1785   #if defined (USE_MDR1986VE9x)
;;;1786   void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState)
0003d0  6dc3              LDR      r3,[r0,#0x5c]
;;;1787   #endif
;;;1788   {
0003d2  b10a              CBZ      r2,|L1.984|
;;;1789     uint32_t tmpreg_DMA_RE;
;;;1790   
;;;1791     /* Check the parameters */
;;;1792     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1793     assert_param(IS_TIMER_STATUS(TIMER_DMASource));
;;;1794     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1795   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1796     if(TIMER_DMAChannel == TIMER_DMA_Channel0){
;;;1797   #endif
;;;1798   	  tmpreg_DMA_RE = TIMERx->DMA_RE;
;;;1799   
;;;1800   	  /* Form new value */
;;;1801   	  if (NewState != DISABLE)
;;;1802   	  {
;;;1803   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1804   		tmpreg_DMA_RE |= TIMER_DMASource;
0003d4  430b              ORRS     r3,r3,r1
0003d6  e000              B        |L1.986|
                  |L1.984|
;;;1805   	  }
;;;1806   	  else
;;;1807   	  {
;;;1808   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1809   		tmpreg_DMA_RE &= ~TIMER_DMASource;
0003d8  438b              BICS     r3,r3,r1
                  |L1.986|
;;;1810   	  }
;;;1811   
;;;1812   	  /* Configure CNTRL register with new value */
;;;1813   	  TIMERx->DMA_RE = tmpreg_DMA_RE;
0003da  65c3              STR      r3,[r0,#0x5c]
;;;1814   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1815     }
;;;1816     else{
;;;1817   	  tmpreg_DMA_RE = TIMERx->DMA_REChx[TIMER_DMAChannel];
;;;1818   
;;;1819   	  /* Form new value */
;;;1820   	  if (NewState != DISABLE)
;;;1821   	  {
;;;1822   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1823   		tmpreg_DMA_RE |= TIMER_DMASource;
;;;1824   	  }
;;;1825   	  else
;;;1826   	  {
;;;1827   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1828   		tmpreg_DMA_RE &= ~TIMER_DMASource;
;;;1829   	  }
;;;1830   
;;;1831   	  /* Configure CNTRL register with new value */
;;;1832   	  TIMERx->DMA_REChx[TIMER_DMAChannel] = tmpreg_DMA_RE;
;;;1833   
;;;1834     }
;;;1835   #endif
;;;1836   }
0003dc  4770              BX       lr
;;;1837   
                          ENDP

                  TIMER_ITConfig PROC
;;;1863     */
;;;1864   void TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState)
0003de  6d83              LDR      r3,[r0,#0x58]
;;;1865   {
0003e0  b10a              CBZ      r2,|L1.998|
;;;1866     uint32_t tmpreg_IE;
;;;1867   
;;;1868     /* Check the parameters */
;;;1869     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1870     assert_param(IS_TIMER_STATUS(TIMER_IT));
;;;1871     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1872   
;;;1873     tmpreg_IE = TIMERx->IE;
;;;1874   
;;;1875     /* Form new value */
;;;1876     if (NewState != DISABLE)
;;;1877     {
;;;1878       /* Enable the TIMERx Interrupt requests by setting bits in the IE register */
;;;1879       tmpreg_IE |= TIMER_IT;
0003e2  430b              ORRS     r3,r3,r1
0003e4  e000              B        |L1.1000|
                  |L1.998|
;;;1880     }
;;;1881     else
;;;1882     {
;;;1883       /* Disable the TIMERx Interrupt requests by clearing bits in the IE register */
;;;1884       tmpreg_IE &= ~TIMER_IT;
0003e6  438b              BICS     r3,r3,r1
                  |L1.1000|
;;;1885     }
;;;1886   
;;;1887     /* Configure CNTRL register with new value */
;;;1888     TIMERx->IE = tmpreg_IE;
0003e8  6583              STR      r3,[r0,#0x58]
;;;1889   }
0003ea  4770              BX       lr
;;;1890   
                          ENDP

                  TIMER_GetITStatus PROC
;;;1914     */
;;;1915   ITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT)
0003ec  6d42              LDR      r2,[r0,#0x54]
;;;1916   {
;;;1917     ITStatus bitstatus;
;;;1918     uint32_t tmpreg;
;;;1919   
;;;1920     /* Check the parameters */
;;;1921     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1922     assert_param(IS_TIMER_STATUS_FLAG(TIMER_IT));
;;;1923   
;;;1924     tmpreg = TIMERx->STATUS & TIMERx->IE & TIMER_IT;
0003ee  6d80              LDR      r0,[r0,#0x58]
0003f0  4002              ANDS     r2,r2,r0
0003f2  420a              TST      r2,r1
0003f4  d101              BNE      |L1.1018|
;;;1925   
;;;1926     if (tmpreg == 0)
;;;1927     {
;;;1928       bitstatus = RESET;
0003f6  2000              MOVS     r0,#0
;;;1929     }
;;;1930     else
;;;1931     {
;;;1932       bitstatus = SET;
;;;1933     }
;;;1934   
;;;1935     return bitstatus;
;;;1936   }
0003f8  4770              BX       lr
                  |L1.1018|
0003fa  2001              MOVS     r0,#1                 ;1932
0003fc  4770              BX       lr
;;;1937   
                          ENDP

                  TIMER_BRGInit PROC
;;;1953     */
;;;1954   void TIMER_BRGInit ( MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG ) {
0003fe  4b10              LDR      r3,|L1.1088|
000400  b510              PUSH     {r4,lr}
;;;1955   	uint32_t tmpreg;
;;;1956   
;;;1957   	/* Check the parameters */
;;;1958   	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1959   	assert_param(IS_TIMER_CLOCK_BRG(TIMER_BRG));
;;;1960   
;;;1961   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1962   	if(TIMERx == MDR_TIMER4)
;;;1963   		tmpreg = MDR_RST_CLK->UART_CLOCK;
;;;1964   	else
;;;1965   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1966   		tmpreg = MDR_RST_CLK->TIM_CLOCK;
000402  6a5a              LDR      r2,[r3,#0x24]
;;;1967   
;;;1968   	if (TIMERx == MDR_TIMER1) {
000404  4c0f              LDR      r4,|L1.1092|
000406  42a0              CMP      r0,r4
000408  d105              BNE      |L1.1046|
;;;1969   		tmpreg &= ~RST_CLK_TIM_CLOCK_TIM1_BRG_Msk;
00040a  f02200ff          BIC      r0,r2,#0xff
;;;1970   		tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM1_BRG_Pos;
00040e  4308              ORRS     r0,r0,r1
;;;1971   		tmpreg |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN;
000410  f0407280          ORR      r2,r0,#0x1000000
000414  e012              B        |L1.1084|
                  |L1.1046|
;;;1972   	}
;;;1973   	else
;;;1974   		if (TIMERx == MDR_TIMER2) {
000416  4c0c              LDR      r4,|L1.1096|
000418  42a0              CMP      r0,r4
00041a  d106              BNE      |L1.1066|
;;;1975   			tmpreg &= ~RST_CLK_TIM_CLOCK_TIM2_BRG_Msk;
00041c  f422407f          BIC      r0,r2,#0xff00
;;;1976   			tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM2_BRG_Pos;
000420  ea402001          ORR      r0,r0,r1,LSL #8
;;;1977   			tmpreg |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN;
000424  f0407200          ORR      r2,r0,#0x2000000
000428  e008              B        |L1.1084|
                  |L1.1066|
;;;1978   		}
;;;1979   		else
;;;1980   			if (TIMERx == MDR_TIMER3) {
00042a  4c08              LDR      r4,|L1.1100|
00042c  42a0              CMP      r0,r4
00042e  d105              BNE      |L1.1084|
;;;1981   				tmpreg &= ~RST_CLK_TIM_CLOCK_TIM3_BRG_Msk;
000430  f422007f          BIC      r0,r2,#0xff0000
;;;1982   				tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM3_BRG_Pos;
000434  ea404001          ORR      r0,r0,r1,LSL #16
;;;1983   				tmpreg |= RST_CLK_TIM_CLOCK_TIM3_CLK_EN;
000438  f0406280          ORR      r2,r0,#0x4000000
                  |L1.1084|
;;;1984   			}
;;;1985   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1986   			else
;;;1987   				if(TIMERx == MDR_TIMER4) {
;;;1988   					tmpreg &= ~RST_CLK_UART_CLOCK_TIM4_BRG_Msk;
;;;1989   					tmpreg |= TIMER_BRG << RST_CLK_UART_CLOCK_TIM4_BRG_Pos;
;;;1990   					tmpreg |= RST_CLK_UART_CLOCK_TIM4_CLK_EN;
;;;1991   				} // if(TIMERx == MDR_TIMER4) {
;;;1992   #endif // #if ( (defined (USE_MDR1986VE3) ) || (defined (MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1993   
;;;1994   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1995   	if(TIMERx == MDR_TIMER4)
;;;1996   		MDR_RST_CLK->UART_CLOCK = tmpreg;
;;;1997   	else
;;;1998   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1999   		MDR_RST_CLK->TIM_CLOCK = tmpreg;
00043c  625a              STR      r2,[r3,#0x24]
;;;2000   
;;;2001   }
00043e  bd10              POP      {r4,pc}
;;;2002   
                          ENDP

                  |L1.1088|
                          DCD      0x40020000
                  |L1.1092|
                          DCD      0x40070000
                  |L1.1096|
                          DCD      0x40078000
                  |L1.1100|
                          DCD      0x40080000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___17_MDR32F9Qx_timer_c_566b03da____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH|
#line 144
|__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
