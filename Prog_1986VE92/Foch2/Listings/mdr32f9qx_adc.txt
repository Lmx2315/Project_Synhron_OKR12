; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list -c --asm --interleave -o.\objects\mdr32f9qx_adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mdr32f9qx_adc.d --cpu=Cortex-M3 --apcs=interwork -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE -IC:\SOFT_project\Mk\Project_Synhron_OKR12\Prog_1986VE92\Foch2\RTE\Device\MDR1986BE92 -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=513 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 -W --enum_is_int --signed_chars C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;45       */
;;;46     void ADC_DeInit ( void )
000000  48cc              LDR      r0,|L1.820|
;;;47     {
;;;48       MDR_ADC->ADC1_CFG = 0;
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
;;;49       MDR_ADC->ADC2_CFG = 0;
000006  6041              STR      r1,[r0,#4]
;;;50       MDR_ADC->ADC1_H_LEVEL = 0;
000008  6081              STR      r1,[r0,#8]
;;;51       MDR_ADC->ADC1_L_LEVEL = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;52       MDR_ADC->ADC1_RESULT;
00000c  6982              LDR      r2,[r0,#0x18]
;;;53       MDR_ADC->ADC1_STATUS = 0;
00000e  6201              STR      r1,[r0,#0x20]
;;;54       MDR_ADC->ADC1_CHSEL = 0;
000010  6281              STR      r1,[r0,#0x28]
;;;55     
;;;56     #if defined ( USE_MDR1986VE9x ) /* For Cortex M3 */
;;;57       MDR_ADC->ADC2_H_LEVEL = 0;
000012  60c1              STR      r1,[r0,#0xc]
;;;58       MDR_ADC->ADC2_L_LEVEL = 0;
000014  6141              STR      r1,[r0,#0x14]
;;;59       MDR_ADC->ADC2_RESULT;
000016  69c2              LDR      r2,[r0,#0x1c]
;;;60       MDR_ADC->ADC2_STATUS = 0;
000018  6241              STR      r1,[r0,#0x24]
;;;61       MDR_ADC->ADC2_CHSEL = 0;
00001a  62c1              STR      r1,[r0,#0x2c]
;;;62     #endif // #if defined ( USE_MDR1986VE9x ) /* For Cortex M3 */
;;;63     
;;;64     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;65       MDR_ADC->ADC1_TRIM = 0;
;;;66     #endif
;;;67     }
00001c  4770              BX       lr
;;;68     
                          ENDP

                  ADC_Init PROC
;;;76       */
;;;77     void ADC_Init(const ADC_InitTypeDef* ADC_InitStruct)
00001e  e9d01202          LDRD     r1,r2,[r0,#8]
;;;78     {
;;;79       uint32_t tmpreg_CFG;
;;;80       uint32_t tmpreg_MSK;
;;;81     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;82       uint32_t tmpreg_TRIM;
;;;83     #endif
;;;84     
;;;85       /* Check the parameters */
;;;86     #if defined (USE_MDR1986VE9x)
;;;87       assert_param(IS_ADC_SYNC_MODE(ADC_InitStruct->ADC_SynchronousMode));
;;;88     #endif
;;;89       assert_param(IS_ADC_START_DELAY_VALUE(ADC_InitStruct->ADC_StartDelay));
;;;90       assert_param(IS_ADC_TEMP_SENSOR_CONFIG(ADC_InitStruct->ADC_TempSensor));
;;;91       assert_param(IS_ADC_TEMP_SENSOR_AMP_CONFIG(ADC_InitStruct->ADC_TempSensorAmplifier));
;;;92       assert_param(IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(ADC_InitStruct->ADC_TempSensorConversion));
;;;93       assert_param(IS_ADC_VREF_CONVERSION_CONFIG(ADC_InitStruct->ADC_IntVRefConversion));
;;;94       assert_param(IS_ADC_VREF_TRIMMING_VALUE(ADC_InitStruct->ADC_IntVRefTrimming));
;;;95     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;96       assert_param(IS_ADC_INT_VREF_AMPLIFIER(ADC_InitStruct->ADC_IntVRefAmplifier));
;;;97     #endif
;;;98     
;;;99       tmpreg_CFG = (ADC_InitStruct->ADC_StartDelay << ADC1_CFG_DELAY_ADC_Pos)
000022  4411              ADD      r1,r1,r2
000024  7903              LDRB     r3,[r0,#4]
000026  6902              LDR      r2,[r0,#0x10]
000028  eb027203          ADD      r2,r2,r3,LSL #28
00002c  4411              ADD      r1,r1,r2
00002e  6942              LDR      r2,[r0,#0x14]
000030  4411              ADD      r1,r1,r2
;;;100                 + ADC_InitStruct->ADC_TempSensor
;;;101                 + ADC_InitStruct->ADC_TempSensorAmplifier
;;;102                 + ADC_InitStruct->ADC_TempSensorConversion
;;;103                 + ADC_InitStruct->ADC_IntVRefConversion;
;;;104    
;;;105    #if defined( USE_MDR1986VE9x ) /* For Cortex M3*/
;;;106      tmpreg_CFG += (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_CFG_TR_Pos)
000032  6802              LDR      r2,[r0,#0]
000034  8b00              LDRH     r0,[r0,#0x18]
000036  eb015040          ADD      r0,r1,r0,LSL #21
00003a  1811              ADDS     r1,r2,r0
;;;107                 +   ADC_InitStruct->ADC_SynchronousMode;
;;;108    #endif // #if defined(USE_MDR1986VE9x) /* For Cortex M3*/
;;;109    
;;;110      tmpreg_MSK = ADC1_CFG_DELAY_ADC_Msk
;;;111                 | ADC1_CFG_TS_EN
;;;112                 | ADC1_CFG_TS_BUF_EN
;;;113                 | ADC1_CFG_SEL_TS
;;;114                 | ADC1_CFG_SEL_VREF;
;;;115    #if defined( USE_MDR1986VE9x ) /* For Cortex M3*/
;;;116      tmpreg_MSK |= ADC1_CFG_TR_Msk
;;;117                 |  ADC1_CFG_SYNC_CONVER;
;;;118    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;119      tmpreg_TRIM = (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_TRIM_TS_TRIM_Pos)
;;;120              | ADC_InitStruct->ADC_IntVRefAmplifier;
;;;121      MDR_ADC->ADC1_TRIM  = tmpreg_TRIM;
;;;122    #endif
;;;123    
;;;124      MDR_ADC->ADC1_CFG = (MDR_ADC->ADC1_CFG & ~tmpreg_MSK) + tmpreg_CFG;
00003c  4abd              LDR      r2,|L1.820|
;;;125    }
00003e  48be              LDR      r0,|L1.824|
000040  6813              LDR      r3,[r2,#0]            ;124
000042  4383              BICS     r3,r3,r0              ;124
000044  1858              ADDS     r0,r3,r1              ;124
000046  6010              STR      r0,[r2,#0]            ;124
000048  4770              BX       lr
;;;126    
                          ENDP

                  ADC_StructInit PROC
;;;132      */
;;;133    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
00004a  2100              MOVS     r1,#0
;;;134    {
;;;135    
;;;136    #if defined( USE_MDR1986VE9x )
;;;137      ADC_InitStruct->ADC_SynchronousMode     = ADC_SyncMode_Independent;
;;;138    #endif
;;;139    
;;;140      ADC_InitStruct->ADC_StartDelay        	= 0;
00004c  6001              STR      r1,[r0,#0]
;;;141      ADC_InitStruct->ADC_TempSensor        	= ADC_TEMP_SENSOR_Disable;
00004e  6041              STR      r1,[r0,#4]
;;;142      ADC_InitStruct->ADC_TempSensorAmplifier   = ADC_TEMP_SENSOR_AMPLIFIER_Disable;
000050  6081              STR      r1,[r0,#8]
;;;143      ADC_InitStruct->ADC_TempSensorConversion  = ADC_TEMP_SENSOR_CONVERSION_Disable;
000052  60c1              STR      r1,[r0,#0xc]
;;;144      ADC_InitStruct->ADC_IntVRefConversion     = ADC_VREF_CONVERSION_Disable;
000054  6101              STR      r1,[r0,#0x10]
;;;145      ADC_InitStruct->ADC_IntVRefTrimming     	= 0;
000056  6141              STR      r1,[r0,#0x14]
000058  6181              STR      r1,[r0,#0x18]
;;;146    
;;;147    #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
;;;148      ADC_InitStruct->ADC_IntVRefAmplifier    	= ADC_INT_VREF_AMPLIFIER_Disable;
;;;149    #endif
;;;150    }
00005a  4770              BX       lr
;;;151    
                          ENDP

                  ADC_SetTrim PROC
;;;157      */
;;;158    void ADC_SetTrim(uint32_t Trim)
00005c  4ab5              LDR      r2,|L1.820|
;;;159    {
;;;160      uint32_t tmpreg;
;;;161    
;;;162      /* Check the parameters */
;;;163      assert_param(IS_ADC_VREF_TRIMMING_VALUE(Trim));
;;;164    
;;;165    #if defined(USE_MDR1986VE9x) /* For Cortex M3*/
;;;166      tmpreg = MDR_ADC->ADC1_CFG & ~ADC1_CFG_TR_Msk;
00005e  6811              LDR      r1,[r2,#0]
000060  f02171f0          BIC      r1,r1,#0x1e00000
;;;167      MDR_ADC->ADC1_CFG = tmpreg + (Trim << ADC1_CFG_TR_Pos);
000064  eb015040          ADD      r0,r1,r0,LSL #21
000068  6010              STR      r0,[r2,#0]
;;;168    
;;;169    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;170      tmpreg = MDR_ADC->ADC1_TRIM;
;;;171      tmpreg &= ~ADC1_TRIM_TS_TRIM_Msk;
;;;172      tmpreg |= Trim << ADC1_TRIM_TS_TRIM_Pos;
;;;173      MDR_ADC->ADC1_TRIM = tmpreg;
;;;174    #endif
;;;175    }
00006a  4770              BX       lr
;;;176    
                          ENDP

                  ADC1_Init PROC
;;;185      */
;;;186    void ADC1_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
00006c  b530              PUSH     {r4,r5,lr}
;;;187    {
;;;188      uint32_t tmpreg_CFG1;
;;;189      uint32_t tmpreg_CFG2;
;;;190    
;;;191      /* Check the parameters */
;;;192      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;193      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;194      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;195      assert_param(IS_ADC1_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;196      assert_param(IS_ADC1_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;197      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;198      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;199      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;200      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;201      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;202      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;203      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;204    
;;;205      tmpreg_CFG1 = MDR_ADC->ADC1_CFG;
00006e  49b1              LDR      r1,|L1.820|
000070  680a              LDR      r2,[r1,#0]
;;;206    
;;;207      tmpreg_CFG1 &= ~(ADC1_CFG_REG_CLKS
000072  4bb1              LDR      r3,|L1.824|
000074  1cdb              ADDS     r3,r3,#3
000076  401a              ANDS     r2,r2,r3
000078  e9d03400          LDRD     r3,r4,[r0,#0]
;;;208                     | ADC1_CFG_REG_SAMPLE
;;;209                     | ADC1_CFG_REG_CHCH
;;;210                     | ADC1_CFG_REG_CHS_Msk
;;;211                     | ADC1_CFG_REG_RNGC
;;;212                     | ADC1_CFG_M_REF
;;;213                     | ADC1_CFG_REG_DIVCLK_Msk
;;;214                     | ADC1_CFG_DELAY_GO_Msk);
;;;215    
;;;216      tmpreg_CFG1 += ADCx_InitStruct->ADC_ClockSource
00007c  4423              ADD      r3,r3,r4
00007e  e9d04502          LDRD     r4,r5,[r0,#8]
000082  eb041405          ADD      r4,r4,r5,LSL #4
000086  4423              ADD      r3,r3,r4
000088  6944              LDR      r4,[r0,#0x14]
00008a  4423              ADD      r3,r3,r4
00008c  69c4              LDR      r4,[r0,#0x1c]
00008e  4423              ADD      r3,r3,r4
000090  6a44              LDR      r4,[r0,#0x24]
000092  4423              ADD      r3,r3,r4
000094  f8904028          LDRB     r4,[r0,#0x28]
000098  eb036344          ADD      r3,r3,r4,LSL #25
00009c  4413              ADD      r3,r3,r2
;;;217                   + ADCx_InitStruct->ADC_SamplingMode
;;;218                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;219                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC1_CFG_REG_CHS_Pos)
;;;220                   + ADCx_InitStruct->ADC_LevelControl
;;;221                   + ADCx_InitStruct->ADC_VRefSource
;;;222                   + ADCx_InitStruct->ADC_Prescaler
;;;223                   + (ADCx_InitStruct->ADC_DelayGo << ADC1_CFG_DELAY_GO_Pos);
;;;224    
;;;225      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
00009e  684a              LDR      r2,[r1,#4]
;;;226      tmpreg_CFG2 &= ~ADC2_CFG_ADC1_OP;
;;;227      tmpreg_CFG2 += ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC1_OP_Pos;
0000a0  8c04              LDRH     r4,[r0,#0x20]
0000a2  f4223200          BIC      r2,r2,#0x20000        ;226
0000a6  eb024244          ADD      r2,r2,r4,LSL #17
;;;228    
;;;229      MDR_ADC->ADC1_CFG = tmpreg_CFG1;
0000aa  600b              STR      r3,[r1,#0]
;;;230      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
0000ac  604a              STR      r2,[r1,#4]
;;;231    
;;;232      MDR_ADC->ADC1_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
0000ae  8b02              LDRH     r2,[r0,#0x18]
0000b0  610a              STR      r2,[r1,#0x10]
;;;233      MDR_ADC->ADC1_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
0000b2  8b42              LDRH     r2,[r0,#0x1a]
0000b4  608a              STR      r2,[r1,#8]
;;;234      MDR_ADC->ADC1_CHSEL   = ADCx_InitStruct->ADC_Channels;
0000b6  6900              LDR      r0,[r0,#0x10]
0000b8  6288              STR      r0,[r1,#0x28]
;;;235    }
0000ba  bd30              POP      {r4,r5,pc}
;;;236    
                          ENDP

                  ADC2_Init PROC
;;;247      */
;;;248    void ADC2_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
0000bc  b530              PUSH     {r4,r5,lr}
;;;249    {
;;;250      uint32_t tmpreg_CFG2;
;;;251    
;;;252      /* Check the parameters */
;;;253      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;254      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;255      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;256      assert_param(IS_ADC2_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;257      assert_param(IS_ADC2_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;258      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;259      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;260      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;261      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;262      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;263      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;264      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;265    
;;;266      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
0000be  499d              LDR      r1,|L1.820|
0000c0  684a              LDR      r2,[r1,#4]
;;;267    
;;;268      tmpreg_CFG2 &= ~(ADC2_CFG_REG_CLKS
0000c2  4b9e              LDR      r3,|L1.828|
0000c4  401a              ANDS     r2,r2,r3
0000c6  e9d03400          LDRD     r3,r4,[r0,#0]
;;;269                     | ADC2_CFG_REG_SAMPLE
;;;270                     | ADC2_CFG_REG_CHCH
;;;271                     | ADC2_CFG_REG_CHS_Msk
;;;272                     | ADC2_CFG_REG_RNGC
;;;273                     | ADC2_CFG_M_REF
;;;274                     | ADC2_CFG_ADC2_OP
;;;275                     | ADC2_CFG_REG_DIVCLK_Msk
;;;276                     | ADC2_CFG_DELAY_GO_Msk);
;;;277    
;;;278      tmpreg_CFG2 += ADCx_InitStruct->ADC_ClockSource
0000ca  4423              ADD      r3,r3,r4
0000cc  e9d04502          LDRD     r4,r5,[r0,#8]
0000d0  eb041405          ADD      r4,r4,r5,LSL #4
0000d4  4423              ADD      r3,r3,r4
0000d6  6944              LDR      r4,[r0,#0x14]
0000d8  4423              ADD      r3,r3,r4
0000da  69c4              LDR      r4,[r0,#0x1c]
0000dc  4423              ADD      r3,r3,r4
0000de  8c04              LDRH     r4,[r0,#0x20]
0000e0  eb034384          ADD      r3,r3,r4,LSL #18
0000e4  6a44              LDR      r4,[r0,#0x24]
0000e6  4423              ADD      r3,r3,r4
0000e8  f8904028          LDRB     r4,[r0,#0x28]
0000ec  eb036344          ADD      r3,r3,r4,LSL #25
0000f0  441a              ADD      r2,r2,r3
;;;279                   + ADCx_InitStruct->ADC_SamplingMode
;;;280                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;281                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC2_CFG_REG_CHS_Pos)
;;;282                   + ADCx_InitStruct->ADC_LevelControl
;;;283                   + ADCx_InitStruct->ADC_VRefSource
;;;284                   + (ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC2_OP_Pos)
;;;285                   + ADCx_InitStruct->ADC_Prescaler
;;;286                   + (ADCx_InitStruct->ADC_DelayGo << ADC2_CFG_DELAY_GO_Pos);
;;;287    
;;;288      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
0000f2  604a              STR      r2,[r1,#4]
;;;289      MDR_ADC->ADC2_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
0000f4  8b02              LDRH     r2,[r0,#0x18]
0000f6  614a              STR      r2,[r1,#0x14]
;;;290      MDR_ADC->ADC2_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
0000f8  8b42              LDRH     r2,[r0,#0x1a]
0000fa  60ca              STR      r2,[r1,#0xc]
;;;291      MDR_ADC->ADC2_CHSEL   = ADCx_InitStruct->ADC_Channels;
0000fc  6900              LDR      r0,[r0,#0x10]
0000fe  62c8              STR      r0,[r1,#0x2c]
;;;292    }
000100  bd30              POP      {r4,r5,pc}
;;;293    
                          ENDP

                  ADCx_StructInit PROC
;;;301      */
;;;302    void ADCx_StructInit(ADCx_InitTypeDef* ADCx_InitStruct)
000102  2100              MOVS     r1,#0
;;;303    {
;;;304      ADCx_InitStruct->ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU;
;;;305      ADCx_InitStruct->ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
000104  6001              STR      r1,[r0,#0]
;;;306      ADCx_InitStruct->ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000106  6041              STR      r1,[r0,#4]
;;;307      ADCx_InitStruct->ADC_ChannelNumber    = ADC_CH_ADC0;
000108  6081              STR      r1,[r0,#8]
;;;308      ADCx_InitStruct->ADC_Channels         = 0;
00010a  60c1              STR      r1,[r0,#0xc]
;;;309      ADCx_InitStruct->ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
00010c  6101              STR      r1,[r0,#0x10]
;;;310      ADCx_InitStruct->ADC_LowLevel         = 0;
00010e  6141              STR      r1,[r0,#0x14]
000110  8301              STRH     r1,[r0,#0x18]
;;;311      ADCx_InitStruct->ADC_HighLevel        = 0;
000112  8341              STRH     r1,[r0,#0x1a]
;;;312      ADCx_InitStruct->ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL;
;;;313      ADCx_InitStruct->ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT;
000114  61c1              STR      r1,[r0,#0x1c]
;;;314      ADCx_InitStruct->ADC_Prescaler        = ADC_CLK_div_None;
000116  6201              STR      r1,[r0,#0x20]
;;;315      ADCx_InitStruct->ADC_DelayGo          = 0;
000118  6241              STR      r1,[r0,#0x24]
00011a  6281              STR      r1,[r0,#0x28]
;;;316    }
00011c  4770              BX       lr
;;;317    
                          ENDP

                  ADC1_Cmd PROC
;;;323      */
;;;324    void ADC1_Cmd(FunctionalState NewState)
00011e  4a85              LDR      r2,|L1.820|
;;;325    {
;;;326      uint32_t tmpreg_CFG;
;;;327    
;;;328      /* Check the parameters */
;;;329      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;330    
;;;331      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000120  6811              LDR      r1,[r2,#0]
000122  b110              CBZ      r0,|L1.298|
;;;332    
;;;333      /* Form new value */
;;;334      if (NewState != DISABLE)
;;;335      {
;;;336        /* Enable ADC1 by setting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;337        tmpreg_CFG |= ADC1_CFG_REG_ADON;
000124  f0410001          ORR      r0,r1,#1
000128  e001              B        |L1.302|
                  |L1.298|
;;;338      }
;;;339      else
;;;340      {
;;;341        /* Disable ADC1 by resetting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;342        tmpreg_CFG &= ~ADC1_CFG_REG_ADON;
00012a  f0210001          BIC      r0,r1,#1
                  |L1.302|
;;;343      }
;;;344    
;;;345      /* Configure ADC1_CFG register with new value */
;;;346      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00012e  6010              STR      r0,[r2,#0]
;;;347    }
000130  4770              BX       lr
;;;348    
                          ENDP

                  ADC2_Cmd PROC
;;;357      */
;;;358    void ADC2_Cmd(FunctionalState NewState)
000132  4a80              LDR      r2,|L1.820|
;;;359    {
;;;360      uint32_t tmpreg_CFG;
;;;361    
;;;362      /* Check the parameters */
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;364    
;;;365      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000134  6851              LDR      r1,[r2,#4]
000136  b110              CBZ      r0,|L1.318|
;;;366    
;;;367      /* Form new value */
;;;368      if (NewState != DISABLE)
;;;369      {
;;;370        /* Enable ADC2 by setting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;371        tmpreg_CFG |= ADC2_CFG_REG_ADON;
000138  f0410001          ORR      r0,r1,#1
00013c  e001              B        |L1.322|
                  |L1.318|
;;;372      }
;;;373      else
;;;374      {
;;;375        /* Disable ADC2 by resetting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;376        tmpreg_CFG &= ~ADC2_CFG_REG_ADON;
00013e  f0210001          BIC      r0,r1,#1
                  |L1.322|
;;;377      }
;;;378    
;;;379      /* Configure ADC2_CFG register with new value */
;;;380      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000142  6050              STR      r0,[r2,#4]
;;;381    }
000144  4770              BX       lr
;;;382    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetChannel PROC
;;;388      */
;;;389    void ADC1_SetChannel(uint32_t Channel)
000146  4a7b              LDR      r2,|L1.820|
;;;390    {
;;;391      uint32_t tmpreg_CFG;
;;;392    
;;;393      /* Check the parameters */
;;;394      assert_param(IS_ADC1_CH_NUM(Channel));
;;;395    
;;;396      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000148  6811              LDR      r1,[r2,#0]
;;;397      tmpreg_CFG &= ~ADC1_CFG_REG_CHS_Msk;
00014a  f42171f8          BIC      r1,r1,#0x1f0
;;;398      tmpreg_CFG += Channel << ADC1_CFG_REG_CHS_Pos;
00014e  eb011000          ADD      r0,r1,r0,LSL #4
;;;399      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000152  6010              STR      r0,[r2,#0]
;;;400    }
000154  4770              BX       lr
;;;401    
                          ENDP

                  ADC2_SetChannel PROC
;;;409      */
;;;410    void ADC2_SetChannel(uint32_t Channel)
000156  4a77              LDR      r2,|L1.820|
;;;411    {
;;;412      uint32_t tmpreg_CFG;
;;;413    
;;;414      /* Check the parameters */
;;;415      assert_param(IS_ADC2_CH_NUM(Channel));
;;;416    
;;;417      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000158  6851              LDR      r1,[r2,#4]
;;;418      tmpreg_CFG &= ~ADC2_CFG_REG_CHS_Msk;
00015a  f42171f8          BIC      r1,r1,#0x1f0
;;;419      tmpreg_CFG += Channel << ADC2_CFG_REG_CHS_Pos;
00015e  eb011000          ADD      r0,r1,r0,LSL #4
;;;420      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000162  6050              STR      r0,[r2,#4]
;;;421    }
000164  4770              BX       lr
;;;422    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetChannels PROC
;;;428      */
;;;429    void ADC1_SetChannels(uint32_t ChannelMask)
000166  4973              LDR      r1,|L1.820|
;;;430    {
;;;431      /* Check the parameters */
;;;432      assert_param(IS_ADC1_CH_MASK(ChannelMask));
;;;433    
;;;434      MDR_ADC->ADC1_CHSEL = ChannelMask;
000168  6288              STR      r0,[r1,#0x28]
;;;435    }
00016a  4770              BX       lr
;;;436    
                          ENDP

                  ADC2_SetChannels PROC
;;;442      */
;;;443    void ADC2_SetChannels(uint32_t ChannelMask)
00016c  4971              LDR      r1,|L1.820|
;;;444    {
;;;445      /* Check the parameters */
;;;446      assert_param(IS_ADC2_CH_MASK(ChannelMask));
;;;447    
;;;448      MDR_ADC->ADC2_CHSEL = ChannelMask;
00016e  62c8              STR      r0,[r1,#0x2c]
;;;449    }
000170  4770              BX       lr
;;;450    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_OperationModeConfig PROC
;;;457      */
;;;458    void ADC1_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
000172  4b70              LDR      r3,|L1.820|
;;;459    {
;;;460      uint32_t tmpreg_CFG;
;;;461    
;;;462      /* Check the parameters */
;;;463      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;464      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;465    
;;;466      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000174  681a              LDR      r2,[r3,#0]
;;;467      tmpreg_CFG &= ~(ADC1_CFG_REG_SAMPLE | ADC1_CFG_REG_CHCH);
;;;468      tmpreg_CFG += SamplingMode + SwitchingMode;
000176  4408              ADD      r0,r0,r1
000178  f4227202          BIC      r2,r2,#0x208          ;467
00017c  4410              ADD      r0,r0,r2
;;;469      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00017e  6018              STR      r0,[r3,#0]
;;;470    }
000180  4770              BX       lr
;;;471    
                          ENDP

                  ADC2_OperationModeConfig PROC
;;;480      */
;;;481    void ADC2_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
000182  4b6c              LDR      r3,|L1.820|
;;;482    {
;;;483      uint32_t tmpreg_CFG;
;;;484    
;;;485      /* Check the parameters */
;;;486      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;487      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;488    
;;;489      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000184  685a              LDR      r2,[r3,#4]
;;;490      tmpreg_CFG &= ~(ADC2_CFG_REG_SAMPLE | ADC2_CFG_REG_CHCH);
;;;491      tmpreg_CFG += SamplingMode + SwitchingMode;
000186  4408              ADD      r0,r0,r1
000188  f4227202          BIC      r2,r2,#0x208          ;490
00018c  4410              ADD      r0,r0,r2
;;;492      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00018e  6058              STR      r0,[r3,#4]
;;;493    }
000190  4770              BX       lr
;;;494    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SamplingModeConfig PROC
;;;500      */
;;;501    void ADC1_SamplingModeConfig(uint32_t SamplingMode)
000192  4a68              LDR      r2,|L1.820|
;;;502    {
;;;503      uint32_t tmpreg_CFG;
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;507    
;;;508      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000194  6811              LDR      r1,[r2,#0]
;;;509      tmpreg_CFG &= ~ADC1_CFG_REG_SAMPLE;
000196  f0210108          BIC      r1,r1,#8
;;;510      tmpreg_CFG += SamplingMode;
00019a  4408              ADD      r0,r0,r1
;;;511      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00019c  6010              STR      r0,[r2,#0]
;;;512    }
00019e  4770              BX       lr
;;;513    
                          ENDP

                  ADC2_SamplingModeConfig PROC
;;;521      */
;;;522    void ADC2_SamplingModeConfig(uint32_t SamplingMode)
0001a0  4a64              LDR      r2,|L1.820|
;;;523    {
;;;524      uint32_t tmpreg_CFG;
;;;525    
;;;526      /* Check the parameters */
;;;527      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;528    
;;;529      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001a2  6851              LDR      r1,[r2,#4]
;;;530      tmpreg_CFG &= ~ADC2_CFG_REG_SAMPLE;
0001a4  f0210108          BIC      r1,r1,#8
;;;531      tmpreg_CFG += SamplingMode;
0001a8  4408              ADD      r0,r0,r1
;;;532      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001aa  6050              STR      r0,[r2,#4]
;;;533    }
0001ac  4770              BX       lr
;;;534    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_ChannelSwithingConfig PROC
;;;540      */
;;;541    void ADC1_ChannelSwithingConfig(uint32_t SwitchingMode)
0001ae  4a61              LDR      r2,|L1.820|
;;;542    {
;;;543      uint32_t tmpreg_CFG;
;;;544    
;;;545      /* Check the parameters */
;;;546      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;547    
;;;548      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001b0  6811              LDR      r1,[r2,#0]
;;;549      tmpreg_CFG &= ~ADC1_CFG_REG_CHCH;
0001b2  f4217100          BIC      r1,r1,#0x200
;;;550      tmpreg_CFG += SwitchingMode;
0001b6  4408              ADD      r0,r0,r1
;;;551      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001b8  6010              STR      r0,[r2,#0]
;;;552    }
0001ba  4770              BX       lr
;;;553    
                          ENDP

                  ADC2_ChannelSwithingConfig PROC
;;;561      */
;;;562    void ADC2_ChannelSwithingConfig(uint32_t SwitchingMode)
0001bc  4a5d              LDR      r2,|L1.820|
;;;563    {
;;;564      uint32_t tmpreg_CFG;
;;;565    
;;;566      /* Check the parameters */
;;;567      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;568    
;;;569      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001be  6851              LDR      r1,[r2,#4]
;;;570      tmpreg_CFG &= ~ADC2_CFG_REG_CHCH;
0001c0  f4217100          BIC      r1,r1,#0x200
;;;571      tmpreg_CFG += SwitchingMode;
0001c4  4408              ADD      r0,r0,r1
;;;572      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001c6  6050              STR      r0,[r2,#4]
;;;573    }
0001c8  4770              BX       lr
;;;574    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_LevelsConfig PROC
;;;582      */
;;;583    void ADC1_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
0001ca  4b5a              LDR      r3,|L1.820|
;;;584    {
0001cc  b510              PUSH     {r4,lr}
;;;585      uint32_t tmpreg_CFG;
;;;586    
;;;587      /* Check the parameters */
;;;588      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;589      assert_param(IS_ADC_VALUE(LowLevel));
;;;590      assert_param(IS_ADC_VALUE(HighLevel));
;;;591    
;;;592      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001ce  681c              LDR      r4,[r3,#0]
;;;593      tmpreg_CFG &= ~ADC1_CFG_REG_RNGC;
0001d0  f4246480          BIC      r4,r4,#0x400
;;;594      tmpreg_CFG += NewState;
0001d4  4422              ADD      r2,r2,r4
;;;595      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001d6  601a              STR      r2,[r3,#0]
;;;596    
;;;597      MDR_ADC->ADC1_L_LEVEL = LowLevel;
0001d8  6118              STR      r0,[r3,#0x10]
;;;598      MDR_ADC->ADC1_H_LEVEL = HighLevel;
0001da  6099              STR      r1,[r3,#8]
;;;599    }
0001dc  bd10              POP      {r4,pc}
;;;600    
                          ENDP

                  ADC2_LevelsConfig PROC
;;;610      */
;;;611    void ADC2_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
0001de  4b55              LDR      r3,|L1.820|
;;;612    {
0001e0  b510              PUSH     {r4,lr}
;;;613      uint32_t tmpreg_CFG;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;617      assert_param(IS_ADC_VALUE(LowLevel));
;;;618      assert_param(IS_ADC_VALUE(HighLevel));
;;;619    
;;;620      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001e2  685c              LDR      r4,[r3,#4]
;;;621      tmpreg_CFG &= ~ADC2_CFG_REG_RNGC;
0001e4  f4246480          BIC      r4,r4,#0x400
;;;622      tmpreg_CFG += NewState;
0001e8  4422              ADD      r2,r2,r4
;;;623      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001ea  605a              STR      r2,[r3,#4]
;;;624    
;;;625      MDR_ADC->ADC2_L_LEVEL = LowLevel;
0001ec  6158              STR      r0,[r3,#0x14]
;;;626      MDR_ADC->ADC2_H_LEVEL = HighLevel;
0001ee  60d9              STR      r1,[r3,#0xc]
;;;627    }
0001f0  bd10              POP      {r4,pc}
;;;628    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetLowLevel PROC
;;;634      */
;;;635    void ADC1_SetLowLevel(uint32_t LowLevel)
0001f2  4950              LDR      r1,|L1.820|
;;;636    {
;;;637      /* Check the parameters */
;;;638      assert_param(IS_ADC_VALUE(LowLevel));
;;;639    
;;;640      MDR_ADC->ADC1_L_LEVEL = LowLevel;
0001f4  6108              STR      r0,[r1,#0x10]
;;;641    }
0001f6  4770              BX       lr
;;;642    
                          ENDP

                  ADC2_SetLowLevel PROC
;;;648      */
;;;649    void ADC2_SetLowLevel(uint32_t LowLevel)
0001f8  494e              LDR      r1,|L1.820|
;;;650    {
;;;651      /* Check the parameters */
;;;652      assert_param(IS_ADC_VALUE(LowLevel));
;;;653    
;;;654      MDR_ADC->ADC2_L_LEVEL = LowLevel;
0001fa  6148              STR      r0,[r1,#0x14]
;;;655    }
0001fc  4770              BX       lr
;;;656    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetHighLevel PROC
;;;662      */
;;;663    void ADC1_SetHighLevel(uint32_t HighLevel)
0001fe  494d              LDR      r1,|L1.820|
;;;664    {
;;;665      /* Check the parameters */
;;;666      assert_param(IS_ADC_VALUE(HighLevel));
;;;667    
;;;668      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000200  6088              STR      r0,[r1,#8]
;;;669    }
000202  4770              BX       lr
;;;670    
                          ENDP

                  ADC2_SetHighLevel PROC
;;;678      */
;;;679    void ADC2_SetHighLevel(uint32_t HighLevel)
000204  494b              LDR      r1,|L1.820|
;;;680    {
;;;681      /* Check the parameters */
;;;682      assert_param(IS_ADC_VALUE(HighLevel));
;;;683    
;;;684      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000206  60c8              STR      r0,[r1,#0xc]
;;;685    }
000208  4770              BX       lr
;;;686    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_Start PROC
;;;692      */
;;;693    void ADC1_Start(void)
00020a  484a              LDR      r0,|L1.820|
;;;694    {
;;;695      MDR_ADC->ADC1_CFG |= ADC1_CFG_REG_GO;
00020c  6801              LDR      r1,[r0,#0]
00020e  f0410102          ORR      r1,r1,#2
000212  6001              STR      r1,[r0,#0]
;;;696    }
000214  4770              BX       lr
;;;697    
                          ENDP

                  ADC2_Start PROC
;;;705      */
;;;706    void ADC2_Start(void)
000216  4847              LDR      r0,|L1.820|
;;;707    {
;;;708      MDR_ADC->ADC2_CFG |= ADC2_CFG_REG_GO;
000218  6841              LDR      r1,[r0,#4]
00021a  f0410102          ORR      r1,r1,#2
00021e  6041              STR      r1,[r0,#4]
;;;709    }
000220  4770              BX       lr
;;;710    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_GetResult PROC
;;;716      */
;;;717    uint32_t ADC1_GetResult(void)
000222  4844              LDR      r0,|L1.820|
;;;718    {
;;;719      return MDR_ADC->ADC1_RESULT;
000224  6980              LDR      r0,[r0,#0x18]
;;;720    }
000226  4770              BX       lr
;;;721    
                          ENDP

                  ADC2_GetResult PROC
;;;729      */
;;;730    uint32_t ADC2_GetResult(void)
000228  4842              LDR      r0,|L1.820|
;;;731    {
;;;732      return MDR_ADC->ADC2_RESULT;
00022a  69c0              LDR      r0,[r0,#0x1c]
;;;733    }
00022c  4770              BX       lr
;;;734    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC_GetStatus PROC
;;;740      */
;;;741    uint32_t ADC_GetStatus ( void )
00022e  4841              LDR      r0,|L1.820|
;;;742    {
;;;743    #if defined  (USE_MDR1986VE9x) 									/* For Cortex M3 */
;;;744      return MDR_ADC->ADC1_STATUS + (MDR_ADC->ADC2_STATUS << 16);
000230  6a01              LDR      r1,[r0,#0x20]
000232  6a40              LDR      r0,[r0,#0x24]
000234  eb014000          ADD      r0,r1,r0,LSL #16
;;;745    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) 	/* For Cortex M1 */
;;;746      return MDR_ADC->ADC1_STATUS;
;;;747    #endif
;;;748    }
000238  4770              BX       lr
;;;749    
                          ENDP

                  ADC1_GetStatus PROC
;;;754      */
;;;755    uint32_t ADC1_GetStatus(void)
00023a  483e              LDR      r0,|L1.820|
;;;756    {
;;;757      return MDR_ADC->ADC1_STATUS;
00023c  6a00              LDR      r0,[r0,#0x20]
;;;758    }
00023e  4770              BX       lr
;;;759    
                          ENDP

                  ADC2_GetStatus PROC
;;;767      */
;;;768    uint32_t ADC2_GetStatus(void)
000240  483c              LDR      r0,|L1.820|
;;;769    {
;;;770      return MDR_ADC->ADC2_STATUS;
000242  6a40              LDR      r0,[r0,#0x24]
;;;771    }
000244  4770              BX       lr
;;;772    #endif // #ifdef USE_MDR1986VE9x /* For Cortex M3 */
                          ENDP

                  ADC_GetFlagStatus PROC
;;;785      */
;;;786    FlagStatus ADC_GetFlagStatus(uint32_t Flag)
000246  b500              PUSH     {lr}
;;;787    {
000248  4602              MOV      r2,r0
;;;788      FlagStatus bitstatus;
;;;789    
;;;790      /* Check the parameters */
;;;791      assert_param(IS_ADC_STATUS_FLAG(Flag));
;;;792    
;;;793      if ((ADC_GetStatus() & Flag) == 0)
00024a  f7fffffe          BL       ADC_GetStatus
00024e  4010              ANDS     r0,r0,r2
000250  d000              BEQ      |L1.596|
;;;794      {
;;;795        bitstatus = RESET;
;;;796      }
;;;797      else
;;;798      {
;;;799        bitstatus = SET;
000252  2001              MOVS     r0,#1
                  |L1.596|
;;;800      }
;;;801    
;;;802      return bitstatus;
;;;803    }
000254  bd00              POP      {pc}
;;;804    
                          ENDP

                  ADC1_GetFlagStatus PROC
;;;813      */
;;;814    FlagStatus ADC1_GetFlagStatus(uint32_t Flag)
000256  4937              LDR      r1,|L1.820|
;;;815    {
;;;816      FlagStatus bitstatus;
;;;817    
;;;818      /* Check the parameters */
;;;819      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;820    
;;;821      if ((MDR_ADC->ADC1_STATUS & Flag) == 0)
000258  6a09              LDR      r1,[r1,#0x20]
00025a  4201              TST      r1,r0
00025c  d101              BNE      |L1.610|
;;;822      {
;;;823        bitstatus = RESET;
00025e  2000              MOVS     r0,#0
;;;824      }
;;;825      else
;;;826      {
;;;827        bitstatus = SET;
;;;828      }
;;;829    
;;;830      return bitstatus;
;;;831    }
000260  4770              BX       lr
                  |L1.610|
000262  2001              MOVS     r0,#1                 ;827
000264  4770              BX       lr
;;;832    
                          ENDP

                  ADC2_GetFlagStatus PROC
;;;844      */
;;;845    FlagStatus ADC2_GetFlagStatus(uint32_t Flag)
000266  4933              LDR      r1,|L1.820|
;;;846    {
;;;847      FlagStatus bitstatus;
;;;848    
;;;849      /* Check the parameters */
;;;850      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;851    
;;;852      if ((MDR_ADC->ADC2_STATUS & Flag) == 0)
000268  6a49              LDR      r1,[r1,#0x24]
00026a  4201              TST      r1,r0
00026c  d101              BNE      |L1.626|
;;;853      {
;;;854        bitstatus = RESET;
00026e  2000              MOVS     r0,#0
;;;855      }
;;;856      else
;;;857      {
;;;858        bitstatus = SET;
;;;859      }
;;;860    
;;;861      return bitstatus;
;;;862    }
000270  4770              BX       lr
                  |L1.626|
000272  2001              MOVS     r0,#1                 ;858
000274  4770              BX       lr
;;;863    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_ClearOverwriteFlag PROC
;;;869      */
;;;870    void ADC1_ClearOverwriteFlag(void)
000276  482f              LDR      r0,|L1.820|
;;;871    {
;;;872      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OVERWRITE;
000278  6a01              LDR      r1,[r0,#0x20]
00027a  f0210101          BIC      r1,r1,#1
00027e  6201              STR      r1,[r0,#0x20]
;;;873    }
000280  4770              BX       lr
;;;874    
                          ENDP

                  ADC2_ClearOverwriteFlag PROC
;;;882      */
;;;883    void ADC2_ClearOverwriteFlag(void)
000282  482c              LDR      r0,|L1.820|
;;;884    {
;;;885      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OVERWRITE;
000284  6a41              LDR      r1,[r0,#0x24]
000286  f0210101          BIC      r1,r1,#1
00028a  6241              STR      r1,[r0,#0x24]
;;;886    }
00028c  4770              BX       lr
;;;887    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_ClearOutOfRangeFlag PROC
;;;893      */
;;;894    void ADC1_ClearOutOfRangeFlag(void)
00028e  4829              LDR      r0,|L1.820|
;;;895    {
;;;896      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
000290  6a01              LDR      r1,[r0,#0x20]
000292  f0210102          BIC      r1,r1,#2
000296  6201              STR      r1,[r0,#0x20]
;;;897    }
000298  4770              BX       lr
;;;898    
                          ENDP

                  ADC2_ClearOutOfRangeFlag PROC
;;;906      */
;;;907    void ADC2_ClearOutOfRangeFlag(void)
00029a  4826              LDR      r0,|L1.820|
;;;908    {
;;;909      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
00029c  6a41              LDR      r1,[r0,#0x24]
00029e  f0210102          BIC      r1,r1,#2
0002a2  6241              STR      r1,[r0,#0x24]
;;;910    }
0002a4  4770              BX       lr
;;;911    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC_ITConfig PROC
;;;924      */
;;;925    void ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002a6  b530              PUSH     {r4,r5,lr}
;;;926    {
;;;927      uint32_t tmpreg_ADC1_IE;
;;;928      uint32_t tmpreg_ADC_IT;
;;;929    #if defined  (USE_MDR1986VE9x)
;;;930      uint32_t tmpreg_ADC2_IE;
;;;931    #endif
;;;932    
;;;933      /* Check the parameters */
;;;934      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;935      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;936    
;;;937      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
0002a8  4d22              LDR      r5,|L1.820|
0002aa  6a2b              LDR      r3,[r5,#0x20]
;;;938      tmpreg_ADC_IT = ADC_IT << 2;
0002ac  0084              LSLS     r4,r0,#2
0002ae  0480              LSLS     r0,r0,#18
;;;939    
;;;940      /* Form new value */
;;;941      if (NewState != DISABLE)
;;;942      {
;;;943        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;944        tmpreg_ADC1_IE |= tmpreg_ADC_IT & 0xFFFF;
0002b0  0c02              LSRS     r2,r0,#16
0002b2  2900              CMP      r1,#0                 ;941
0002b4  d002              BEQ      |L1.700|
0002b6  ea420203          ORR      r2,r2,r3
0002ba  e001              B        |L1.704|
                  |L1.700|
;;;945      }
;;;946      else
;;;947      {
;;;948        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;949        tmpreg_ADC1_IE &= ~(tmpreg_ADC_IT & 0xFFFF);
0002bc  ea230202          BIC      r2,r3,r2
                  |L1.704|
;;;950      }
;;;951    
;;;952      /* Configure ADCx_STATUS registers with new value */
;;;953      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
0002c0  622a              STR      r2,[r5,#0x20]
;;;954    
;;;955    #if defined  (USE_MDR1986VE9x)
;;;956    
;;;957      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
0002c2  6a68              LDR      r0,[r5,#0x24]
;;;958    
;;;959      /* Form new value */
;;;960      if (NewState != DISABLE)
0002c4  d002              BEQ      |L1.716|
;;;961      {
;;;962        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;963        tmpreg_ADC2_IE |= tmpreg_ADC_IT >> 16;
0002c6  ea404014          ORR      r0,r0,r4,LSR #16
0002ca  e001              B        |L1.720|
                  |L1.716|
;;;964      }
;;;965      else
;;;966      {
;;;967        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;968        tmpreg_ADC2_IE &= ~(tmpreg_ADC_IT >> 16);
0002cc  ea204014          BIC      r0,r0,r4,LSR #16
                  |L1.720|
;;;969      }
;;;970      /* Configure ADCx_STATUS registers with new value */
;;;971      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
0002d0  6268              STR      r0,[r5,#0x24]
;;;972    #endif /* #if defined  (USE_MDR1986VE9x) */
;;;973    }
0002d2  bd30              POP      {r4,r5,pc}
;;;974    
                          ENDP

                  ADC1_ITConfig PROC
;;;984      */
;;;985    void ADC1_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002d4  4b17              LDR      r3,|L1.820|
;;;986    {
;;;987      uint32_t tmpreg_ADC1_IE;
;;;988    
;;;989      /* Check the parameters */
;;;990      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;991      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;992    
;;;993      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
0002d6  6a1a              LDR      r2,[r3,#0x20]
0002d8  b111              CBZ      r1,|L1.736|
;;;994    
;;;995      /* Form new value */
;;;996      if (NewState != DISABLE)
;;;997      {
;;;998        /* Enable the ADC Interrupt requests by setting bits in the ADC1_STATUS register */
;;;999        tmpreg_ADC1_IE |= (ADC_IT << 2);
0002da  ea420080          ORR      r0,r2,r0,LSL #2
0002de  e001              B        |L1.740|
                  |L1.736|
;;;1000     }
;;;1001     else
;;;1002     {
;;;1003       /* Disable the ADC Interrupt requests by clearing bits in the ADC1_STATUS register */
;;;1004       tmpreg_ADC1_IE &= ~(ADC_IT << 2);
0002e0  ea220080          BIC      r0,r2,r0,LSL #2
                  |L1.740|
;;;1005     }
;;;1006   
;;;1007     /* Configure ADC1_STATUS registers with new value */
;;;1008     MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
0002e4  6218              STR      r0,[r3,#0x20]
;;;1009   }
0002e6  4770              BX       lr
;;;1010   
                          ENDP

                  ADC2_ITConfig PROC
;;;1023     */
;;;1024   void ADC2_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002e8  4b12              LDR      r3,|L1.820|
;;;1025   {
;;;1026     uint32_t tmpreg_ADC2_IE;
;;;1027   
;;;1028     /* Check the parameters */
;;;1029     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1030     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1031   
;;;1032     tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
0002ea  6a5a              LDR      r2,[r3,#0x24]
0002ec  b111              CBZ      r1,|L1.756|
;;;1033   
;;;1034     /* Form new value */
;;;1035     if (NewState != DISABLE)
;;;1036     {
;;;1037       /* Enable the ADC Interrupt requests by setting bits in the ADC2_STATUS register */
;;;1038       tmpreg_ADC2_IE |= (ADC_IT << 2);
0002ee  ea420080          ORR      r0,r2,r0,LSL #2
0002f2  e001              B        |L1.760|
                  |L1.756|
;;;1039     }
;;;1040     else
;;;1041     {
;;;1042       /* Disable the ADC Interrupt requests by clearing bits in the ADC2_STATUS register */
;;;1043       tmpreg_ADC2_IE &= ~(ADC_IT << 2);
0002f4  ea220080          BIC      r0,r2,r0,LSL #2
                  |L1.760|
;;;1044     }
;;;1045   
;;;1046     /* Configure ADC2_STATUS registers with new value */
;;;1047     MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
0002f8  6258              STR      r0,[r3,#0x24]
;;;1048   }
0002fa  4770              BX       lr
;;;1049   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC_GetITStatus PROC
;;;1060     */
;;;1061   ITStatus ADC_GetITStatus(uint32_t ADC_IT)
0002fc  b500              PUSH     {lr}
;;;1062   {
0002fe  4602              MOV      r2,r0
;;;1063     ITStatus bitstatus;
;;;1064     uint32_t tmpreg;
;;;1065   
;;;1066     /* Check the parameters */
;;;1067     assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;1068   
;;;1069     tmpreg = ADC_GetStatus();
000300  f7fffffe          BL       ADC_GetStatus
;;;1070     tmpreg &= (tmpreg >> 2) & ADC_IT;
000304  ea020190          AND      r1,r2,r0,LSR #2
000308  4201              TST      r1,r0
;;;1071   
;;;1072     if (tmpreg == 0)
00030a  d101              BNE      |L1.784|
;;;1073     {
;;;1074       bitstatus = RESET;
00030c  2000              MOVS     r0,#0
;;;1075     }
;;;1076     else
;;;1077     {
;;;1078       bitstatus = SET;
;;;1079     }
;;;1080   
;;;1081     return bitstatus;
;;;1082   }
00030e  bd00              POP      {pc}
                  |L1.784|
000310  2001              MOVS     r0,#1                 ;1078
000312  bd00              POP      {pc}
;;;1083   
                          ENDP

                  ADC1_GetITStatus PROC
;;;1091     */
;;;1092   ITStatus ADC1_GetITStatus(uint32_t ADC_IT)
000314  4907              LDR      r1,|L1.820|
;;;1093   {
;;;1094     ITStatus bitstatus;
;;;1095     uint32_t tmpreg;
;;;1096   
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1099   
;;;1100     tmpreg = MDR_ADC->ADC1_STATUS;
000316  6a09              LDR      r1,[r1,#0x20]
;;;1101     tmpreg &= (tmpreg >> 2) & ADC_IT;
000318  ea000091          AND      r0,r0,r1,LSR #2
00031c  4008              ANDS     r0,r0,r1
00031e  d000              BEQ      |L1.802|
;;;1102   
;;;1103     if (tmpreg == 0)
;;;1104     {
;;;1105       bitstatus = RESET;
;;;1106     }
;;;1107     else
;;;1108     {
;;;1109       bitstatus = SET;
000320  2001              MOVS     r0,#1
                  |L1.802|
;;;1110     }
;;;1111   
;;;1112     return bitstatus;
;;;1113   }
000322  4770              BX       lr
;;;1114   
                          ENDP

                  ADC2_GetITStatus PROC
;;;1125     */
;;;1126   ITStatus ADC2_GetITStatus(uint32_t ADC_IT)
000324  4903              LDR      r1,|L1.820|
;;;1127   {
;;;1128     ITStatus bitstatus;
;;;1129     uint32_t tmpreg;
;;;1130   
;;;1131     /* Check the parameters */
;;;1132     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1133   
;;;1134     tmpreg = MDR_ADC->ADC2_STATUS;
000326  6a49              LDR      r1,[r1,#0x24]
;;;1135     tmpreg &= (tmpreg >> 2) & ADC_IT;
000328  ea000091          AND      r0,r0,r1,LSR #2
00032c  4008              ANDS     r0,r0,r1
00032e  d000              BEQ      |L1.818|
;;;1136   
;;;1137     if (tmpreg == 0)
;;;1138     {
;;;1139       bitstatus = RESET;
;;;1140     }
;;;1141     else
;;;1142     {
;;;1143       bitstatus = SET;
000330  2001              MOVS     r0,#1
                  |L1.818|
;;;1144     }
;;;1145   
;;;1146     return bitstatus;
;;;1147   }
000332  4770              BX       lr
;;;1148   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L1.820|
                          DCD      0x40088000
                  |L1.824|
                          DCD      0xf1ff0000
                  |L1.828|
                          DCD      0xf1fb0003

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH|
#line 144
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
